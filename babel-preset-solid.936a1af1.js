// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"dKqMn":[function(require,module,exports) {
"use strict";
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "a8fb9c35fdafe466";
module.bundle.HMR_BUNDLE_ID = "dd69e9f9936a1af1";
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = it.call(o);
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        acceptedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] 🚨 Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] ✨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>💡 ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                var oldDeps = modules[asset.id][1];
                for(var dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    var id = oldDeps[dep];
                    var parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id1) {
    var modules = bundle.modules;
    if (!modules) return;
    if (modules[id1]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        var deps = modules[id1][1];
        var orphans = [];
        for(var dep in deps){
            var parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id1];
        delete bundle.cache[id1]; // Now delete the orphans.
        orphans.forEach(function(id) {
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id1);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    var parents = getParents(module.bundle.root, id);
    var accepted = false;
    while(parents.length > 0){
        var v = parents.shift();
        var a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            var p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push.apply(parents, _toConsumableArray(p));
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"3JDr1":[function(require,module,exports) {
const jsxTransform = require("babel-plugin-jsx-dom-expressions");
module.exports = function(context, options = {}) {
    const plugins = [
        [
            jsxTransform,
            Object.assign({
                moduleName: "solid-js/web",
                builtIns: [
                    "For",
                    "Show",
                    "Switch",
                    "Match",
                    "Suspense",
                    "SuspenseList",
                    "Portal",
                    "Index",
                    "Dynamic",
                    "ErrorBoundary"
                ],
                contextToCustomElements: true,
                wrapConditionals: true,
                generate: "dom"
            }, options)
        ]
    ];
    return {
        plugins
    };
};

},{"babel-plugin-jsx-dom-expressions":"45hdX"}],"45hdX":[function(require,module,exports) {
'use strict';
var SyntaxJSX = require('@babel/plugin-syntax-jsx');
var t = require('@babel/types');
var helperModuleImports = require('@babel/helper-module-imports');
var htmlEntities = require('html-entities');
function _interopDefaultLegacy(e) {
    return e && typeof e === 'object' && 'default' in e ? e : {
        'default': e
    };
}
function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) Object.keys(e).forEach(function(k) {
        if (k !== 'default') {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
                enumerable: true,
                get: function() {
                    return e[k];
                }
            });
        }
    });
    n["default"] = e;
    return Object.freeze(n);
}
var SyntaxJSX__default = /*#__PURE__*/ _interopDefaultLegacy(SyntaxJSX);
var t__namespace = /*#__PURE__*/ _interopNamespace(t);
const booleans = [
    "allowfullscreen",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "disabled",
    "formnovalidate",
    "hidden",
    "indeterminate",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "seamless",
    "selected"
];
const BooleanAttributes = new Set(booleans);
const Properties = new Set([
    "className",
    "value",
    "readOnly",
    "formNoValidate",
    "isMap",
    "noModule",
    "playsInline",
    ...booleans
]);
const ChildProperties = new Set([
    "innerHTML",
    "textContent",
    "innerText",
    "children"
]);
// React Compat
const Aliases = {
    className: "class",
    htmlFor: "for"
};
const PropAliases = {
    class: "className",
    formnovalidate: "formNoValidate",
    ismap: "isMap",
    nomodule: "noModule",
    playsinline: "playsInline",
    readonly: "readOnly"
};
// list of Element events that will be delegated
const DelegatedEvents = new Set([
    "beforeinput",
    "click",
    "dblclick",
    "contextmenu",
    "focusin",
    "focusout",
    "input",
    "keydown",
    "keyup",
    "mousedown",
    "mousemove",
    "mouseout",
    "mouseover",
    "mouseup",
    "pointerdown",
    "pointermove",
    "pointerout",
    "pointerover",
    "pointerup",
    "touchend",
    "touchmove",
    "touchstart"
]);
const SVGElements = new Set([
    // "a",
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animate",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "circle",
    "clipPath",
    "color-profile",
    "cursor",
    "defs",
    "desc",
    "ellipse",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "filter",
    "font",
    "font-face",
    "font-face-format",
    "font-face-name",
    "font-face-src",
    "font-face-uri",
    "foreignObject",
    "g",
    "glyph",
    "glyphRef",
    "hkern",
    "image",
    "line",
    "linearGradient",
    "marker",
    "mask",
    "metadata",
    "missing-glyph",
    "mpath",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    // "script",
    "set",
    "stop",
    // "style",
    "svg",
    "switch",
    "symbol",
    "text",
    "textPath",
    // "title",
    "tref",
    "tspan",
    "use",
    "view",
    "vkern"
]);
const SVGNamespace = {
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace"
};
var VoidElements = [
    'area',
    'base',
    'br',
    'col',
    'embed',
    'hr',
    'img',
    'input',
    'keygen',
    'link',
    'menuitem',
    'meta',
    'param',
    'source',
    'track',
    'wbr'
];
const reservedNameSpaces = new Set([
    "class",
    "on",
    "oncapture",
    "style",
    "use",
    "prop",
    "attr"
]);
function getConfig(path) {
    return path.hub.file.metadata.config;
}
function registerImportMethod(path, name) {
    const imports = path.scope.getProgramParent().data.imports || (path.scope.getProgramParent().data.imports = new Set());
    const identifier = t__namespace.identifier(`_$${name}`);
    if (!imports.has(name)) {
        helperModuleImports.addNamed(path, name, getConfig(path).moduleName, {
            nameHint: `_$${name}`
        });
        imports.add(name);
    }
    return identifier;
}
function jsxElementNameToString(node) {
    if (t__namespace.isJSXMemberExpression(node)) return `${jsxElementNameToString(node.object)}.${node.property.name}`;
    if (t__namespace.isJSXIdentifier(node) || t__namespace.isIdentifier(node)) return node.name;
    return `${node.namespace.name}:${node.name.name}`;
}
function getTagName(tag) {
    const jsxName = tag.openingElement.name;
    return jsxElementNameToString(jsxName);
}
function isComponent(tagName) {
    return tagName[0] && tagName[0].toLowerCase() !== tagName[0] || tagName.includes(".") || /[^a-zA-Z]/.test(tagName[0]);
}
function isDynamic(path, { checkMember , checkTags , checkCallExpressions =true , native  }) {
    const config1 = getConfig(path);
    if (config1.generate === "ssr" && native) {
        checkMember = false;
        checkCallExpressions = false;
    }
    const expr = path.node;
    if (t__namespace.isFunction(expr)) return false;
    if (expr.leadingComments && expr.leadingComments[0] && expr.leadingComments[0].value.trim() === config1.staticMarker) {
        expr.leadingComments.shift();
        return false;
    }
    if (checkCallExpressions && t__namespace.isCallExpression(expr) || checkMember && (t__namespace.isMemberExpression(expr) || t__namespace.isOptionalMemberExpression(expr)) || checkTags && (t__namespace.isJSXElement(expr) || t__namespace.isJSXFragment(expr))) return true;
    let dynamic;
    path.traverse({
        Function (p) {
            if (t__namespace.isObjectMethod(p.node) && p.node.computed) dynamic = isDynamic(p.get("key"), {
                checkMember,
                checkTags,
                checkCallExpressions,
                native
            });
            p.skip();
        },
        CallExpression (p) {
            checkCallExpressions && (dynamic = true) && p.stop();
        },
        MemberExpression (p) {
            checkMember && (dynamic = true) && p.stop();
        },
        OptionalMemberExpression (p) {
            checkMember && (dynamic = true) && p.stop();
        },
        JSXElement (p) {
            checkTags ? (dynamic = true, p.stop()) : p.skip();
        },
        JSXFragment (p) {
            checkTags ? (dynamic = true, p.stop()) : p.skip();
        }
    });
    return dynamic;
}
function getStaticExpression(path) {
    const node = path.node;
    let value, type;
    return t__namespace.isJSXExpressionContainer(node) && t__namespace.isJSXElement(path.parent) && !isComponent(getTagName(path.parent)) && (value = path.get("expression").evaluate().value) !== undefined && ((type = typeof value) === "string" || type === "number") && value;
}
// remove unnecessary JSX Text nodes
function filterChildren(children) {
    return children.filter(({ node: child  })=>!(t__namespace.isJSXExpressionContainer(child) && t__namespace.isJSXEmptyExpression(child.expression)) && (!t__namespace.isJSXText(child) || !/^[\r\n]\s*$/.test(child.extra.raw))
    );
}
function checkLength(children) {
    let i = 0;
    children.forEach((path)=>{
        const child = path.node;
        !(t__namespace.isJSXExpressionContainer(child) && t__namespace.isJSXEmptyExpression(child.expression)) && (!t__namespace.isJSXText(child) || !/^\s*$/.test(child.extra.raw)) && i++;
    });
    return i > 1;
}
function trimWhitespace(text) {
    text = text.replace(/\r/g, "");
    if (/\n/g.test(text)) text = text.split("\n").map((t1, i)=>i ? t1.replace(/^\s*/g, "") : t1
    ).filter((s)=>!/^\s*$/.test(s)
    ).join(" ");
    return text.replace(/\s+/g, " ");
}
function toEventName(name) {
    return name.slice(2).toLowerCase();
}
function toPropertyName(name) {
    return name.toLowerCase().replace(/-([a-z])/g, (_, w)=>w.toUpperCase()
    );
}
function wrappedByText(list, startIndex) {
    let index1 = startIndex, wrapped;
    while(--index1 >= 0){
        const node = list[index1];
        if (!node) continue;
        if (node.text) {
            wrapped = true;
            break;
        }
        if (node.id) return false;
    }
    if (!wrapped) return false;
    index1 = startIndex;
    while(++index1 < list.length){
        const node = list[index1];
        if (!node) continue;
        if (node.text) return true;
        if (node.id) return false;
    }
    return false;
}
function transformCondition(path, inline, deep) {
    const config2 = getConfig(path);
    const expr = path.node;
    const memo = registerImportMethod(path, config2.memoWrapper);
    let dTest, cond, id;
    if (t__namespace.isConditionalExpression(expr) && (isDynamic(path.get("consequent"), {
        checkTags: true
    }) || isDynamic(path.get("alternate"), {
        checkTags: true
    }))) {
        dTest = isDynamic(path.get("test"), {
            checkMember: true
        });
        if (dTest) {
            cond = expr.test;
            if (!t__namespace.isBinaryExpression(cond)) cond = t__namespace.unaryExpression("!", t__namespace.unaryExpression("!", cond, true), true);
            id = inline ? t__namespace.callExpression(memo, [
                t__namespace.arrowFunctionExpression([], cond),
                t__namespace.booleanLiteral(true)
            ]) : path.scope.generateUidIdentifier("_c$");
            expr.test = t__namespace.callExpression(id, []);
            if (t__namespace.isConditionalExpression(expr.consequent) || t__namespace.isLogicalExpression(expr.consequent)) expr.consequent = transformCondition(path.get("consequent"), inline, true);
            if (t__namespace.isConditionalExpression(expr.alternate) || t__namespace.isLogicalExpression(expr.alternate)) expr.alternate = transformCondition(path.get("alternate"), inline, true);
        }
    } else if (t__namespace.isLogicalExpression(expr)) {
        let nextPath = path;
        // handle top-level or, ie cond && <A/> || <B/>
        while(nextPath.node.operator !== "&&" && t__namespace.isLogicalExpression(nextPath.node.left))nextPath = nextPath.get("left");
        nextPath.node.operator === "&&" && isDynamic(nextPath.get("right"), {
            checkTags: true
        }) && (dTest = isDynamic(nextPath.get("left"), {
            checkMember: true
        }));
        if (dTest) {
            cond = nextPath.node.left;
            if (!t__namespace.isBinaryExpression(cond)) cond = t__namespace.unaryExpression("!", t__namespace.unaryExpression("!", cond, true), true);
            id = inline ? t__namespace.callExpression(memo, [
                t__namespace.arrowFunctionExpression([], cond),
                t__namespace.booleanLiteral(true)
            ]) : path.scope.generateUidIdentifier("_c$");
            nextPath.node.left = t__namespace.callExpression(id, []);
        }
    }
    if (dTest && !inline) {
        const statements = [
            t__namespace.variableDeclaration("const", [
                t__namespace.variableDeclarator(id, config2.memoWrapper ? t__namespace.callExpression(memo, [
                    t__namespace.arrowFunctionExpression([], cond),
                    t__namespace.booleanLiteral(true)
                ]) : t__namespace.arrowFunctionExpression([], cond))
            ]),
            t__namespace.arrowFunctionExpression([], expr)
        ];
        return deep ? t__namespace.callExpression(t__namespace.arrowFunctionExpression([], t__namespace.blockStatement([
            statements[0],
            t__namespace.returnStatement(statements[1])
        ])), []) : statements;
    }
    return deep ? expr : t__namespace.arrowFunctionExpression([], expr);
}
function escapeBackticks(value) {
    return value.replace(/`/g, "\\`");
}
function escapeHTML(s, attr) {
    if (typeof s !== "string") return s;
    const delim = attr ? '"' : "<";
    const escDelim = attr ? "&quot;" : "&lt;";
    let iDelim = s.indexOf(delim);
    let iAmp = s.indexOf("&");
    if (iDelim < 0 && iAmp < 0) return s;
    let left = 0, out = "";
    while(iDelim >= 0 && iAmp >= 0)if (iDelim < iAmp) {
        if (left < iDelim) out += s.substring(left, iDelim);
        out += escDelim;
        left = iDelim + 1;
        iDelim = s.indexOf(delim, left);
    } else {
        if (left < iAmp) out += s.substring(left, iAmp);
        out += "&amp;";
        left = iAmp + 1;
        iAmp = s.indexOf("&", left);
    }
    if (iDelim >= 0) do {
        if (left < iDelim) out += s.substring(left, iDelim);
        out += escDelim;
        left = iDelim + 1;
        iDelim = s.indexOf(delim, left);
    }while (iDelim >= 0)
    else while(iAmp >= 0){
        if (left < iAmp) out += s.substring(left, iAmp);
        out += "&amp;";
        left = iAmp + 1;
        iAmp = s.indexOf("&", left);
    }
    return left < s.length ? out + s.substring(left) : out;
}
function transformElement$2(path, info) {
    let tagName = getTagName(path.node), config3 = getConfig(path), wrapSVG = info.topLevel && tagName != "svg" && SVGElements.has(tagName), voidTag = VoidElements.indexOf(tagName) > -1, results = {
        template: `<${tagName}`,
        decl: [],
        exprs: [],
        dynamics: [],
        postExprs: [],
        isSVG: wrapSVG,
        tagName
    };
    if (tagName === "html" && config3.hydratable) results.skipTemplate = true;
    if (wrapSVG) results.template = "<svg>" + results.template;
    if (!info.skipId) results.id = path.scope.generateUidIdentifier("el$");
    transformAttributes$2(path, results);
    if (config3.contextToCustomElements && (tagName === "slot" || tagName.indexOf("-") > -1)) contextToCustomElement(path, results);
    results.template += ">";
    if (!voidTag) {
        transformChildren$2(path, results, config3);
        results.template += `</${tagName}>`;
    }
    if (info.topLevel && config3.hydratable && results.hasHydratableEvent) results.postExprs.push(t__namespace.expressionStatement(t__namespace.callExpression(registerImportMethod(path, "runHydrationEvents"), [])));
    if (wrapSVG) results.template += "</svg>";
    return results;
}
function setAttr$2(path, elem, name, value, { isSVG , dynamic , prevId , isCE  }) {
    // pull out namespace
    const config4 = getConfig(path);
    let parts, namespace;
    if ((parts = name.split(":")) && parts[1] && reservedNameSpaces.has(parts[0])) {
        name = parts[1];
        namespace = parts[0];
    }
    if (namespace === "style") return t__namespace.callExpression(t__namespace.memberExpression(t__namespace.memberExpression(elem, t__namespace.identifier("style")), t__namespace.identifier("setProperty")), [
        t__namespace.stringLiteral(name),
        value
    ]);
    if (namespace === "class") return t__namespace.callExpression(t__namespace.memberExpression(t__namespace.memberExpression(elem, t__namespace.identifier("classList")), t__namespace.identifier("toggle")), [
        t__namespace.stringLiteral(name),
        value
    ]);
    if (name === "style") return t__namespace.callExpression(registerImportMethod(path, "style"), prevId ? [
        elem,
        value,
        prevId
    ] : [
        elem,
        value
    ]);
    if (!isSVG && name === "class") return t__namespace.assignmentExpression("=", t__namespace.memberExpression(elem, t__namespace.identifier("className")), value);
    if (name === "classList") return t__namespace.callExpression(registerImportMethod(path, "classList"), prevId ? [
        elem,
        value,
        prevId
    ] : [
        elem,
        value
    ]);
    if (config4.hydratable && name === "innerHTML") return t__namespace.callExpression(registerImportMethod(path, "innerHTML"), [
        elem,
        value
    ]);
    if (dynamic && name === "textContent") return t__namespace.assignmentExpression("=", t__namespace.memberExpression(elem, t__namespace.identifier("data")), value);
    const isChildProp = ChildProperties.has(name);
    const isProp = Properties.has(name);
    const alias = PropAliases[name];
    if (namespace !== "attr" && (isChildProp || !isSVG && isProp || isCE || namespace === "prop")) {
        if (isCE && !isChildProp && !isProp && namespace !== "prop") name = toPropertyName(name);
        return t__namespace.assignmentExpression("=", t__namespace.memberExpression(elem, t__namespace.identifier(alias || name)), value);
    }
    let isNameSpaced = name.indexOf(":") > -1;
    name = Aliases[name] || name;
    !isSVG && (name = name.toLowerCase());
    const ns = isNameSpaced && SVGNamespace[name.split(":")[0]];
    if (ns) return t__namespace.callExpression(registerImportMethod(path, "setAttributeNS"), [
        elem,
        t__namespace.stringLiteral(ns),
        t__namespace.stringLiteral(name),
        value
    ]);
    else return t__namespace.callExpression(registerImportMethod(path, "setAttribute"), [
        elem,
        t__namespace.stringLiteral(name),
        value
    ]);
}
function detectResolvableEventHandler(attribute, handler) {
    while(t__namespace.isIdentifier(handler)){
        const lookup = attribute.scope.getBinding(handler.name);
        if (lookup) {
            if (t__namespace.isVariableDeclarator(lookup.path.node)) handler = lookup.path.node.init;
            else if (t__namespace.isFunctionDeclaration(lookup.path.node)) return true;
            else return false;
        } else return false;
    }
    return t__namespace.isFunction(handler);
}
function transformAttributes$2(path, results) {
    let elem = results.id, hasHydratableEvent = false, children, attributes = path.get("openingElement").get("attributes");
    const tagName = getTagName(path.node), isSVG = SVGElements.has(tagName), isCE = tagName.includes("-"), hasChildren = path.node.children.length > 0, config5 = getConfig(path);
    // preprocess styles
    const styleAttribute = attributes.find((a)=>a.node.name && a.node.name.name === "style" && t__namespace.isJSXExpressionContainer(a.node.value) && t__namespace.isObjectExpression(a.node.value.expression) && !a.node.value.expression.properties.some((p)=>t__namespace.isSpreadElement(p)
        )
    );
    if (styleAttribute) {
        let i = 0, leading = styleAttribute.node.value.expression.leadingComments;
        styleAttribute.node.value.expression.properties.slice().forEach((p, index2)=>{
            if (!p.computed) {
                if (leading) p.value.leadingComments = leading;
                path.get("openingElement").node.attributes.splice(styleAttribute.key + ++i, 0, t__namespace.JSXAttribute(t__namespace.JSXNamespacedName(t__namespace.JSXIdentifier("style"), t__namespace.JSXIdentifier(t__namespace.isIdentifier(p.key) ? p.key.name : p.key.value)), t__namespace.JSXExpressionContainer(p.value)));
                styleAttribute.node.value.expression.properties.splice(index2 - i - 1, 1);
            }
        });
        if (!styleAttribute.node.value.expression.properties.length) path.get("openingElement").node.attributes.splice(styleAttribute.key, 1);
    }
    // preprocess classList
    attributes = path.get("openingElement").get("attributes");
    const classListAttribute = attributes.find((a)=>a.node.name && a.node.name.name === "classList" && t__namespace.isJSXExpressionContainer(a.node.value) && t__namespace.isObjectExpression(a.node.value.expression) && !a.node.value.expression.properties.some((p)=>t__namespace.isSpreadElement(p) || p.computed || t__namespace.isStringLiteral(p.key) && (p.key.value.includes(" ") || p.key.value.includes(":"))
        )
    );
    if (classListAttribute) {
        let i = 0, leading = classListAttribute.node.value.expression.leadingComments, classListProperties = classListAttribute.get("value").get("expression").get("properties");
        classListProperties.slice().forEach((propPath, index3)=>{
            const p = propPath.node;
            const { confident , value: computed  } = propPath.get("value").evaluate();
            if (leading) p.value.leadingComments = leading;
            if (!confident) path.get("openingElement").node.attributes.splice(classListAttribute.key + ++i, 0, t__namespace.JSXAttribute(t__namespace.JSXNamespacedName(t__namespace.JSXIdentifier("class"), t__namespace.JSXIdentifier(t__namespace.isIdentifier(p.key) ? p.key.name : p.key.value)), t__namespace.JSXExpressionContainer(p.value)));
            else if (computed) path.get("openingElement").node.attributes.splice(classListAttribute.key + ++i, 0, t__namespace.JSXAttribute(t__namespace.JSXIdentifier("class"), t__namespace.stringLiteral(t__namespace.isIdentifier(p.key) ? p.key.name : p.key.value)));
            classListProperties.splice(index3 - i - 1, 1);
        });
        if (!classListProperties.length) path.get("openingElement").node.attributes.splice(classListAttribute.key, 1);
    }
    // combine class properties
    attributes = path.get("openingElement").get("attributes");
    const classAttributes = attributes.filter((a)=>a.node.name && (a.node.name.name === "class" || a.node.name.name === "className")
    );
    if (classAttributes.length > 1) {
        const first = classAttributes[0].node, values = [], quasis = [
            t__namespace.TemplateElement({
                raw: ""
            })
        ];
        for(let i = 0; i < classAttributes.length; i++){
            const attr = classAttributes[i].node, isLast = i === classAttributes.length - 1;
            if (!t__namespace.isJSXExpressionContainer(attr.value)) {
                const prev = quasis.pop();
                quasis.push(t__namespace.TemplateElement({
                    raw: (prev ? prev.value.raw : "") + `${attr.value.value}` + (isLast ? "" : " ")
                }));
            } else {
                values.push(t__namespace.logicalExpression("||", attr.value.expression, t__namespace.stringLiteral("")));
                quasis.push(t__namespace.TemplateElement({
                    raw: isLast ? "" : " "
                }));
            }
            i && attributes.splice(attributes.indexOf(classAttributes[i]), 1);
        }
        if (values.length) first.value = t__namespace.JSXExpressionContainer(t__namespace.TemplateLiteral(quasis, values));
        else first.value = t__namespace.stringLiteral(quasis[0].value.raw);
    }
    path.get("openingElement").set("attributes", attributes.map((a)=>a.node
    ));
    path.get("openingElement").get("attributes").forEach((attribute)=>{
        const node = attribute.node;
        if (t__namespace.isJSXSpreadAttribute(node)) {
            results.exprs.push(t__namespace.expressionStatement(t__namespace.callExpression(registerImportMethod(attribute, "spread"), [
                elem,
                isDynamic(attribute.get("argument"), {
                    checkMember: true
                }) ? t__namespace.isCallExpression(node.argument) && !node.argument.arguments.length ? node.argument.callee : t__namespace.arrowFunctionExpression([], node.argument) : node.argument,
                t__namespace.booleanLiteral(isSVG),
                t__namespace.booleanLiteral(hasChildren)
            ])));
            //NOTE: can't be checked at compile time so add to compiled output
            hasHydratableEvent = true;
            return;
        }
        let value = node.value, key = t__namespace.isJSXNamespacedName(node.name) ? `${node.name.namespace.name}:${node.name.name.name}` : node.name.name, reservedNameSpace = t__namespace.isJSXNamespacedName(node.name) && reservedNameSpaces.has(node.name.namespace.name);
        if (t__namespace.isJSXExpressionContainer(value) && !key.startsWith("use:")) {
            const evaluated = attribute.get("value").get("expression").evaluate().value;
            let type;
            if (evaluated !== undefined && ((type = typeof evaluated) === "string" || type === "number")) value = t__namespace.stringLiteral(String(evaluated));
        }
        if (t__namespace.isJSXNamespacedName(node.name) && reservedNameSpace && !t__namespace.isJSXExpressionContainer(value)) node.value = value = t__namespace.JSXExpressionContainer(value || t__namespace.JSXEmptyExpression());
        if (t__namespace.isJSXExpressionContainer(value) && (reservedNameSpace || !(t__namespace.isStringLiteral(value.expression) || t__namespace.isNumericLiteral(value.expression)))) {
            if (key === "ref") {
                // Normalize expressions for non-null and type-as
                while(t__namespace.isTSNonNullExpression(value.expression) || t__namespace.isTSAsExpression(value.expression))value.expression = value.expression.expression;
                let binding, isFunction = t__namespace.isIdentifier(value.expression) && (binding = path.scope.getBinding(value.expression.name)) && binding.kind === "const";
                if (!isFunction && t__namespace.isLVal(value.expression)) {
                    const refIdentifier = path.scope.generateUidIdentifier("_ref$");
                    results.exprs.unshift(t__namespace.variableDeclaration("const", [
                        t__namespace.variableDeclarator(refIdentifier, value.expression)
                    ]), t__namespace.expressionStatement(t__namespace.conditionalExpression(t__namespace.binaryExpression("===", t__namespace.unaryExpression("typeof", refIdentifier), t__namespace.stringLiteral("function")), t__namespace.callExpression(refIdentifier, [
                        elem
                    ]), t__namespace.assignmentExpression("=", value.expression, elem))));
                } else if (isFunction || t__namespace.isFunction(value.expression)) results.exprs.unshift(t__namespace.expressionStatement(t__namespace.callExpression(value.expression, [
                    elem
                ])));
                else if (t__namespace.isCallExpression(value.expression)) {
                    const refIdentifier = path.scope.generateUidIdentifier("_ref$");
                    results.exprs.unshift(t__namespace.variableDeclaration("const", [
                        t__namespace.variableDeclarator(refIdentifier, value.expression)
                    ]), t__namespace.expressionStatement(t__namespace.logicalExpression("&&", t__namespace.binaryExpression("===", t__namespace.unaryExpression("typeof", refIdentifier), t__namespace.stringLiteral("function")), t__namespace.callExpression(refIdentifier, [
                        elem
                    ]))));
                }
            } else if (key.startsWith("use:")) {
                // Some trick to treat JSXIdentifier as Identifier
                node.name.name.type = 'Identifier';
                results.exprs.unshift(t__namespace.expressionStatement(t__namespace.callExpression(node.name.name, [
                    elem,
                    t__namespace.arrowFunctionExpression([], t__namespace.isJSXEmptyExpression(value.expression) ? t__namespace.booleanLiteral(true) : value.expression)
                ])));
            } else if (key === "children") children = value;
            else if (key.startsWith("on")) {
                const ev = toEventName(key);
                if (key.startsWith("on:") || key.startsWith("oncapture:")) {
                    const listenerOptions = [
                        t__namespace.stringLiteral(key.split(":")[1]),
                        value.expression
                    ];
                    results.exprs.push(t__namespace.expressionStatement(t__namespace.callExpression(t__namespace.memberExpression(elem, t__namespace.identifier("addEventListener")), key.startsWith("oncapture:") ? listenerOptions.concat(t__namespace.booleanLiteral(true)) : listenerOptions)));
                } else if (config5.delegateEvents && (DelegatedEvents.has(ev) || config5.delegatedEvents.indexOf(ev) !== -1)) {
                    // can only hydrate delegated events
                    hasHydratableEvent = true;
                    const events = attribute.scope.getProgramParent().data.events || (attribute.scope.getProgramParent().data.events = new Set());
                    events.add(ev);
                    let handler = value.expression;
                    const resolveable = detectResolvableEventHandler(attribute, handler);
                    if (t__namespace.isArrayExpression(handler)) {
                        if (handler.elements.length > 1) results.exprs.unshift(t__namespace.expressionStatement(t__namespace.assignmentExpression("=", t__namespace.memberExpression(elem, t__namespace.identifier(`$$${ev}Data`)), handler.elements[1])));
                        handler = handler.elements[0];
                        results.exprs.unshift(t__namespace.expressionStatement(t__namespace.assignmentExpression("=", t__namespace.memberExpression(elem, t__namespace.identifier(`$$${ev}`)), handler)));
                    } else if (t__namespace.isFunction(handler) || resolveable) results.exprs.unshift(t__namespace.expressionStatement(t__namespace.assignmentExpression("=", t__namespace.memberExpression(elem, t__namespace.identifier(`$$${ev}`)), handler)));
                    else results.exprs.unshift(t__namespace.expressionStatement(t__namespace.callExpression(registerImportMethod(path, "addEventListener"), [
                        elem,
                        t__namespace.stringLiteral(ev),
                        handler,
                        t__namespace.booleanLiteral(true)
                    ])));
                } else {
                    let handler = value.expression;
                    const resolveable = detectResolvableEventHandler(attribute, handler);
                    if (t__namespace.isArrayExpression(handler)) {
                        if (handler.elements.length > 1) handler = t__namespace.arrowFunctionExpression([
                            t__namespace.identifier("e")
                        ], t__namespace.callExpression(handler.elements[0], [
                            handler.elements[1],
                            t__namespace.identifier("e")
                        ]));
                        else handler = handler.elements[0];
                        results.exprs.unshift(t__namespace.expressionStatement(t__namespace.callExpression(t__namespace.memberExpression(elem, t__namespace.identifier("addEventListener")), [
                            t__namespace.stringLiteral(ev),
                            handler
                        ])));
                    } else if (t__namespace.isFunction(handler) || resolveable) results.exprs.unshift(t__namespace.expressionStatement(t__namespace.callExpression(t__namespace.memberExpression(elem, t__namespace.identifier("addEventListener")), [
                        t__namespace.stringLiteral(ev),
                        handler
                    ])));
                    else results.exprs.unshift(t__namespace.expressionStatement(t__namespace.callExpression(registerImportMethod(path, "addEventListener"), [
                        elem,
                        t__namespace.stringLiteral(ev),
                        handler
                    ])));
                }
            } else if (config5.effectWrapper && isDynamic(attribute.get("value").get("expression"), {
                checkMember: true
            })) {
                let nextElem = elem;
                if (key === "textContent") {
                    nextElem = attribute.scope.generateUidIdentifier("el$");
                    children = t__namespace.JSXText(" ");
                    children.extra = {
                        raw: " ",
                        rawValue: " "
                    };
                    results.decl.push(t__namespace.variableDeclarator(nextElem, t__namespace.memberExpression(elem, t__namespace.identifier("firstChild"))));
                }
                results.dynamics.push({
                    elem: nextElem,
                    key,
                    value: value.expression,
                    isSVG,
                    isCE
                });
            } else results.exprs.push(t__namespace.expressionStatement(setAttr$2(attribute, elem, key, value.expression, {
                isSVG,
                isCE
            })));
        } else {
            if (config5.hydratable && key === "$ServerOnly") {
                results.skipTemplate = true;
                return;
            }
            if (t__namespace.isJSXExpressionContainer(value)) value = value.expression;
            key = Aliases[key] || key;
            if (value && ChildProperties.has(key)) results.exprs.push(t__namespace.expressionStatement(setAttr$2(attribute, elem, key, value, {
                isSVG,
                isCE
            })));
            else {
                !isSVG && (key = key.toLowerCase());
                results.template += ` ${key}`;
                results.template += value ? `="${escapeBackticks(value.value)}"` : "";
            }
        }
    });
    if (!hasChildren && children) path.node.children.push(children);
    results.hasHydratableEvent = results.hasHydratableEvent || hasHydratableEvent;
}
function transformChildren$2(path, results, config6) {
    let tempPath = results.id && results.id.name, tagName = getTagName(path.node), nextPlaceholder, i1 = 0;
    const filteredChildren = filterChildren(path.get("children")), childNodes = filteredChildren.map((child, index4)=>transformNode(child, {
            skipId: !results.id || !detectExpressions(filteredChildren, index4, config6)
        })
    ).reduce((memo, child)=>{
        if (!child) return memo;
        const i = memo.length;
        if (child.text && i && memo[i - 1].text) memo[i - 1].template += child.template;
        else memo.push(child);
        return memo;
    }, []);
    childNodes.forEach((child, index5)=>{
        if (!child) return;
        results.template += child.template;
        if (child.id) {
            if (child.tagName === "head") return;
            if (config6.hydratable && tagName === "html") registerImportMethod(path, "getNextMatch");
            const walk = t__namespace.memberExpression(t__namespace.identifier(tempPath), t__namespace.identifier(i1 === 0 ? "firstChild" : "nextSibling"));
            results.decl.push(t__namespace.variableDeclarator(child.id, config6.hydratable && tagName === "html" ? t__namespace.callExpression(registerImportMethod(path, "getNextMatch"), [
                walk,
                t__namespace.stringLiteral(child.tagName)
            ]) : walk));
            results.decl.push(...child.decl);
            results.exprs.push(...child.exprs);
            results.dynamics.push(...child.dynamics);
            results.hasHydratableEvent = results.hasHydratableEvent || child.hasHydratableEvent;
            tempPath = child.id.name;
            nextPlaceholder = null;
            i1++;
        } else if (child.exprs.length) {
            const insert = registerImportMethod(path, "insert");
            const multi = checkLength(filteredChildren), markers = config6.hydratable && multi;
            // boxed by textNodes
            if (markers || wrappedByText(childNodes, index5)) {
                let exprId, contentId;
                if (markers) tempPath = createPlaceholder(path, results, tempPath, i1++, "#")[0].name;
                if (nextPlaceholder) exprId = nextPlaceholder;
                else [exprId, contentId] = createPlaceholder(path, results, tempPath, i1++, markers ? "/" : "");
                if (!markers) nextPlaceholder = exprId;
                results.exprs.push(t__namespace.expressionStatement(t__namespace.callExpression(insert, contentId ? [
                    results.id,
                    child.exprs[0],
                    exprId,
                    contentId
                ] : [
                    results.id,
                    child.exprs[0],
                    exprId
                ])));
                tempPath = exprId.name;
            } else if (multi) results.exprs.push(t__namespace.expressionStatement(t__namespace.callExpression(insert, [
                results.id,
                child.exprs[0],
                nextChild$1(childNodes, index5) || t__namespace.nullLiteral()
            ])));
            else results.exprs.push(t__namespace.expressionStatement(t__namespace.callExpression(insert, [
                results.id,
                child.exprs[0]
            ])));
        } else nextPlaceholder = null;
    });
}
function createPlaceholder(path, results, tempPath, i, char) {
    const exprId = path.scope.generateUidIdentifier("el$"), config7 = getConfig(path);
    let contentId;
    results.template += `<!${char}>`;
    if (config7.hydratable && char === "/") {
        contentId = path.scope.generateUidIdentifier("co$");
        results.decl.push(t__namespace.variableDeclarator(t__namespace.arrayPattern([
            exprId,
            contentId
        ]), t__namespace.callExpression(registerImportMethod(path, "getNextMarker"), [
            t__namespace.memberExpression(t__namespace.identifier(tempPath), t__namespace.identifier("nextSibling"))
        ])));
    } else results.decl.push(t__namespace.variableDeclarator(exprId, t__namespace.memberExpression(t__namespace.identifier(tempPath), t__namespace.identifier(i === 0 ? "firstChild" : "nextSibling"))));
    return [
        exprId,
        contentId
    ];
}
function nextChild$1(children, index6) {
    return children[index6 + 1] && (children[index6 + 1].id || nextChild$1(children, index6 + 1));
}
// reduce unnecessary refs
function detectExpressions(children, index7, config8) {
    if (children[index7 - 1]) {
        const node = children[index7 - 1].node;
        if (t__namespace.isJSXExpressionContainer(node) && !t__namespace.isJSXEmptyExpression(node.expression) && !getStaticExpression(children[index7 - 1])) return true;
        let tagName;
        if (t__namespace.isJSXElement(node) && (tagName = getTagName(node)) && isComponent(tagName)) return true;
    }
    for(let i = index7; i < children.length; i++){
        const child = children[i].node;
        if (t__namespace.isJSXExpressionContainer(child)) {
            if (!t__namespace.isJSXEmptyExpression(child.expression) && !getStaticExpression(children[i])) return true;
        } else if (t__namespace.isJSXElement(child)) {
            const tagName = getTagName(child);
            if (isComponent(tagName)) return true;
            if (config8.contextToCustomElements && (tagName === "slot" || tagName.indexOf("-") > -1)) return true;
            if (child.openingElement.attributes.some((attr)=>t__namespace.isJSXSpreadAttribute(attr) || [
                    "textContent",
                    "innerHTML",
                    "innerText"
                ].includes(attr.name.name) || attr.name.namespace && attr.name.namespace.name === "use" || t__namespace.isJSXExpressionContainer(attr.value) && !(t__namespace.isStringLiteral(attr.value.expression) || t__namespace.isNumericLiteral(attr.value.expression))
            )) return true;
            const nextChildren = filterChildren(children[i].get("children"));
            if (nextChildren.length) {
                if (detectExpressions(nextChildren, 0, config8)) return true;
            }
        }
    }
}
function contextToCustomElement(path, results) {
    results.exprs.push(t__namespace.expressionStatement(t__namespace.assignmentExpression("=", t__namespace.memberExpression(results.id, t__namespace.identifier("_$owner")), t__namespace.callExpression(registerImportMethod(path, "getOwner"), []))));
}
function createTemplate$2(path, result, wrap) {
    const config9 = getConfig(path);
    if (result.id) {
        registerTemplate(path, result);
        if (!(result.exprs.length || result.dynamics.length || result.postExprs.length) && result.decl.declarations.length === 1) return result.decl.declarations[0].init;
        else return t__namespace.callExpression(t__namespace.arrowFunctionExpression([], t__namespace.blockStatement([
            result.decl,
            ...result.exprs.concat(wrapDynamics$1(path, result.dynamics) || [], result.postExprs || []),
            t__namespace.returnStatement(result.id)
        ])), []);
    }
    if (wrap && result.dynamic && config9.memoWrapper) return t__namespace.callExpression(registerImportMethod(path, config9.memoWrapper), [
        result.exprs[0]
    ]);
    return result.exprs[0];
}
function appendTemplates$1(path, templates) {
    const declarators = templates.map((template)=>{
        const tmpl = {
            cooked: template.template,
            raw: template.template
        };
        return t__namespace.variableDeclarator(template.id, t__namespace.addComment(t__namespace.callExpression(registerImportMethod(path, "template"), [
            t__namespace.templateLiteral([
                t__namespace.templateElement(tmpl, true)
            ], []),
            t__namespace.numericLiteral(template.elementCount)
        ].concat(template.isSVG ? t__namespace.booleanLiteral(template.isSVG) : [])), 'leading', '#__PURE__'));
    });
    path.node.body.unshift(t__namespace.variableDeclaration("const", declarators));
}
function registerTemplate(path, results) {
    const { hydratable  } = getConfig(path);
    let decl;
    if (results.template.length) {
        let templateDef, templateId;
        if (!results.skipTemplate) {
            const templates = path.scope.getProgramParent().data.templates || (path.scope.getProgramParent().data.templates = []);
            if (templateDef = templates.find((t2)=>t2.template === results.template
            )) templateId = templateDef.id;
            else {
                templateId = path.scope.generateUidIdentifier("tmpl$");
                templates.push({
                    id: templateId,
                    template: results.template,
                    elementCount: results.template.split("<").length - 1,
                    isSVG: results.isSVG
                });
            }
        }
        decl = t__namespace.variableDeclarator(results.id, hydratable ? t__namespace.callExpression(registerImportMethod(path, "getNextElement"), templateId ? [
            templateId
        ] : []) : t__namespace.callExpression(t__namespace.memberExpression(templateId, t__namespace.identifier("cloneNode")), [
            t__namespace.booleanLiteral(true)
        ]));
    }
    results.decl.unshift(decl);
    results.decl = t__namespace.variableDeclaration("const", results.decl);
}
function wrapDynamics$1(path, dynamics) {
    if (!dynamics.length) return;
    const config10 = getConfig(path);
    const effectWrapperId = registerImportMethod(path, config10.effectWrapper);
    if (dynamics.length === 1) {
        const prevValue = dynamics[0].key === "classList" || dynamics[0].key === "style" ? t__namespace.identifier("_$p") : undefined;
        return t__namespace.expressionStatement(t__namespace.callExpression(effectWrapperId, [
            t__namespace.arrowFunctionExpression(prevValue ? [
                prevValue
            ] : [], setAttr$2(path, dynamics[0].elem, dynamics[0].key, dynamics[0].value, {
                isSVG: dynamics[0].isSVG,
                isCE: dynamics[0].isCE,
                dynamic: true,
                prevId: prevValue
            }))
        ]));
    }
    const decls = [], statements = [], identifiers = [], prevId = t__namespace.identifier("_p$");
    dynamics.forEach(({ elem , key , value , isSVG , isCE  })=>{
        const identifier = path.scope.generateUidIdentifier("v$");
        identifiers.push(identifier);
        decls.push(t__namespace.variableDeclarator(identifier, value));
        if (key === "classList" || key === "style") {
            const prev = t__namespace.memberExpression(prevId, identifier);
            statements.push(t__namespace.expressionStatement(t__namespace.assignmentExpression("=", prev, setAttr$2(path, elem, key, identifier, {
                isSVG,
                isCE,
                dynamic: true,
                prevId: prev
            }))));
        } else statements.push(t__namespace.expressionStatement(t__namespace.logicalExpression("&&", t__namespace.binaryExpression("!==", identifier, t__namespace.memberExpression(prevId, identifier)), setAttr$2(path, elem, key, t__namespace.assignmentExpression("=", t__namespace.memberExpression(prevId, identifier), identifier), {
            isSVG,
            isCE,
            dynamic: true
        }))));
    });
    return t__namespace.expressionStatement(t__namespace.callExpression(effectWrapperId, [
        t__namespace.arrowFunctionExpression([
            prevId
        ], t__namespace.blockStatement([
            t__namespace.variableDeclaration("const", decls),
            ...statements,
            t__namespace.returnStatement(prevId)
        ])),
        t__namespace.objectExpression(identifiers.map((id)=>t__namespace.objectProperty(id, t__namespace.identifier("undefined"))
        ))
    ]));
}
function createTemplate$1(path, result) {
    if (!result.template) return result.exprs[0];
    let template, id;
    if (!Array.isArray(result.template)) template = t__namespace.stringLiteral(result.template);
    else if (result.template.length === 1) template = t__namespace.stringLiteral(result.template[0]);
    else {
        const strings = result.template.map((tmpl)=>t__namespace.stringLiteral(tmpl)
        );
        template = t__namespace.arrayExpression(strings);
    }
    const templates = path.scope.getProgramParent().data.templates || (path.scope.getProgramParent().data.templates = []);
    const found = templates.find((tmp)=>{
        if (t__namespace.isArrayExpression(tmp[1]) && t__namespace.isArrayExpression(template)) return tmp[1].elements.every((el, i)=>template.elements[i] && el.value === template.elements[i].value
        );
        return tmp[1].value === template.value;
    });
    if (!found) {
        id = path.scope.generateUidIdentifier("tmpl$");
        templates.push([
            id,
            template
        ]);
    } else id = found[0];
    return t__namespace.callExpression(registerImportMethod(path, "ssr"), result.template.length > 1 ? [
        id,
        ...result.templateValues
    ] : [
        id
    ]);
}
function appendTemplates(path, templates) {
    const declarators = templates.map((template)=>{
        return t__namespace.variableDeclarator(template[0], template[1]);
    });
    path.node.body.unshift(t__namespace.variableDeclaration("const", declarators));
}
function appendToTemplate(template, value) {
    let array;
    if (Array.isArray(value)) [value, ...array] = value;
    template[template.length - 1] += value;
    if (array && array.length) template.push.apply(template, array);
}
function transformElement$1(path, info) {
    let tagName = getTagName(path.node), config11 = getConfig(path), voidTag = VoidElements.indexOf(tagName) > -1, results = {
        template: [
            `<${tagName}`
        ],
        templateValues: [],
        decl: [],
        exprs: [],
        dynamics: [],
        tagName
    };
    if (info.topLevel && config11.hydratable) {
        results.template.push("");
        results.templateValues.push(t__namespace.callExpression(registerImportMethod(path, "ssrHydrationKey"), []));
    }
    transformAttributes$1(path, results);
    appendToTemplate(results.template, ">");
    if (!voidTag) {
        transformChildren$1(path, results, {
            ...config11,
            ...info
        });
        appendToTemplate(results.template, `</${tagName}>`);
    }
    return results;
}
function toAttribute(key, isSVG) {
    key = Aliases[key] || key;
    !isSVG && (key = key.toLowerCase());
    return key;
}
function setAttr$1(results, name, value, isSVG) {
    // strip out namespaces for now, everything at this point is an attribute
    let parts;
    if ((parts = name.split(":")) && parts[1] && reservedNameSpaces.has(parts[0])) name = parts[1];
    name = toAttribute(name, isSVG);
    appendToTemplate(results.template, ` ${name}="`);
    results.template.push(`"`);
    results.templateValues.push(value);
}
function escapeExpression(path, expression, attr) {
    if (t__namespace.isStringLiteral(expression) || t__namespace.isNumericLiteral(expression)) return expression;
    else if (t__namespace.isFunction(expression)) {
        expression.body = escapeExpression(path, expression.body, attr);
        return expression;
    } else if (t__namespace.isTemplateLiteral(expression)) {
        expression.expressions = expression.expressions.map((e)=>escapeExpression(path, e, attr)
        );
        return expression;
    } else if (t__namespace.isUnaryExpression(expression)) {
        expression.argument = escapeExpression(path, expression.argument, attr);
        return expression;
    } else if (t__namespace.isBinaryExpression(expression)) {
        expression.left = escapeExpression(path, expression.left, attr);
        expression.right = escapeExpression(path, expression.right, attr);
        return expression;
    } else if (t__namespace.isConditionalExpression(expression)) {
        expression.consequent = escapeExpression(path, expression.consequent, attr);
        expression.alternate = escapeExpression(path, expression.alternate, attr);
        return expression;
    } else if (t__namespace.isLogicalExpression(expression)) {
        expression.right = escapeExpression(path, expression.right, attr);
        if (expression.operator !== "&&") expression.left = escapeExpression(path, expression.left, attr);
        return expression;
    } else if (t__namespace.isCallExpression(expression) && t__namespace.isFunction(expression.callee)) {
        if (t__namespace.isBlockStatement(expression.callee.body)) expression.callee.body.body = expression.callee.body.body.map((e)=>{
            if (t__namespace.isReturnStatement(e)) e.argument = escapeExpression(path, e.argument, attr);
            return e;
        });
        else expression.callee.body = escapeExpression(path, expression.callee.body, attr);
        return expression;
    }
    return t__namespace.callExpression(registerImportMethod(path, "escape"), [
        expression
    ].concat(attr ? [
        t__namespace.booleanLiteral(true)
    ] : []));
}
function transformToObject(attrName, attributes, selectedAttributes) {
    const properties = [];
    const existingAttribute = attributes.find((a)=>a.node.name.name === attrName
    );
    for(let i = 0; i < selectedAttributes.length; i++){
        const attr = selectedAttributes[i].node;
        const computed = !t__namespace.isValidIdentifier(attr.name.name.name);
        if (!computed) attr.name.name.type = "Identifier";
        properties.push(t__namespace.objectProperty(computed ? t__namespace.stringLiteral(attr.name.name.name) : attr.name.name, t__namespace.isJSXExpressionContainer(attr.value) ? attr.value.expression : attr.value));
        (existingAttribute || i) && attributes.splice(selectedAttributes[i].key, 1);
    }
    if (existingAttribute && t__namespace.isJSXExpressionContainer(existingAttribute.node.value) && t__namespace.isObjectExpression(existingAttribute.node.value.expression)) existingAttribute.node.value.expression.properties.push(...properties);
    else selectedAttributes[0].node = t__namespace.jsxAttribute(t__namespace.jsxIdentifier(attrName), t__namespace.jsxExpressionContainer(t__namespace.objectExpression(properties)));
}
function transformAttributes$1(path, results) {
    let children;
    const tagName = getTagName(path.node), isSVG = SVGElements.has(tagName), hasChildren = path.node.children.length > 0, attributes = path.get("openingElement").get("attributes"), styleAttributes = attributes.filter((a)=>t__namespace.isJSXNamespacedName(a.node.name) && a.node.name.namespace.name === "style"
    ), classNamespaceAttributes = attributes.filter((a)=>t__namespace.isJSXNamespacedName(a.node.name) && a.node.name.namespace.name === "class"
    );
    if (classNamespaceAttributes.length) transformToObject("classList", attributes, classNamespaceAttributes);
    const classAttributes = attributes.filter((a)=>a.node.name && (a.node.name.name === "class" || a.node.name.name === "className" || a.node.name.name === "classList")
    );
    // combine class propertoes
    if (classAttributes.length > 1) {
        const first = classAttributes[0].node, values = [], quasis = [
            t__namespace.TemplateElement({
                raw: ""
            })
        ];
        for(let i = 0; i < classAttributes.length; i++){
            const attr = classAttributes[i].node, isLast = i === classAttributes.length - 1;
            if (!t__namespace.isJSXExpressionContainer(attr.value)) {
                const prev = quasis.pop();
                quasis.push(t__namespace.TemplateElement({
                    raw: (prev ? prev.value.raw : "") + (i ? " " : "") + `${attr.value.value}` + (isLast ? "" : " ")
                }));
            } else {
                let expr = attr.value.expression;
                if (attr.name.name === "classList") {
                    if (t__namespace.isObjectExpression(expr) && !expr.properties.some((p)=>t__namespace.isSpreadElement(p)
                    )) {
                        transformClasslistObject(path, expr, values, quasis);
                        i && attributes.splice(attributes.indexOf(classAttributes[i]), 1);
                        continue;
                    }
                    expr = t__namespace.callExpression(registerImportMethod(path, "ssrClassList"), [
                        expr
                    ]);
                }
                values.push(t__namespace.logicalExpression("||", expr, t__namespace.stringLiteral("")));
                quasis.push(t__namespace.TemplateElement({
                    raw: isLast ? "" : " "
                }));
            }
            i && attributes.splice(attributes.indexOf(classAttributes[i]), 1);
        }
        first.value = t__namespace.JSXExpressionContainer(t__namespace.TemplateLiteral(quasis, values));
    }
    if (styleAttributes.length) transformToObject("style", attributes, styleAttributes);
    attributes.forEach((attribute)=>{
        const node = attribute.node;
        if (t__namespace.isJSXSpreadAttribute(node)) {
            appendToTemplate(results.template, " ");
            results.template.push("");
            results.templateValues.push(t__namespace.callExpression(registerImportMethod(attribute, "ssrSpread"), [
                isDynamic(attribute.get("argument"), {
                    checkMember: true,
                    native: true
                }) ? t__namespace.isCallExpression(node.argument) && !node.argument.arguments.length ? node.argument.callee : t__namespace.arrowFunctionExpression([], node.argument) : node.argument,
                t__namespace.booleanLiteral(isSVG),
                t__namespace.booleanLiteral(hasChildren)
            ]));
            return;
        }
        let value = node.value, key = t__namespace.isJSXNamespacedName(node.name) ? `${node.name.namespace.name}:${node.name.name.name}` : node.name.name, reservedNameSpace = t__namespace.isJSXNamespacedName(node.name) && reservedNameSpaces.has(node.name.namespace.name);
        if ((t__namespace.isJSXNamespacedName(node.name) && reservedNameSpace || ChildProperties.has(key)) && !t__namespace.isJSXExpressionContainer(value)) node.value = value = t__namespace.JSXExpressionContainer(value || t__namespace.JSXEmptyExpression());
        if (t__namespace.isJSXExpressionContainer(value) && (reservedNameSpace || ChildProperties.has(key) || !(t__namespace.isStringLiteral(value.expression) || t__namespace.isNumericLiteral(value.expression)))) {
            if (key === "ref" || key.startsWith("use:") || key.startsWith("prop:") || key.startsWith("on")) return;
            else if (ChildProperties.has(key)) {
                children = value;
                if (key === "innerHTML") path.doNotEscape = true;
            } else {
                let dynamic = false, doEscape = true;
                if (isDynamic(attribute.get("value").get("expression"), {
                    checkMember: true,
                    native: true
                })) dynamic = true;
                if (BooleanAttributes.has(key)) {
                    results.template.push("");
                    const fn = t__namespace.callExpression(registerImportMethod(attribute, "ssrBoolean"), [
                        t__namespace.stringLiteral(key),
                        value.expression
                    ]);
                    results.templateValues.push(dynamic ? t__namespace.arrowFunctionExpression([], fn) : fn);
                    return;
                }
                if (key === "style") {
                    if (t__namespace.isJSXExpressionContainer(value) && t__namespace.isObjectExpression(value.expression) && !value.expression.properties.some((p)=>t__namespace.isSpreadElement(p)
                    )) {
                        const props = value.expression.properties.map((p, i)=>t__namespace.binaryExpression("+", t__namespace.stringLiteral((i ? ";" : "") + (t__namespace.isIdentifier(p.key) ? p.key.name : p.key.value) + ":"), t__namespace.isStringLiteral(p.value) ? t__namespace.stringLiteral(escapeHTML(p.value.value)) : t__namespace.isNumericLiteral(p.value) ? p.value : t__namespace.isTemplateLiteral(p.value) && p.value.expressions.length === 0 ? t__namespace.stringLiteral(escapeHTML(p.value.quasis[0].value.raw)) : t__namespace.callExpression(registerImportMethod(path, "escape"), [
                                p.value,
                                t__namespace.booleanLiteral(true)
                            ]))
                        );
                        let res = props[0];
                        for(let i2 = 1; i2 < props.length; i2++)res = t__namespace.binaryExpression("+", res, props[i2]);
                        value.expression = res;
                    } else value.expression = t__namespace.callExpression(registerImportMethod(path, "ssrStyle"), [
                        value.expression
                    ]);
                    doEscape = false;
                }
                if (key === "classList") {
                    if (t__namespace.isObjectExpression(value.expression) && !value.expression.properties.some((p)=>t__namespace.isSpreadElement(p)
                    )) {
                        const values = [], quasis = [
                            t__namespace.TemplateElement({
                                raw: ""
                            })
                        ];
                        transformClasslistObject(path, value.expression, values, quasis);
                        if (!values.length) value.expression = t__namespace.stringLiteral(quasis[0].value.raw);
                        else if (values.length === 1 && !quasis[0].value.raw && !quasis[1].value.raw) value.expression = values[0];
                        else value.expression = t__namespace.templateLiteral(quasis, values);
                    } else value.expression = t__namespace.callExpression(registerImportMethod(path, "ssrClassList"), [
                        value.expression
                    ]);
                    key = "class";
                    doEscape = false;
                }
                if (dynamic) value.expression = t__namespace.arrowFunctionExpression([], doEscape ? escapeExpression(path, value.expression, true) : value.expression);
                else if (doEscape) value.expression = escapeExpression(path, value.expression, true);
                setAttr$1(results, key, value.expression, isSVG);
            }
        } else {
            if (key === "$ServerOnly") return;
            if (t__namespace.isJSXExpressionContainer(value)) value = value.expression;
            key = toAttribute(key, isSVG);
            appendToTemplate(results.template, ` ${key}`);
            appendToTemplate(results.template, value ? `="${escapeHTML(value.value, true)}"` : "");
        }
    });
    if (!hasChildren && children) path.node.children.push(children);
}
function transformClasslistObject(path, expr, values, quasis) {
    expr.properties.forEach((prop, i)=>{
        const isLast = expr.properties.length - 1 === i;
        let key = prop.key;
        if (t__namespace.isIdentifier(prop.key) && !prop.computed) key = t__namespace.stringLiteral(key.name);
        else if (prop.computed) key = t__namespace.callExpression(registerImportMethod(path, "escape"), [
            prop.key,
            t__namespace.booleanLiteral(true)
        ]);
        else key = t__namespace.stringLiteral(escapeHTML(prop.key.value));
        if (t__namespace.isBooleanLiteral(prop.value)) {
            if (prop.value.value === true) {
                if (!prop.computed) {
                    const prev = quasis.pop();
                    quasis.push(t__namespace.TemplateElement({
                        raw: (prev ? prev.value.raw : "") + (i ? " " : "") + `${key.value}` + (isLast ? "" : " ")
                    }));
                } else {
                    values.push(key);
                    quasis.push(t__namespace.TemplateElement({
                        raw: isLast ? "" : " "
                    }));
                }
            }
        } else {
            values.push(t__namespace.conditionalExpression(prop.value, key, t__namespace.stringLiteral("")));
            quasis.push(t__namespace.TemplateElement({
                raw: isLast ? "" : " "
            }));
        }
    });
}
function transformChildren$1(path, results, { hydratable  }) {
    const doNotEscape = path.doNotEscape;
    const filteredChildren = filterChildren(path.get("children"));
    filteredChildren.forEach((node)=>{
        if (t__namespace.isJSXElement(node.node) && getTagName(node.node) === "head") {
            const child = transformNode(node, {
                doNotEscape,
                hydratable: false
            });
            registerImportMethod(path, "NoHydration");
            results.template.push("");
            results.templateValues.push(t__namespace.callExpression(t__namespace.identifier("_$NoHydration"), [
                t__namespace.objectExpression([
                    t__namespace.objectMethod("get", t__namespace.identifier("children"), [], t__namespace.blockStatement([
                        t__namespace.returnStatement(createTemplate$1(path, child))
                    ]))
                ])
            ]));
            return;
        }
        const child = transformNode(node, {
            doNotEscape
        });
        if (!child) return;
        appendToTemplate(results.template, child.template);
        results.templateValues.push.apply(results.templateValues, child.templateValues || []);
        if (child.exprs.length) {
            const multi = checkLength(filteredChildren), markers = hydratable && multi;
            if (!doNotEscape) child.exprs[0] = escapeExpression(path, child.exprs[0]);
            // boxed by textNodes
            if (markers) {
                appendToTemplate(results.template, `<!--#-->`);
                results.template.push("");
                results.templateValues.push(child.exprs[0]);
                appendToTemplate(results.template, `<!--/-->`);
            } else {
                results.template.push("");
                results.templateValues.push(child.exprs[0]);
            }
        }
    });
}
function transformElement(path, info) {
    let tagName = getTagName(path.node), results = {
        id: path.scope.generateUidIdentifier("el$"),
        decl: [],
        exprs: [],
        dynamics: [],
        postExprs: [],
        tagName
    };
    results.decl.push(t__namespace.variableDeclarator(results.id, t__namespace.callExpression(registerImportMethod(path, "createElement"), [
        t__namespace.stringLiteral(tagName)
    ])));
    transformAttributes(path, results);
    transformChildren(path, results);
    return results;
}
function transformAttributes(path, results) {
    let children;
    const elem = results.id, hasChildren = path.node.children.length > 0, config12 = getConfig(path);
    path.get("openingElement").get("attributes").forEach((attribute)=>{
        const node = attribute.node;
        if (t__namespace.isJSXSpreadAttribute(node)) {
            results.exprs.push(t__namespace.expressionStatement(t__namespace.callExpression(registerImportMethod(attribute, "spread"), [
                elem,
                isDynamic(attribute.get("argument"), {
                    checkMember: true
                }) ? t__namespace.isCallExpression(node.argument) && !node.argument.arguments.length ? node.argument.callee : t__namespace.arrowFunctionExpression([], node.argument) : node.argument,
                t__namespace.booleanLiteral(hasChildren)
            ])));
            return;
        }
        let value = node.value, key = t__namespace.isJSXNamespacedName(node.name) ? `${node.name.namespace.name}:${node.name.name.name}` : node.name.name, reservedNameSpace = t__namespace.isJSXNamespacedName(node.name) && node.name.namespace.name === "use";
        if (t__namespace.isJSXNamespacedName(node.name) && reservedNameSpace && !t__namespace.isJSXExpressionContainer(value)) node.value = value = t__namespace.JSXExpressionContainer(value || t__namespace.JSXEmptyExpression());
        if (t__namespace.isJSXExpressionContainer(value)) {
            if (key === "ref") {
                // Normalize expressions for non-null and type-as
                while(t__namespace.isTSNonNullExpression(value.expression) || t__namespace.isTSAsExpression(value.expression))value.expression = value.expression.expression;
                if (t__namespace.isLVal(value.expression)) {
                    const refIdentifier = path.scope.generateUidIdentifier("_ref$");
                    results.exprs.unshift(t__namespace.variableDeclaration("const", [
                        t__namespace.variableDeclarator(refIdentifier, value.expression)
                    ]), t__namespace.expressionStatement(t__namespace.conditionalExpression(t__namespace.binaryExpression("===", t__namespace.unaryExpression("typeof", refIdentifier), t__namespace.stringLiteral("function")), t__namespace.callExpression(refIdentifier, [
                        elem
                    ]), t__namespace.assignmentExpression("=", value.expression, elem))));
                } else if (t__namespace.isFunction(value.expression)) results.exprs.unshift(t__namespace.expressionStatement(t__namespace.callExpression(value.expression, [
                    elem
                ])));
                else if (t__namespace.isCallExpression(value.expression)) {
                    const refIdentifier = path.scope.generateUidIdentifier("_ref$");
                    results.exprs.unshift(t__namespace.variableDeclaration("const", [
                        t__namespace.variableDeclarator(refIdentifier, value.expression)
                    ]), t__namespace.expressionStatement(t__namespace.logicalExpression("&&", t__namespace.binaryExpression("===", t__namespace.unaryExpression("typeof", refIdentifier), t__namespace.stringLiteral("function")), t__namespace.callExpression(refIdentifier, [
                        elem
                    ]))));
                }
            } else if (key.startsWith("use:")) {
                // Some trick to treat JSXIdentifier as Identifier
                node.name.name.type = 'Identifier';
                results.exprs.unshift(t__namespace.expressionStatement(t__namespace.callExpression(node.name.name, [
                    elem,
                    t__namespace.arrowFunctionExpression([], t__namespace.isJSXEmptyExpression(value.expression) ? t__namespace.booleanLiteral(true) : value.expression)
                ])));
            } else if (key === "children") children = value;
            else if (config12.effectWrapper && isDynamic(attribute.get("value").get("expression"), {
                checkMember: true
            })) results.dynamics.push({
                elem,
                key,
                value: value.expression
            });
            else results.exprs.push(t__namespace.expressionStatement(setAttr(attribute, elem, key, value.expression)));
        } else results.exprs.push(t__namespace.expressionStatement(setAttr(attribute, elem, key, value)));
    });
    if (!hasChildren && children) path.node.children.push(children);
}
function setAttr(path, elem, name, value, { prevId  } = {}) {
    if (!value) value = t__namespace.booleanLiteral(true);
    return t__namespace.callExpression(registerImportMethod(path, "setProp"), prevId ? [
        elem,
        t__namespace.stringLiteral(name),
        value,
        prevId
    ] : [
        elem,
        t__namespace.stringLiteral(name),
        value
    ]);
}
function transformChildren(path, results) {
    const filteredChildren = filterChildren(path.get("children")), multi = checkLength(filteredChildren), childNodes = filteredChildren.map(transformNode).reduce((memo, child)=>{
        if (!child) return memo;
        const i = memo.length;
        if (child.text && i && memo[i - 1].text) memo[i - 1].template += child.template;
        else memo.push(child);
        return memo;
    }, []);
    const appends = [];
    childNodes.forEach((child, index8)=>{
        if (!child) return;
        if (child.id) {
            const insertNode = registerImportMethod(path, "insertNode");
            let insert = child.id;
            if (child.text) {
                const createTextNode = registerImportMethod(path, "createTextNode");
                if (multi) results.decl.push(t__namespace.variableDeclarator(child.id, t__namespace.callExpression(createTextNode, [
                    t__namespace.stringLiteral(htmlEntities.decode(child.template))
                ])));
                else insert = t__namespace.callExpression(createTextNode, [
                    t__namespace.stringLiteral(htmlEntities.decode(child.template))
                ]);
            }
            appends.push(t__namespace.expressionStatement(t__namespace.callExpression(insertNode, [
                results.id,
                insert
            ])));
            results.decl.push(...child.decl);
            results.exprs.push(...child.exprs);
            results.dynamics.push(...child.dynamics);
        } else if (child.exprs.length) {
            const insert = registerImportMethod(path, "insert");
            if (multi) results.exprs.push(t__namespace.expressionStatement(t__namespace.callExpression(insert, [
                results.id,
                child.exprs[0],
                nextChild(childNodes, index8) || t__namespace.nullLiteral()
            ])));
            else results.exprs.push(t__namespace.expressionStatement(t__namespace.callExpression(insert, [
                results.id,
                child.exprs[0]
            ])));
        }
    });
    results.exprs.unshift(...appends);
}
function nextChild(children, index9) {
    return children[index9 + 1] && (children[index9 + 1].id || nextChild(children, index9 + 1));
}
function createTemplate(path, result, wrap) {
    const config13 = getConfig(path);
    if (result.id) {
        result.decl = t__namespace.variableDeclaration("const", result.decl);
        if (!(result.exprs.length || result.dynamics.length || result.postExprs.length) && result.decl.declarations.length === 1) return result.decl.declarations[0].init;
        else return t__namespace.callExpression(t__namespace.arrowFunctionExpression([], t__namespace.blockStatement([
            result.decl,
            ...result.exprs.concat(wrapDynamics(path, result.dynamics) || [], result.postExprs || []),
            t__namespace.returnStatement(result.id)
        ])), []);
    }
    if (wrap && result.dynamic && config13.memoWrapper) return t__namespace.callExpression(registerImportMethod(path, config13.memoWrapper), [
        result.exprs[0]
    ]);
    return result.exprs[0];
}
function wrapDynamics(path, dynamics) {
    if (!dynamics.length) return;
    const config14 = getConfig(path);
    const effectWrapperId = registerImportMethod(path, config14.effectWrapper);
    if (dynamics.length === 1) {
        const prevValue = t__namespace.identifier("_$p");
        return t__namespace.expressionStatement(t__namespace.callExpression(effectWrapperId, [
            t__namespace.arrowFunctionExpression([
                prevValue
            ], setAttr(path, dynamics[0].elem, dynamics[0].key, dynamics[0].value, {
                dynamic: true,
                prevId: prevValue
            }))
        ]));
    }
    const decls = [], statements = [], identifiers = [], prevId = t__namespace.identifier("_p$");
    dynamics.forEach(({ elem , key , value  })=>{
        const identifier = path.scope.generateUidIdentifier("v$");
        identifiers.push(identifier);
        decls.push(t__namespace.variableDeclarator(identifier, value));
        const prev = t__namespace.memberExpression(prevId, identifier);
        statements.push(t__namespace.expressionStatement(t__namespace.logicalExpression("&&", t__namespace.binaryExpression("!==", identifier, t__namespace.memberExpression(prevId, identifier)), t__namespace.assignmentExpression("=", t__namespace.memberExpression(prevId, identifier), setAttr(path, elem, key, identifier, {
            dynamic: true,
            prevId: prev
        })))));
    });
    return t__namespace.expressionStatement(t__namespace.callExpression(effectWrapperId, [
        t__namespace.arrowFunctionExpression([
            prevId
        ], t__namespace.blockStatement([
            t__namespace.variableDeclaration("const", decls),
            ...statements,
            t__namespace.returnStatement(prevId)
        ])),
        t__namespace.objectExpression(identifiers.map((id)=>t__namespace.objectProperty(id, t__namespace.identifier("undefined"))
        ))
    ]));
}
function convertComponentIdentifier(node) {
    if (t__namespace.isJSXIdentifier(node)) {
        if (t__namespace.isValidIdentifier(node.name)) node.type = "Identifier";
        else return t__namespace.stringLiteral(node.name);
    } else if (t__namespace.isJSXMemberExpression(node)) {
        const prop = convertComponentIdentifier(node.property);
        const computed = t__namespace.isStringLiteral(prop);
        return t__namespace.memberExpression(convertComponentIdentifier(node.object), prop, computed);
    }
    return node;
}
function convertJSXIdentifier(node) {
    if (t__namespace.isJSXIdentifier(node)) {
        if (t__namespace.isValidIdentifier(node.name)) node.type = "Identifier";
        else return t__namespace.stringLiteral(node.name);
    } else if (t__namespace.isJSXMemberExpression(node)) return t__namespace.memberExpression(convertJSXIdentifier(node.object), convertJSXIdentifier(node.property));
    else if (t__namespace.isJSXNamespacedName(node)) return t__namespace.stringLiteral(`${node.namespace.name}:${node.name.name}`);
    return node;
}
function transformComponent(path) {
    let exprs = [], config15 = getConfig(path), tagId = convertComponentIdentifier(path.node.openingElement.name), props = [], runningObject = [], dynamicSpread = false, hasChildren = path.node.children.length > 0;
    if (config15.builtIns.indexOf(tagId.name) > -1 && !path.scope.hasBinding(tagId.name)) {
        const newTagId = registerImportMethod(path, tagId.name);
        tagId.name = newTagId.name;
    }
    path.get("openingElement").get("attributes").forEach((attribute)=>{
        const node = attribute.node;
        if (t__namespace.isJSXSpreadAttribute(node)) {
            if (runningObject.length) {
                props.push(t__namespace.objectExpression(runningObject));
                runningObject = [];
            }
            props.push(isDynamic(attribute.get("argument"), {
                checkMember: true
            }) && (dynamicSpread = true) ? t__namespace.isCallExpression(node.argument) && !node.argument.arguments.length && !t__namespace.isCallExpression(node.argument.callee) && !t__namespace.isMemberExpression(node.argument.callee) ? node.argument.callee : t__namespace.arrowFunctionExpression([], node.argument) : node.argument);
        } else {
            const value = node.value || t__namespace.booleanLiteral(true), id = convertJSXIdentifier(node.name), key = id.name;
            if (hasChildren && key === "children") return;
            if (t__namespace.isJSXExpressionContainer(value)) {
                if (key === "ref") {
                    if (config15.generate === "ssr") return;
                    // Normalize expressions for non-null and type-as
                    while(t__namespace.isTSNonNullExpression(value.expression) || t__namespace.isTSAsExpression(value.expression))value.expression = value.expression.expression;
                    let binding, isFunction = t__namespace.isIdentifier(value.expression) && (binding = path.scope.getBinding(value.expression.name)) && binding.kind === "const";
                    if (!isFunction && t__namespace.isLVal(value.expression)) {
                        const refIdentifier = path.scope.generateUidIdentifier("_ref$");
                        runningObject.push(t__namespace.objectMethod("method", t__namespace.identifier("ref"), [
                            t__namespace.identifier("r$")
                        ], t__namespace.blockStatement([
                            t__namespace.variableDeclaration("const", [
                                t__namespace.variableDeclarator(refIdentifier, value.expression)
                            ]),
                            t__namespace.expressionStatement(t__namespace.conditionalExpression(t__namespace.binaryExpression("===", t__namespace.unaryExpression("typeof", refIdentifier), t__namespace.stringLiteral("function")), t__namespace.callExpression(refIdentifier, [
                                t__namespace.identifier("r$")
                            ]), t__namespace.assignmentExpression("=", value.expression, t__namespace.identifier("r$"))))
                        ])));
                    } else if (isFunction || t__namespace.isFunction(value.expression)) runningObject.push(t__namespace.objectProperty(t__namespace.identifier("ref"), value.expression));
                    else if (t__namespace.isCallExpression(value.expression)) {
                        const refIdentifier = path.scope.generateUidIdentifier("_ref$");
                        runningObject.push(t__namespace.objectMethod("method", t__namespace.identifier("ref"), [
                            t__namespace.identifier("r$")
                        ], t__namespace.blockStatement([
                            t__namespace.variableDeclaration("const", [
                                t__namespace.variableDeclarator(refIdentifier, value.expression)
                            ]),
                            t__namespace.expressionStatement(t__namespace.logicalExpression("&&", t__namespace.binaryExpression("===", t__namespace.unaryExpression("typeof", refIdentifier), t__namespace.stringLiteral("function")), t__namespace.callExpression(refIdentifier, [
                                t__namespace.identifier("r$")
                            ])))
                        ])));
                    }
                } else if (isDynamic(attribute.get("value").get("expression"), {
                    checkMember: true,
                    checkTags: true
                })) {
                    let expr = config15.wrapConditionals && config15.generate !== "ssr" && (t__namespace.isLogicalExpression(value.expression) || t__namespace.isConditionalExpression(value.expression)) ? transformCondition(attribute.get("value").get("expression"), true) : t__namespace.arrowFunctionExpression([], value.expression);
                    runningObject.push(t__namespace.objectMethod("get", id, [], t__namespace.blockStatement([
                        t__namespace.returnStatement(expr.body)
                    ]), !t__namespace.isValidIdentifier(key)));
                } else runningObject.push(t__namespace.objectProperty(id, value.expression));
            } else runningObject.push(t__namespace.objectProperty(id, value));
        }
    });
    const childResult = transformComponentChildren(path.get("children"), config15);
    if (childResult && childResult[0]) {
        if (childResult[1]) {
            const body = t__namespace.isCallExpression(childResult[0]) && t__namespace.isFunction(childResult[0].callee) ? childResult[0].callee.body : childResult[0].body;
            runningObject.push(t__namespace.objectMethod("get", t__namespace.identifier("children"), [], t__namespace.isExpression(body) ? t__namespace.blockStatement([
                t__namespace.returnStatement(body)
            ]) : body));
        } else runningObject.push(t__namespace.objectProperty(t__namespace.identifier("children"), childResult[0]));
    }
    if (runningObject.length || !props.length) props.push(t__namespace.objectExpression(runningObject));
    if (props.length > 1 || dynamicSpread) props = [
        t__namespace.callExpression(registerImportMethod(path, "mergeProps"), props)
    ];
    const componentArgs = [
        tagId,
        props[0]
    ];
    exprs.push(t__namespace.callExpression(registerImportMethod(path, "createComponent"), componentArgs));
    // handle hoisting conditionals
    if (exprs.length > 1) {
        const ret = exprs.pop();
        exprs = [
            t__namespace.callExpression(t__namespace.arrowFunctionExpression([], t__namespace.blockStatement([
                ...exprs,
                t__namespace.returnStatement(ret)
            ])), [])
        ];
    }
    return {
        exprs,
        template: "",
        component: true
    };
}
function transformComponentChildren(children, config16) {
    const createTemplate$3 = config16.generate === "universal" ? createTemplate : config16.generate === "ssr" ? createTemplate$1 : createTemplate$2, filteredChildren = filterChildren(children);
    if (!filteredChildren.length) return;
    let dynamic = false;
    let transformedChildren = filteredChildren.reduce((memo, path)=>{
        if (t__namespace.isJSXText(path.node)) {
            const v = htmlEntities.decode(trimWhitespace(path.node.extra.raw));
            if (v.length) memo.push(t__namespace.stringLiteral(v));
        } else {
            const child = transformNode(path, {
                topLevel: true,
                componentChild: true
            });
            dynamic = dynamic || child.dynamic;
            memo.push(createTemplate$3(path, child, filteredChildren.length > 1));
        }
        return memo;
    }, []);
    if (transformedChildren.length === 1) {
        transformedChildren = transformedChildren[0];
        if (!t__namespace.isJSXExpressionContainer(filteredChildren[0]) && !t__namespace.isJSXSpreadChild(filteredChildren[0]) && !t__namespace.isJSXText(filteredChildren[0])) {
            transformedChildren = t__namespace.isCallExpression(transformedChildren) && !transformedChildren.arguments.length && !t__namespace.isIdentifier(transformedChildren.callee) ? transformedChildren.callee : t__namespace.arrowFunctionExpression([], transformedChildren);
            dynamic = true;
        }
    } else {
        transformedChildren = t__namespace.arrowFunctionExpression([], t__namespace.arrayExpression(transformedChildren));
        dynamic = true;
    }
    return [
        transformedChildren,
        dynamic
    ];
}
function transformFragmentChildren(children, results, config17) {
    const createTemplate$3 = config17.generate === "universal" ? createTemplate : config17.generate === "ssr" ? createTemplate$1 : createTemplate$2, filteredChildren = filterChildren(children), childNodes = filteredChildren.reduce((memo, path)=>{
        if (t__namespace.isJSXText(path.node)) {
            const v = htmlEntities.decode(trimWhitespace(path.node.extra.raw));
            if (v.length) memo.push(t__namespace.stringLiteral(v));
        } else {
            const child = transformNode(path, {
                topLevel: true,
                fragmentChild: true
            });
            memo.push(createTemplate$3(path, child, true));
        }
        return memo;
    }, []);
    results.exprs.push(childNodes.length === 1 ? childNodes[0] : t__namespace.arrayExpression(childNodes));
}
function transformJSX(path) {
    const config18 = getConfig(path);
    const replace = transformThis(path);
    const result = transformNode(path, t__namespace.isJSXFragment(path.node) ? {} : {
        topLevel: true
    });
    const template = config18.generate === "universal" ? createTemplate : config18.generate === "ssr" ? createTemplate$1 : createTemplate$2;
    path.replaceWith(replace(template(path, result, false)));
}
function transformThis(path1) {
    let thisId;
    path1.traverse({
        ThisExpression (path) {
            thisId || (thisId = path.scope.generateUidIdentifier("self$"));
            path.replaceWith(thisId);
        }
    });
    return (node)=>{
        if (thisId) {
            let parent = path1.getStatementParent();
            const decl = t__namespace.variableDeclaration("const", [
                t__namespace.variableDeclarator(thisId, t__namespace.thisExpression())
            ]);
            parent.insertBefore(decl);
        }
        return node;
    };
}
function transformNode(path, info = {}) {
    const config19 = getConfig(path);
    const node = path.node;
    let staticValue;
    if (t__namespace.isJSXElement(node)) {
        let tagName = getTagName(node);
        if (isComponent(tagName)) return transformComponent(path);
        const element = config19.generate === "universal" ? transformElement : config19.generate === "ssr" ? transformElement$1 : transformElement$2;
        return element(path, info);
    } else if (t__namespace.isJSXFragment(node)) {
        let results = {
            template: "",
            decl: [],
            exprs: [],
            dynamics: []
        };
        transformFragmentChildren(path.get("children"), results, config19);
        return results;
    } else if (t__namespace.isJSXText(node) || (staticValue = getStaticExpression(path))) {
        const text = staticValue !== undefined ? !info.doNotEscape ? escapeHTML(staticValue.toString()) : staticValue.toString() : trimWhitespace(node.extra.raw);
        if (!text.length) return null;
        const results = {
            template: config19.generate === "dom" ? escapeBackticks(text) : text,
            decl: [],
            exprs: [],
            dynamics: [],
            postExprs: [],
            text: true
        };
        if (!info.skipId && config19.generate !== "ssr") results.id = path.scope.generateUidIdentifier("el$");
        return results;
    } else if (t__namespace.isJSXExpressionContainer(node)) {
        if (t__namespace.isJSXEmptyExpression(node.expression)) return null;
        if (!isDynamic(path.get("expression"), {
            checkMember: true,
            checkTags: !!info.componentChild,
            native: !info.componentChild
        })) return {
            exprs: [
                node.expression
            ],
            template: ""
        };
        const expr = config19.wrapConditionals && config19.generate !== "ssr" && (t__namespace.isLogicalExpression(node.expression) || t__namespace.isConditionalExpression(node.expression)) ? transformCondition(path.get("expression"), info.componentChild) : !info.componentChild && (config19.generate !== "ssr" || info.fragmentChild) && t__namespace.isCallExpression(node.expression) && !t__namespace.isMemberExpression(node.expression.callee) && node.expression.arguments.length === 0 ? node.expression.callee : t__namespace.arrowFunctionExpression([], node.expression);
        return {
            exprs: expr.length > 1 ? [
                t__namespace.callExpression(t__namespace.arrowFunctionExpression([], t__namespace.blockStatement([
                    expr[0],
                    t__namespace.returnStatement(expr[1])
                ])), [])
            ] : [
                expr
            ],
            template: "",
            dynamic: true
        };
    } else if (t__namespace.isJSXSpreadChild(node)) {
        if (!isDynamic(path.get("expression"), {
            checkMember: true,
            native: !info.componentChild
        })) return {
            exprs: [
                node.expression
            ],
            template: ""
        };
        const expr = t__namespace.arrowFunctionExpression([], node.expression);
        return {
            exprs: [
                expr
            ],
            template: "",
            dynamic: true
        };
    }
}
// add to the top/bottom of the module.
var postprocess = (path)=>{
    const config20 = getConfig(path);
    if (path.scope.data.events) path.node.body.push(t__namespace.expressionStatement(t__namespace.callExpression(registerImportMethod(path, "delegateEvents"), [
        t__namespace.arrayExpression(Array.from(path.scope.data.events).map((e)=>t__namespace.stringLiteral(e)
        ))
    ])));
    if (path.scope.data.templates) {
        const appendTemplates$2 = config20.generate === "ssr" ? appendTemplates : appendTemplates$1;
        appendTemplates$2(path, path.scope.data.templates);
    }
};
var config = {
    moduleName: "dom",
    generate: "dom",
    hydratable: false,
    delegateEvents: true,
    delegatedEvents: [],
    builtIns: [],
    requireImportSource: false,
    wrapConditionals: true,
    contextToCustomElements: false,
    staticMarker: "@once",
    effectWrapper: "effect",
    memoWrapper: "memo"
};
var preprocess = (path, { opts  })=>{
    const merged = path.hub.file.metadata.config = Object.assign({}, config, opts);
    const lib = merged.requireImportSource;
    if (lib) {
        const comments = path.hub.file.ast.comments;
        for(let i = 0; i < comments.length; i++){
            const comment = comments[i];
            const index10 = comment.value.indexOf("@jsxImportSource");
            if (index10 > -1 && comment.value.slice(index10).includes(lib)) return;
        }
        path.skip();
    }
};
var index = ()=>{
    return {
        name: "JSX DOM Expressions",
        inherits: SyntaxJSX__default["default"],
        visitor: {
            JSXElement: transformJSX,
            JSXFragment: transformJSX,
            Program: {
                enter: preprocess,
                exit: postprocess
            }
        }
    };
};
module.exports = index;

},{"@babel/plugin-syntax-jsx":"gpnvg","@babel/types":"fN4fD","@babel/helper-module-imports":"jj9rJ","html-entities":"7QVnB"}],"gpnvg":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    return {
        name: "syntax-jsx",
        manipulateOptions (opts, parserOpts) {
            if (parserOpts.plugins.some((p)=>(Array.isArray(p) ? p[0] : p) === "typescript"
            )) return;
            parserOpts.plugins.push("jsx");
        }
    };
});
exports.default = _default;

},{"@babel/helper-plugin-utils":"g7vWl"}],"g7vWl":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.declare = declare;
function declare(builder) {
    return (api, options, dirname)=>{
        var _clonedApi2;
        let clonedApi;
        for (const name of Object.keys(apiPolyfills)){
            var _clonedApi;
            if (api[name]) continue;
            clonedApi = (_clonedApi = clonedApi) != null ? _clonedApi : copyApiObject(api);
            clonedApi[name] = apiPolyfills[name](clonedApi);
        }
        return builder((_clonedApi2 = clonedApi) != null ? _clonedApi2 : api, options || {}, dirname);
    };
}
const apiPolyfills = {
    assertVersion: (api)=>(range)=>{
            throwVersionError(range, api.version);
        }
    ,
    targets: ()=>()=>{
            return {};
        }
    ,
    assumption: ()=>()=>{}
};
function copyApiObject(api) {
    let proto = null;
    if (typeof api.version === "string" && /^7\./.test(api.version)) {
        proto = Object.getPrototypeOf(api);
        if (proto && (!has(proto, "version") || !has(proto, "transform") || !has(proto, "template") || !has(proto, "types"))) proto = null;
    }
    return Object.assign({}, proto, api);
}
function has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
function throwVersionError(range, version) {
    if (typeof range === "number") {
        if (!Number.isInteger(range)) throw new Error("Expected string or integer value.");
        range = `^${range}.0.0-0`;
    }
    if (typeof range !== "string") throw new Error("Expected string or integer value.");
    const limit = Error.stackTraceLimit;
    if (typeof limit === "number" && limit < 25) Error.stackTraceLimit = 25;
    let err;
    if (version.slice(0, 2) === "7.") err = new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${version}". ` + `You'll need to update your @babel/core version.`);
    else err = new Error(`Requires Babel "${range}", but was loaded with "${version}". ` + `If you are sure you have a compatible version of @babel/core, ` + `it is likely that something in your build process is loading the ` + `wrong version. Inspect the stack trace of this error to look for ` + `the first entry that doesn't mention "@babel/core" or "babel-core" ` + `to see what is calling Babel.`);
    if (typeof limit === "number") Error.stackTraceLimit = limit;
    throw Object.assign(err, {
        code: "BABEL_VERSION_UNSUPPORTED",
        version,
        range
    });
}

},{}],"fN4fD":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _exportNames = {
    react: true,
    assertNode: true,
    createTypeAnnotationBasedOnTypeof: true,
    createUnionTypeAnnotation: true,
    createFlowUnionType: true,
    createTSUnionType: true,
    cloneNode: true,
    clone: true,
    cloneDeep: true,
    cloneDeepWithoutLoc: true,
    cloneWithoutLoc: true,
    addComment: true,
    addComments: true,
    inheritInnerComments: true,
    inheritLeadingComments: true,
    inheritsComments: true,
    inheritTrailingComments: true,
    removeComments: true,
    ensureBlock: true,
    toBindingIdentifierName: true,
    toBlock: true,
    toComputedKey: true,
    toExpression: true,
    toIdentifier: true,
    toKeyAlias: true,
    toSequenceExpression: true,
    toStatement: true,
    valueToNode: true,
    appendToMemberExpression: true,
    inherits: true,
    prependToMemberExpression: true,
    removeProperties: true,
    removePropertiesDeep: true,
    removeTypeDuplicates: true,
    getBindingIdentifiers: true,
    getOuterBindingIdentifiers: true,
    traverse: true,
    traverseFast: true,
    shallowEqual: true,
    is: true,
    isBinding: true,
    isBlockScoped: true,
    isImmutable: true,
    isLet: true,
    isNode: true,
    isNodesEquivalent: true,
    isPlaceholderType: true,
    isReferenced: true,
    isScope: true,
    isSpecifierDefault: true,
    isType: true,
    isValidES3Identifier: true,
    isValidIdentifier: true,
    isVar: true,
    matchesPattern: true,
    validate: true,
    buildMatchMemberExpression: true
};
Object.defineProperty(exports, "addComment", {
    enumerable: true,
    get: function() {
        return _addComment.default;
    }
});
Object.defineProperty(exports, "addComments", {
    enumerable: true,
    get: function() {
        return _addComments.default;
    }
});
Object.defineProperty(exports, "appendToMemberExpression", {
    enumerable: true,
    get: function() {
        return _appendToMemberExpression.default;
    }
});
Object.defineProperty(exports, "assertNode", {
    enumerable: true,
    get: function() {
        return _assertNode.default;
    }
});
Object.defineProperty(exports, "buildMatchMemberExpression", {
    enumerable: true,
    get: function() {
        return _buildMatchMemberExpression.default;
    }
});
Object.defineProperty(exports, "clone", {
    enumerable: true,
    get: function() {
        return _clone.default;
    }
});
Object.defineProperty(exports, "cloneDeep", {
    enumerable: true,
    get: function() {
        return _cloneDeep.default;
    }
});
Object.defineProperty(exports, "cloneDeepWithoutLoc", {
    enumerable: true,
    get: function() {
        return _cloneDeepWithoutLoc.default;
    }
});
Object.defineProperty(exports, "cloneNode", {
    enumerable: true,
    get: function() {
        return _cloneNode.default;
    }
});
Object.defineProperty(exports, "cloneWithoutLoc", {
    enumerable: true,
    get: function() {
        return _cloneWithoutLoc.default;
    }
});
Object.defineProperty(exports, "createFlowUnionType", {
    enumerable: true,
    get: function() {
        return _createFlowUnionType.default;
    }
});
Object.defineProperty(exports, "createTSUnionType", {
    enumerable: true,
    get: function() {
        return _createTSUnionType.default;
    }
});
Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
    enumerable: true,
    get: function() {
        return _createTypeAnnotationBasedOnTypeof.default;
    }
});
Object.defineProperty(exports, "createUnionTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _createFlowUnionType.default;
    }
});
Object.defineProperty(exports, "ensureBlock", {
    enumerable: true,
    get: function() {
        return _ensureBlock.default;
    }
});
Object.defineProperty(exports, "getBindingIdentifiers", {
    enumerable: true,
    get: function() {
        return _getBindingIdentifiers.default;
    }
});
Object.defineProperty(exports, "getOuterBindingIdentifiers", {
    enumerable: true,
    get: function() {
        return _getOuterBindingIdentifiers.default;
    }
});
Object.defineProperty(exports, "inheritInnerComments", {
    enumerable: true,
    get: function() {
        return _inheritInnerComments.default;
    }
});
Object.defineProperty(exports, "inheritLeadingComments", {
    enumerable: true,
    get: function() {
        return _inheritLeadingComments.default;
    }
});
Object.defineProperty(exports, "inheritTrailingComments", {
    enumerable: true,
    get: function() {
        return _inheritTrailingComments.default;
    }
});
Object.defineProperty(exports, "inherits", {
    enumerable: true,
    get: function() {
        return _inherits.default;
    }
});
Object.defineProperty(exports, "inheritsComments", {
    enumerable: true,
    get: function() {
        return _inheritsComments.default;
    }
});
Object.defineProperty(exports, "is", {
    enumerable: true,
    get: function() {
        return _is.default;
    }
});
Object.defineProperty(exports, "isBinding", {
    enumerable: true,
    get: function() {
        return _isBinding.default;
    }
});
Object.defineProperty(exports, "isBlockScoped", {
    enumerable: true,
    get: function() {
        return _isBlockScoped.default;
    }
});
Object.defineProperty(exports, "isImmutable", {
    enumerable: true,
    get: function() {
        return _isImmutable.default;
    }
});
Object.defineProperty(exports, "isLet", {
    enumerable: true,
    get: function() {
        return _isLet.default;
    }
});
Object.defineProperty(exports, "isNode", {
    enumerable: true,
    get: function() {
        return _isNode.default;
    }
});
Object.defineProperty(exports, "isNodesEquivalent", {
    enumerable: true,
    get: function() {
        return _isNodesEquivalent.default;
    }
});
Object.defineProperty(exports, "isPlaceholderType", {
    enumerable: true,
    get: function() {
        return _isPlaceholderType.default;
    }
});
Object.defineProperty(exports, "isReferenced", {
    enumerable: true,
    get: function() {
        return _isReferenced.default;
    }
});
Object.defineProperty(exports, "isScope", {
    enumerable: true,
    get: function() {
        return _isScope.default;
    }
});
Object.defineProperty(exports, "isSpecifierDefault", {
    enumerable: true,
    get: function() {
        return _isSpecifierDefault.default;
    }
});
Object.defineProperty(exports, "isType", {
    enumerable: true,
    get: function() {
        return _isType.default;
    }
});
Object.defineProperty(exports, "isValidES3Identifier", {
    enumerable: true,
    get: function() {
        return _isValidES3Identifier.default;
    }
});
Object.defineProperty(exports, "isValidIdentifier", {
    enumerable: true,
    get: function() {
        return _isValidIdentifier.default;
    }
});
Object.defineProperty(exports, "isVar", {
    enumerable: true,
    get: function() {
        return _isVar.default;
    }
});
Object.defineProperty(exports, "matchesPattern", {
    enumerable: true,
    get: function() {
        return _matchesPattern.default;
    }
});
Object.defineProperty(exports, "prependToMemberExpression", {
    enumerable: true,
    get: function() {
        return _prependToMemberExpression.default;
    }
});
exports.react = void 0;
Object.defineProperty(exports, "removeComments", {
    enumerable: true,
    get: function() {
        return _removeComments.default;
    }
});
Object.defineProperty(exports, "removeProperties", {
    enumerable: true,
    get: function() {
        return _removeProperties.default;
    }
});
Object.defineProperty(exports, "removePropertiesDeep", {
    enumerable: true,
    get: function() {
        return _removePropertiesDeep.default;
    }
});
Object.defineProperty(exports, "removeTypeDuplicates", {
    enumerable: true,
    get: function() {
        return _removeTypeDuplicates.default;
    }
});
Object.defineProperty(exports, "shallowEqual", {
    enumerable: true,
    get: function() {
        return _shallowEqual.default;
    }
});
Object.defineProperty(exports, "toBindingIdentifierName", {
    enumerable: true,
    get: function() {
        return _toBindingIdentifierName.default;
    }
});
Object.defineProperty(exports, "toBlock", {
    enumerable: true,
    get: function() {
        return _toBlock.default;
    }
});
Object.defineProperty(exports, "toComputedKey", {
    enumerable: true,
    get: function() {
        return _toComputedKey.default;
    }
});
Object.defineProperty(exports, "toExpression", {
    enumerable: true,
    get: function() {
        return _toExpression.default;
    }
});
Object.defineProperty(exports, "toIdentifier", {
    enumerable: true,
    get: function() {
        return _toIdentifier.default;
    }
});
Object.defineProperty(exports, "toKeyAlias", {
    enumerable: true,
    get: function() {
        return _toKeyAlias.default;
    }
});
Object.defineProperty(exports, "toSequenceExpression", {
    enumerable: true,
    get: function() {
        return _toSequenceExpression.default;
    }
});
Object.defineProperty(exports, "toStatement", {
    enumerable: true,
    get: function() {
        return _toStatement.default;
    }
});
Object.defineProperty(exports, "traverse", {
    enumerable: true,
    get: function() {
        return _traverse.default;
    }
});
Object.defineProperty(exports, "traverseFast", {
    enumerable: true,
    get: function() {
        return _traverseFast.default;
    }
});
Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
        return _validate.default;
    }
});
Object.defineProperty(exports, "valueToNode", {
    enumerable: true,
    get: function() {
        return _valueToNode.default;
    }
});
var _isReactComponent = require("./validators/react/isReactComponent");
var _isCompatTag = require("./validators/react/isCompatTag");
var _buildChildren = require("./builders/react/buildChildren");
var _assertNode = require("./asserts/assertNode");
var _generated = require("./asserts/generated");
Object.keys(_generated).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _generated[key];
        }
    });
});
var _createTypeAnnotationBasedOnTypeof = require("./builders/flow/createTypeAnnotationBasedOnTypeof");
var _createFlowUnionType = require("./builders/flow/createFlowUnionType");
var _createTSUnionType = require("./builders/typescript/createTSUnionType");
var _generated2 = require("./builders/generated");
Object.keys(_generated2).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated2[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _generated2[key];
        }
    });
});
var _uppercase = require("./builders/generated/uppercase");
Object.keys(_uppercase).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _uppercase[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _uppercase[key];
        }
    });
});
var _cloneNode = require("./clone/cloneNode");
var _clone = require("./clone/clone");
var _cloneDeep = require("./clone/cloneDeep");
var _cloneDeepWithoutLoc = require("./clone/cloneDeepWithoutLoc");
var _cloneWithoutLoc = require("./clone/cloneWithoutLoc");
var _addComment = require("./comments/addComment");
var _addComments = require("./comments/addComments");
var _inheritInnerComments = require("./comments/inheritInnerComments");
var _inheritLeadingComments = require("./comments/inheritLeadingComments");
var _inheritsComments = require("./comments/inheritsComments");
var _inheritTrailingComments = require("./comments/inheritTrailingComments");
var _removeComments = require("./comments/removeComments");
var _generated3 = require("./constants/generated");
Object.keys(_generated3).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated3[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _generated3[key];
        }
    });
});
var _constants = require("./constants");
Object.keys(_constants).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _constants[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _constants[key];
        }
    });
});
var _ensureBlock = require("./converters/ensureBlock");
var _toBindingIdentifierName = require("./converters/toBindingIdentifierName");
var _toBlock = require("./converters/toBlock");
var _toComputedKey = require("./converters/toComputedKey");
var _toExpression = require("./converters/toExpression");
var _toIdentifier = require("./converters/toIdentifier");
var _toKeyAlias = require("./converters/toKeyAlias");
var _toSequenceExpression = require("./converters/toSequenceExpression");
var _toStatement = require("./converters/toStatement");
var _valueToNode = require("./converters/valueToNode");
var _definitions = require("./definitions");
Object.keys(_definitions).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _definitions[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _definitions[key];
        }
    });
});
var _appendToMemberExpression = require("./modifications/appendToMemberExpression");
var _inherits = require("./modifications/inherits");
var _prependToMemberExpression = require("./modifications/prependToMemberExpression");
var _removeProperties = require("./modifications/removeProperties");
var _removePropertiesDeep = require("./modifications/removePropertiesDeep");
var _removeTypeDuplicates = require("./modifications/flow/removeTypeDuplicates");
var _getBindingIdentifiers = require("./retrievers/getBindingIdentifiers");
var _getOuterBindingIdentifiers = require("./retrievers/getOuterBindingIdentifiers");
var _traverse = require("./traverse/traverse");
Object.keys(_traverse).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _traverse[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _traverse[key];
        }
    });
});
var _traverseFast = require("./traverse/traverseFast");
var _shallowEqual = require("./utils/shallowEqual");
var _is = require("./validators/is");
var _isBinding = require("./validators/isBinding");
var _isBlockScoped = require("./validators/isBlockScoped");
var _isImmutable = require("./validators/isImmutable");
var _isLet = require("./validators/isLet");
var _isNode = require("./validators/isNode");
var _isNodesEquivalent = require("./validators/isNodesEquivalent");
var _isPlaceholderType = require("./validators/isPlaceholderType");
var _isReferenced = require("./validators/isReferenced");
var _isScope = require("./validators/isScope");
var _isSpecifierDefault = require("./validators/isSpecifierDefault");
var _isType = require("./validators/isType");
var _isValidES3Identifier = require("./validators/isValidES3Identifier");
var _isValidIdentifier = require("./validators/isValidIdentifier");
var _isVar = require("./validators/isVar");
var _matchesPattern = require("./validators/matchesPattern");
var _validate = require("./validators/validate");
var _buildMatchMemberExpression = require("./validators/buildMatchMemberExpression");
var _generated4 = require("./validators/generated");
Object.keys(_generated4).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated4[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _generated4[key];
        }
    });
});
var _generated5 = require("./ast-types/generated");
Object.keys(_generated5).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated5[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _generated5[key];
        }
    });
});
const react = {
    isReactComponent: _isReactComponent.default,
    isCompatTag: _isCompatTag.default,
    buildChildren: _buildChildren.default
};
exports.react = react;

},{"./validators/react/isReactComponent":"19SJ4","./validators/react/isCompatTag":"8F123","./builders/react/buildChildren":"i1W4S","./asserts/assertNode":"kwNUX","./asserts/generated":"jw7Eg","./builders/flow/createTypeAnnotationBasedOnTypeof":"7OaWy","./builders/flow/createFlowUnionType":"ilG9a","./builders/typescript/createTSUnionType":"kfOse","./builders/generated":"1t4GT","./builders/generated/uppercase":"3Bbdf","./clone/cloneNode":"9Uv0G","./clone/clone":"5e1Qq","./clone/cloneDeep":"7a8ZO","./clone/cloneDeepWithoutLoc":"l7vJf","./clone/cloneWithoutLoc":"2hNWY","./comments/addComment":"kR7Gx","./comments/addComments":"ezUCd","./comments/inheritInnerComments":"9QaTf","./comments/inheritLeadingComments":"9pYNJ","./comments/inheritsComments":"j0S4j","./comments/inheritTrailingComments":"jm9ZN","./comments/removeComments":"i6Mcq","./constants/generated":"dcabq","./constants":"lrpJ7","./converters/ensureBlock":"kRy1K","./converters/toBindingIdentifierName":"1yiSv","./converters/toBlock":"8XIXS","./converters/toComputedKey":"k0odi","./converters/toExpression":"3Qu81","./converters/toIdentifier":"10UkJ","./converters/toKeyAlias":"6fIoF","./converters/toSequenceExpression":"7Efdr","./converters/toStatement":"7Z4XE","./converters/valueToNode":"i2VNJ","./definitions":"dzUB7","./modifications/appendToMemberExpression":"eboGQ","./modifications/inherits":"7zhDm","./modifications/prependToMemberExpression":"avsQy","./modifications/removeProperties":"eAGoy","./modifications/removePropertiesDeep":"2nndW","./modifications/flow/removeTypeDuplicates":"syAKf","./retrievers/getBindingIdentifiers":"1guAF","./retrievers/getOuterBindingIdentifiers":"9r9fp","./traverse/traverse":"8GP2S","./traverse/traverseFast":"emIrr","./utils/shallowEqual":"9y7Dh","./validators/is":"g9VKJ","./validators/isBinding":"eBXmT","./validators/isBlockScoped":"7cpnc","./validators/isImmutable":"15E5c","./validators/isLet":"iu6ca","./validators/isNode":"AMA6N","./validators/isNodesEquivalent":"e2PUg","./validators/isPlaceholderType":"dO0QO","./validators/isReferenced":"9QTMn","./validators/isScope":"eeDGz","./validators/isSpecifierDefault":"e0Br2","./validators/isType":"dZEXP","./validators/isValidES3Identifier":"gDxdp","./validators/isValidIdentifier":"gb2G9","./validators/isVar":"b5upV","./validators/matchesPattern":"fCTxl","./validators/validate":"hEMm0","./validators/buildMatchMemberExpression":"5M13O","./validators/generated":"bjDwT","./ast-types/generated":"jfLwn"}],"19SJ4":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _buildMatchMemberExpression = require("../buildMatchMemberExpression");
const isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
var _default = isReactComponent;
exports.default = _default;

},{"../buildMatchMemberExpression":"5M13O"}],"5M13O":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = buildMatchMemberExpression;
var _matchesPattern = require("./matchesPattern");
function buildMatchMemberExpression(match, allowPartial) {
    const parts = match.split(".");
    return (member)=>(0, _matchesPattern.default)(member, parts, allowPartial)
    ;
}

},{"./matchesPattern":"fCTxl"}],"fCTxl":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = matchesPattern;
var _generated = require("./generated");
function matchesPattern(member, match, allowPartial) {
    if (!(0, _generated.isMemberExpression)(member)) return false;
    const parts = Array.isArray(match) ? match : match.split(".");
    const nodes = [];
    let node;
    for(node = member; (0, _generated.isMemberExpression)(node); node = node.object)nodes.push(node.property);
    nodes.push(node);
    if (nodes.length < parts.length) return false;
    if (!allowPartial && nodes.length > parts.length) return false;
    for(let i = 0, j = nodes.length - 1; i < parts.length; i++, j--){
        const node = nodes[j];
        let value;
        if ((0, _generated.isIdentifier)(node)) value = node.name;
        else if ((0, _generated.isStringLiteral)(node)) value = node.value;
        else if ((0, _generated.isThisExpression)(node)) value = "this";
        else return false;
        if (parts[i] !== value) return false;
    }
    return true;
}

},{"./generated":"bjDwT"}],"bjDwT":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
exports.isArgumentPlaceholder = isArgumentPlaceholder;
exports.isArrayExpression = isArrayExpression;
exports.isArrayPattern = isArrayPattern;
exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
exports.isArrowFunctionExpression = isArrowFunctionExpression;
exports.isAssignmentExpression = isAssignmentExpression;
exports.isAssignmentPattern = isAssignmentPattern;
exports.isAwaitExpression = isAwaitExpression;
exports.isBigIntLiteral = isBigIntLiteral;
exports.isBinary = isBinary;
exports.isBinaryExpression = isBinaryExpression;
exports.isBindExpression = isBindExpression;
exports.isBlock = isBlock;
exports.isBlockParent = isBlockParent;
exports.isBlockStatement = isBlockStatement;
exports.isBooleanLiteral = isBooleanLiteral;
exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
exports.isBreakStatement = isBreakStatement;
exports.isCallExpression = isCallExpression;
exports.isCatchClause = isCatchClause;
exports.isClass = isClass;
exports.isClassBody = isClassBody;
exports.isClassDeclaration = isClassDeclaration;
exports.isClassExpression = isClassExpression;
exports.isClassImplements = isClassImplements;
exports.isClassMethod = isClassMethod;
exports.isClassPrivateMethod = isClassPrivateMethod;
exports.isClassPrivateProperty = isClassPrivateProperty;
exports.isClassProperty = isClassProperty;
exports.isCompletionStatement = isCompletionStatement;
exports.isConditional = isConditional;
exports.isConditionalExpression = isConditionalExpression;
exports.isContinueStatement = isContinueStatement;
exports.isDebuggerStatement = isDebuggerStatement;
exports.isDecimalLiteral = isDecimalLiteral;
exports.isDeclaration = isDeclaration;
exports.isDeclareClass = isDeclareClass;
exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
exports.isDeclareFunction = isDeclareFunction;
exports.isDeclareInterface = isDeclareInterface;
exports.isDeclareModule = isDeclareModule;
exports.isDeclareModuleExports = isDeclareModuleExports;
exports.isDeclareOpaqueType = isDeclareOpaqueType;
exports.isDeclareTypeAlias = isDeclareTypeAlias;
exports.isDeclareVariable = isDeclareVariable;
exports.isDeclaredPredicate = isDeclaredPredicate;
exports.isDecorator = isDecorator;
exports.isDirective = isDirective;
exports.isDirectiveLiteral = isDirectiveLiteral;
exports.isDoExpression = isDoExpression;
exports.isDoWhileStatement = isDoWhileStatement;
exports.isEmptyStatement = isEmptyStatement;
exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
exports.isEnumBody = isEnumBody;
exports.isEnumBooleanBody = isEnumBooleanBody;
exports.isEnumBooleanMember = isEnumBooleanMember;
exports.isEnumDeclaration = isEnumDeclaration;
exports.isEnumDefaultedMember = isEnumDefaultedMember;
exports.isEnumMember = isEnumMember;
exports.isEnumNumberBody = isEnumNumberBody;
exports.isEnumNumberMember = isEnumNumberMember;
exports.isEnumStringBody = isEnumStringBody;
exports.isEnumStringMember = isEnumStringMember;
exports.isEnumSymbolBody = isEnumSymbolBody;
exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
exports.isExportAllDeclaration = isExportAllDeclaration;
exports.isExportDeclaration = isExportDeclaration;
exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
exports.isExportNamedDeclaration = isExportNamedDeclaration;
exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
exports.isExportSpecifier = isExportSpecifier;
exports.isExpression = isExpression;
exports.isExpressionStatement = isExpressionStatement;
exports.isExpressionWrapper = isExpressionWrapper;
exports.isFile = isFile;
exports.isFlow = isFlow;
exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
exports.isFlowDeclaration = isFlowDeclaration;
exports.isFlowPredicate = isFlowPredicate;
exports.isFlowType = isFlowType;
exports.isFor = isFor;
exports.isForInStatement = isForInStatement;
exports.isForOfStatement = isForOfStatement;
exports.isForStatement = isForStatement;
exports.isForXStatement = isForXStatement;
exports.isFunction = isFunction;
exports.isFunctionDeclaration = isFunctionDeclaration;
exports.isFunctionExpression = isFunctionExpression;
exports.isFunctionParent = isFunctionParent;
exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
exports.isFunctionTypeParam = isFunctionTypeParam;
exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
exports.isIdentifier = isIdentifier;
exports.isIfStatement = isIfStatement;
exports.isImmutable = isImmutable;
exports.isImport = isImport;
exports.isImportAttribute = isImportAttribute;
exports.isImportDeclaration = isImportDeclaration;
exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
exports.isImportSpecifier = isImportSpecifier;
exports.isIndexedAccessType = isIndexedAccessType;
exports.isInferredPredicate = isInferredPredicate;
exports.isInterfaceDeclaration = isInterfaceDeclaration;
exports.isInterfaceExtends = isInterfaceExtends;
exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
exports.isInterpreterDirective = isInterpreterDirective;
exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
exports.isJSX = isJSX;
exports.isJSXAttribute = isJSXAttribute;
exports.isJSXClosingElement = isJSXClosingElement;
exports.isJSXClosingFragment = isJSXClosingFragment;
exports.isJSXElement = isJSXElement;
exports.isJSXEmptyExpression = isJSXEmptyExpression;
exports.isJSXExpressionContainer = isJSXExpressionContainer;
exports.isJSXFragment = isJSXFragment;
exports.isJSXIdentifier = isJSXIdentifier;
exports.isJSXMemberExpression = isJSXMemberExpression;
exports.isJSXNamespacedName = isJSXNamespacedName;
exports.isJSXOpeningElement = isJSXOpeningElement;
exports.isJSXOpeningFragment = isJSXOpeningFragment;
exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
exports.isJSXSpreadChild = isJSXSpreadChild;
exports.isJSXText = isJSXText;
exports.isLVal = isLVal;
exports.isLabeledStatement = isLabeledStatement;
exports.isLiteral = isLiteral;
exports.isLogicalExpression = isLogicalExpression;
exports.isLoop = isLoop;
exports.isMemberExpression = isMemberExpression;
exports.isMetaProperty = isMetaProperty;
exports.isMethod = isMethod;
exports.isMiscellaneous = isMiscellaneous;
exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
exports.isModuleDeclaration = isModuleDeclaration;
exports.isModuleExpression = isModuleExpression;
exports.isModuleSpecifier = isModuleSpecifier;
exports.isNewExpression = isNewExpression;
exports.isNoop = isNoop;
exports.isNullLiteral = isNullLiteral;
exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
exports.isNumberLiteral = isNumberLiteral;
exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
exports.isNumericLiteral = isNumericLiteral;
exports.isObjectExpression = isObjectExpression;
exports.isObjectMember = isObjectMember;
exports.isObjectMethod = isObjectMethod;
exports.isObjectPattern = isObjectPattern;
exports.isObjectProperty = isObjectProperty;
exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
exports.isObjectTypeIndexer = isObjectTypeIndexer;
exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
exports.isObjectTypeProperty = isObjectTypeProperty;
exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
exports.isOpaqueType = isOpaqueType;
exports.isOptionalCallExpression = isOptionalCallExpression;
exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
exports.isOptionalMemberExpression = isOptionalMemberExpression;
exports.isParenthesizedExpression = isParenthesizedExpression;
exports.isPattern = isPattern;
exports.isPatternLike = isPatternLike;
exports.isPipelineBareFunction = isPipelineBareFunction;
exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
exports.isPipelineTopicExpression = isPipelineTopicExpression;
exports.isPlaceholder = isPlaceholder;
exports.isPrivate = isPrivate;
exports.isPrivateName = isPrivateName;
exports.isProgram = isProgram;
exports.isProperty = isProperty;
exports.isPureish = isPureish;
exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
exports.isRecordExpression = isRecordExpression;
exports.isRegExpLiteral = isRegExpLiteral;
exports.isRegexLiteral = isRegexLiteral;
exports.isRestElement = isRestElement;
exports.isRestProperty = isRestProperty;
exports.isReturnStatement = isReturnStatement;
exports.isScopable = isScopable;
exports.isSequenceExpression = isSequenceExpression;
exports.isSpreadElement = isSpreadElement;
exports.isSpreadProperty = isSpreadProperty;
exports.isStandardized = isStandardized;
exports.isStatement = isStatement;
exports.isStaticBlock = isStaticBlock;
exports.isStringLiteral = isStringLiteral;
exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
exports.isStringTypeAnnotation = isStringTypeAnnotation;
exports.isSuper = isSuper;
exports.isSwitchCase = isSwitchCase;
exports.isSwitchStatement = isSwitchStatement;
exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
exports.isTSAnyKeyword = isTSAnyKeyword;
exports.isTSArrayType = isTSArrayType;
exports.isTSAsExpression = isTSAsExpression;
exports.isTSBaseType = isTSBaseType;
exports.isTSBigIntKeyword = isTSBigIntKeyword;
exports.isTSBooleanKeyword = isTSBooleanKeyword;
exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
exports.isTSConditionalType = isTSConditionalType;
exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
exports.isTSConstructorType = isTSConstructorType;
exports.isTSDeclareFunction = isTSDeclareFunction;
exports.isTSDeclareMethod = isTSDeclareMethod;
exports.isTSEntityName = isTSEntityName;
exports.isTSEnumDeclaration = isTSEnumDeclaration;
exports.isTSEnumMember = isTSEnumMember;
exports.isTSExportAssignment = isTSExportAssignment;
exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
exports.isTSExternalModuleReference = isTSExternalModuleReference;
exports.isTSFunctionType = isTSFunctionType;
exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
exports.isTSImportType = isTSImportType;
exports.isTSIndexSignature = isTSIndexSignature;
exports.isTSIndexedAccessType = isTSIndexedAccessType;
exports.isTSInferType = isTSInferType;
exports.isTSInterfaceBody = isTSInterfaceBody;
exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
exports.isTSIntersectionType = isTSIntersectionType;
exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
exports.isTSLiteralType = isTSLiteralType;
exports.isTSMappedType = isTSMappedType;
exports.isTSMethodSignature = isTSMethodSignature;
exports.isTSModuleBlock = isTSModuleBlock;
exports.isTSModuleDeclaration = isTSModuleDeclaration;
exports.isTSNamedTupleMember = isTSNamedTupleMember;
exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
exports.isTSNeverKeyword = isTSNeverKeyword;
exports.isTSNonNullExpression = isTSNonNullExpression;
exports.isTSNullKeyword = isTSNullKeyword;
exports.isTSNumberKeyword = isTSNumberKeyword;
exports.isTSObjectKeyword = isTSObjectKeyword;
exports.isTSOptionalType = isTSOptionalType;
exports.isTSParameterProperty = isTSParameterProperty;
exports.isTSParenthesizedType = isTSParenthesizedType;
exports.isTSPropertySignature = isTSPropertySignature;
exports.isTSQualifiedName = isTSQualifiedName;
exports.isTSRestType = isTSRestType;
exports.isTSStringKeyword = isTSStringKeyword;
exports.isTSSymbolKeyword = isTSSymbolKeyword;
exports.isTSThisType = isTSThisType;
exports.isTSTupleType = isTSTupleType;
exports.isTSType = isTSType;
exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
exports.isTSTypeAnnotation = isTSTypeAnnotation;
exports.isTSTypeAssertion = isTSTypeAssertion;
exports.isTSTypeElement = isTSTypeElement;
exports.isTSTypeLiteral = isTSTypeLiteral;
exports.isTSTypeOperator = isTSTypeOperator;
exports.isTSTypeParameter = isTSTypeParameter;
exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
exports.isTSTypePredicate = isTSTypePredicate;
exports.isTSTypeQuery = isTSTypeQuery;
exports.isTSTypeReference = isTSTypeReference;
exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
exports.isTSUnionType = isTSUnionType;
exports.isTSUnknownKeyword = isTSUnknownKeyword;
exports.isTSVoidKeyword = isTSVoidKeyword;
exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
exports.isTemplateElement = isTemplateElement;
exports.isTemplateLiteral = isTemplateLiteral;
exports.isTerminatorless = isTerminatorless;
exports.isThisExpression = isThisExpression;
exports.isThisTypeAnnotation = isThisTypeAnnotation;
exports.isThrowStatement = isThrowStatement;
exports.isTopicReference = isTopicReference;
exports.isTryStatement = isTryStatement;
exports.isTupleExpression = isTupleExpression;
exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
exports.isTypeAlias = isTypeAlias;
exports.isTypeAnnotation = isTypeAnnotation;
exports.isTypeCastExpression = isTypeCastExpression;
exports.isTypeParameter = isTypeParameter;
exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
exports.isTypeScript = isTypeScript;
exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
exports.isUnaryExpression = isUnaryExpression;
exports.isUnaryLike = isUnaryLike;
exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
exports.isUpdateExpression = isUpdateExpression;
exports.isUserWhitespacable = isUserWhitespacable;
exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
exports.isVariableDeclaration = isVariableDeclaration;
exports.isVariableDeclarator = isVariableDeclarator;
exports.isVariance = isVariance;
exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
exports.isWhile = isWhile;
exports.isWhileStatement = isWhileStatement;
exports.isWithStatement = isWithStatement;
exports.isYieldExpression = isYieldExpression;
var _shallowEqual = require("../../utils/shallowEqual");
function isArrayExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ArrayExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isAssignmentExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "AssignmentExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBinaryExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BinaryExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isInterpreterDirective(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "InterpreterDirective") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDirective(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Directive") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDirectiveLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DirectiveLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBlockStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BlockStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBreakStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BreakStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isCallExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "CallExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isCatchClause(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "CatchClause") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isConditionalExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ConditionalExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isContinueStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ContinueStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDebuggerStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DebuggerStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDoWhileStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DoWhileStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEmptyStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EmptyStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExpressionStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExpressionStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFile(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "File") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isForInStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ForInStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isForStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ForStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFunctionDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "FunctionDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFunctionExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "FunctionExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Identifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isIfStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "IfStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isLabeledStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "LabeledStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isStringLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "StringLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNumericLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NumericLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNullLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NullLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBooleanLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BooleanLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isRegExpLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "RegExpLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isLogicalExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "LogicalExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isMemberExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "MemberExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNewExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NewExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isProgram(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Program") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectMethod") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isRestElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "RestElement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isReturnStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ReturnStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSequenceExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SequenceExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isParenthesizedExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ParenthesizedExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSwitchCase(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SwitchCase") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSwitchStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SwitchStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isThisExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ThisExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isThrowStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ThrowStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTryStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TryStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isUnaryExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "UnaryExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isUpdateExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "UpdateExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isVariableDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "VariableDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isVariableDeclarator(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "VariableDeclarator") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isWhileStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "WhileStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isWithStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "WithStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isAssignmentPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "AssignmentPattern") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isArrayPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ArrayPattern") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isArrowFunctionExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ArrowFunctionExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassBody") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportAllDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportAllDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportDefaultDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportDefaultDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportNamedDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportNamedDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportSpecifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isForOfStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ForOfStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ImportDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImportDefaultSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ImportDefaultSpecifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ImportNamespaceSpecifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImportSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ImportSpecifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isMetaProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "MetaProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassMethod") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectPattern") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSpreadElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SpreadElement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSuper(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Super") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTaggedTemplateExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TaggedTemplateExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTemplateElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TemplateElement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTemplateLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TemplateLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isYieldExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "YieldExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isAwaitExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "AwaitExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImport(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Import") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBigIntLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BigIntLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportNamespaceSpecifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isOptionalMemberExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "OptionalMemberExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isOptionalCallExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "OptionalCallExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassPrivateProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassPrivateProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassPrivateMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassPrivateMethod") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPrivateName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "PrivateName") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isStaticBlock(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "StaticBlock") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isAnyTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "AnyTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isArrayTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ArrayTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBooleanTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BooleanTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBooleanLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BooleanLiteralTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNullLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NullLiteralTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassImplements(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassImplements") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareClass(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareClass") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareFunction") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareInterface(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareInterface") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareModule(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareModule") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareModuleExports(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareModuleExports") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareTypeAlias(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareTypeAlias") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareOpaqueType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareOpaqueType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareVariable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareVariable") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareExportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareExportDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareExportAllDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareExportAllDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclaredPredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclaredPredicate") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExistsTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExistsTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFunctionTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "FunctionTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFunctionTypeParam(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "FunctionTypeParam") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isGenericTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "GenericTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isInferredPredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "InferredPredicate") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isInterfaceExtends(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "InterfaceExtends") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isInterfaceDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "InterfaceDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isInterfaceTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "InterfaceTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isIntersectionTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "IntersectionTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isMixedTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "MixedTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEmptyTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EmptyTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNullableTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NullableTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNumberLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NumberLiteralTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNumberTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NumberTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectTypeInternalSlot(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeInternalSlot") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectTypeCallProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeCallProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectTypeIndexer(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeIndexer") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectTypeProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectTypeSpreadProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeSpreadProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isOpaqueType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "OpaqueType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isQualifiedTypeIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "QualifiedTypeIdentifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isStringLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "StringLiteralTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isStringTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "StringTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSymbolTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SymbolTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isThisTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ThisTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTupleTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TupleTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeofTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeofTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeAlias(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeAlias") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeCastExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeCastExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeParameter(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeParameter") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeParameterDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeParameterInstantiation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isUnionTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "UnionTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isVariance(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Variance") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isVoidTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "VoidTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumBooleanBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumBooleanBody") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumNumberBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumNumberBody") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumStringBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumStringBody") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumSymbolBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumSymbolBody") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumBooleanMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumBooleanMember") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumNumberMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumNumberMember") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumStringMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumStringMember") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumDefaultedMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumDefaultedMember") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isIndexedAccessType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "IndexedAccessType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isOptionalIndexedAccessType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "OptionalIndexedAccessType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXAttribute(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXAttribute") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXClosingElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXClosingElement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXElement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXEmptyExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXEmptyExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXExpressionContainer(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXExpressionContainer") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXSpreadChild(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXSpreadChild") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXIdentifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXMemberExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXMemberExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXNamespacedName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXNamespacedName") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXOpeningElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXOpeningElement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXSpreadAttribute(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXSpreadAttribute") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXText(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXText") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXFragment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXFragment") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXOpeningFragment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXOpeningFragment") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXClosingFragment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXClosingFragment") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNoop(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Noop") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPlaceholder(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Placeholder") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isV8IntrinsicIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "V8IntrinsicIdentifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isArgumentPlaceholder(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ArgumentPlaceholder") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBindExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BindExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImportAttribute(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ImportAttribute") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDecorator(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Decorator") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDoExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DoExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportDefaultSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportDefaultSpecifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isRecordExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "RecordExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTupleExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TupleExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDecimalLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DecimalLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isModuleExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ModuleExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTopicReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TopicReference") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPipelineTopicExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "PipelineTopicExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPipelineBareFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "PipelineBareFunction") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPipelinePrimaryTopicReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "PipelinePrimaryTopicReference") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSParameterProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSParameterProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSDeclareFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSDeclareFunction") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSDeclareMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSDeclareMethod") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSQualifiedName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSQualifiedName") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSCallSignatureDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSCallSignatureDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSConstructSignatureDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSConstructSignatureDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSPropertySignature(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSPropertySignature") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSMethodSignature(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSMethodSignature") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSIndexSignature(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSIndexSignature") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSAnyKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSAnyKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSBooleanKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSBooleanKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSBigIntKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSBigIntKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSIntrinsicKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSIntrinsicKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSNeverKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNeverKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSNullKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNullKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSNumberKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNumberKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSObjectKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSObjectKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSStringKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSStringKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSSymbolKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSSymbolKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSUndefinedKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSUndefinedKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSUnknownKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSUnknownKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSVoidKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSVoidKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSThisType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSThisType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSFunctionType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSFunctionType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSConstructorType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSConstructorType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeReference") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypePredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypePredicate") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeQuery(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeQuery") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSArrayType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSArrayType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTupleType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTupleType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSOptionalType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSOptionalType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSRestType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSRestType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSNamedTupleMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNamedTupleMember") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSUnionType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSUnionType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSIntersectionType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSIntersectionType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSConditionalType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSConditionalType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSInferType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSInferType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSParenthesizedType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSParenthesizedType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeOperator(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeOperator") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSIndexedAccessType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSIndexedAccessType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSMappedType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSMappedType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSLiteralType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSLiteralType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSExpressionWithTypeArguments(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSExpressionWithTypeArguments") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSInterfaceDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSInterfaceDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSInterfaceBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSInterfaceBody") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeAliasDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeAliasDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSAsExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSAsExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeAssertion(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeAssertion") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSEnumDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSEnumDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSEnumMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSEnumMember") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSModuleDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSModuleDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSModuleBlock(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSModuleBlock") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSImportType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSImportType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSImportEqualsDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSImportEqualsDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSExternalModuleReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSExternalModuleReference") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSNonNullExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNonNullExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSExportAssignment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSExportAssignment") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSNamespaceExportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNamespaceExportDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeParameterInstantiation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeParameterDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeParameter(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeParameter") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isStandardized(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "InterpreterDirective" === nodeType || "Directive" === nodeType || "DirectiveLiteral" === nodeType || "BlockStatement" === nodeType || "BreakStatement" === nodeType || "CallExpression" === nodeType || "CatchClause" === nodeType || "ConditionalExpression" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "File" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "Program" === nodeType || "ObjectExpression" === nodeType || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "RestElement" === nodeType || "ReturnStatement" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "SwitchCase" === nodeType || "SwitchStatement" === nodeType || "ThisExpression" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "VariableDeclaration" === nodeType || "VariableDeclarator" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassBody" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ExportSpecifier" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "MetaProperty" === nodeType || "ClassMethod" === nodeType || "ObjectPattern" === nodeType || "SpreadElement" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateElement" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "ExportNamespaceSpecifier" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType || "StaticBlock" === nodeType || nodeType === "Placeholder" && ("Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode || "BlockStatement" === node.expectedNode || "ClassBody" === node.expectedNode)) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "BindExpression" === nodeType || "DoExpression" === nodeType || "RecordExpression" === nodeType || "TupleExpression" === nodeType || "DecimalLiteral" === nodeType || "ModuleExpression" === nodeType || "TopicReference" === nodeType || "PipelineTopicExpression" === nodeType || "PipelineBareFunction" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Expression" === node.expectedNode || "Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode)) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBinary(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isScopable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBlockParent(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBlock(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BlockStatement" === nodeType || "Program" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || nodeType === "Placeholder" && ("Statement" === node.expectedNode || "Declaration" === node.expectedNode || "BlockStatement" === node.expectedNode)) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTerminatorless(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isCompletionStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isConditional(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ConditionalExpression" === nodeType || "IfStatement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isLoop(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isWhile(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExpressionWrapper(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ExpressionStatement" === nodeType || "ParenthesizedExpression" === nodeType || "TypeCastExpression" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFor(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isForXStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ForInStatement" === nodeType || "ForOfStatement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFunctionParent(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPureish(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || nodeType === "Placeholder" && "Declaration" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPatternLike(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isLVal(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSEntityName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("Identifier" === nodeType || "TSQualifiedName" === nodeType || nodeType === "Placeholder" && "Identifier" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImmutable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "BigIntLiteral" === nodeType || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXOpeningElement" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isUserWhitespacable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isUnaryLike(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("UnaryExpression" === nodeType || "SpreadElement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && "Pattern" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClass(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ClassExpression" === nodeType || "ClassDeclaration" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isModuleDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isModuleSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPrivate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFlow(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType || "EnumDeclaration" === nodeType || "EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType || "EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFlowType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFlowBaseAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFlowDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFlowPredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSX(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isMiscellaneous(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("Noop" === nodeType || "Placeholder" === nodeType || "V8IntrinsicIdentifier" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeScript(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("TSParameterProperty" === nodeType || "TSDeclareFunction" === nodeType || "TSDeclareMethod" === nodeType || "TSQualifiedName" === nodeType || "TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSNamedTupleMember" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSInterfaceBody" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSEnumDeclaration" === nodeType || "TSEnumMember" === nodeType || "TSModuleDeclaration" === nodeType || "TSModuleBlock" === nodeType || "TSImportType" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExternalModuleReference" === nodeType || "TSNonNullExpression" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || "TSTypeAnnotation" === nodeType || "TSTypeParameterInstantiation" === nodeType || "TSTypeParameterDeclaration" === nodeType || "TSTypeParameter" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSBaseType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSLiteralType" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNumberLiteral(node, opts) {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NumberLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isRegexLiteral(node, opts) {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "RegexLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isRestProperty(node, opts) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "RestProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSpreadProperty(node, opts) {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SpreadProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}

},{"../../utils/shallowEqual":"9y7Dh"}],"9y7Dh":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = shallowEqual;
function shallowEqual(actual, expected) {
    const keys = Object.keys(expected);
    for (const key of keys){
        if (actual[key] !== expected[key]) return false;
    }
    return true;
}

},{}],"8F123":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isCompatTag;
function isCompatTag(tagName) {
    return !!tagName && /^[a-z]/.test(tagName);
}

},{}],"i1W4S":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = buildChildren;
var _generated = require("../../validators/generated");
var _cleanJSXElementLiteralChild = require("../../utils/react/cleanJSXElementLiteralChild");
function buildChildren(node) {
    const elements = [];
    for(let i = 0; i < node.children.length; i++){
        let child = node.children[i];
        if ((0, _generated.isJSXText)(child)) {
            (0, _cleanJSXElementLiteralChild.default)(child, elements);
            continue;
        }
        if ((0, _generated.isJSXExpressionContainer)(child)) child = child.expression;
        if ((0, _generated.isJSXEmptyExpression)(child)) continue;
        elements.push(child);
    }
    return elements;
}

},{"../../validators/generated":"bjDwT","../../utils/react/cleanJSXElementLiteralChild":"7fn74"}],"7fn74":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cleanJSXElementLiteralChild;
var _generated = require("../../builders/generated");
function cleanJSXElementLiteralChild(child, args) {
    const lines = child.value.split(/\r\n|\n|\r/);
    let lastNonEmptyLine = 0;
    for(let i = 0; i < lines.length; i++)if (lines[i].match(/[^ \t]/)) lastNonEmptyLine = i;
    let str = "";
    for(let i1 = 0; i1 < lines.length; i1++){
        const line = lines[i1];
        const isFirstLine = i1 === 0;
        const isLastLine = i1 === lines.length - 1;
        const isLastNonEmptyLine = i1 === lastNonEmptyLine;
        let trimmedLine = line.replace(/\t/g, " ");
        if (!isFirstLine) trimmedLine = trimmedLine.replace(/^[ ]+/, "");
        if (!isLastLine) trimmedLine = trimmedLine.replace(/[ ]+$/, "");
        if (trimmedLine) {
            if (!isLastNonEmptyLine) trimmedLine += " ";
            str += trimmedLine;
        }
    }
    if (str) args.push((0, _generated.stringLiteral)(str));
}

},{"../../builders/generated":"1t4GT"}],"1t4GT":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.anyTypeAnnotation = anyTypeAnnotation;
exports.argumentPlaceholder = argumentPlaceholder;
exports.arrayExpression = arrayExpression;
exports.arrayPattern = arrayPattern;
exports.arrayTypeAnnotation = arrayTypeAnnotation;
exports.arrowFunctionExpression = arrowFunctionExpression;
exports.assignmentExpression = assignmentExpression;
exports.assignmentPattern = assignmentPattern;
exports.awaitExpression = awaitExpression;
exports.bigIntLiteral = bigIntLiteral;
exports.binaryExpression = binaryExpression;
exports.bindExpression = bindExpression;
exports.blockStatement = blockStatement;
exports.booleanLiteral = booleanLiteral;
exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
exports.booleanTypeAnnotation = booleanTypeAnnotation;
exports.breakStatement = breakStatement;
exports.callExpression = callExpression;
exports.catchClause = catchClause;
exports.classBody = classBody;
exports.classDeclaration = classDeclaration;
exports.classExpression = classExpression;
exports.classImplements = classImplements;
exports.classMethod = classMethod;
exports.classPrivateMethod = classPrivateMethod;
exports.classPrivateProperty = classPrivateProperty;
exports.classProperty = classProperty;
exports.conditionalExpression = conditionalExpression;
exports.continueStatement = continueStatement;
exports.debuggerStatement = debuggerStatement;
exports.decimalLiteral = decimalLiteral;
exports.declareClass = declareClass;
exports.declareExportAllDeclaration = declareExportAllDeclaration;
exports.declareExportDeclaration = declareExportDeclaration;
exports.declareFunction = declareFunction;
exports.declareInterface = declareInterface;
exports.declareModule = declareModule;
exports.declareModuleExports = declareModuleExports;
exports.declareOpaqueType = declareOpaqueType;
exports.declareTypeAlias = declareTypeAlias;
exports.declareVariable = declareVariable;
exports.declaredPredicate = declaredPredicate;
exports.decorator = decorator;
exports.directive = directive;
exports.directiveLiteral = directiveLiteral;
exports.doExpression = doExpression;
exports.doWhileStatement = doWhileStatement;
exports.emptyStatement = emptyStatement;
exports.emptyTypeAnnotation = emptyTypeAnnotation;
exports.enumBooleanBody = enumBooleanBody;
exports.enumBooleanMember = enumBooleanMember;
exports.enumDeclaration = enumDeclaration;
exports.enumDefaultedMember = enumDefaultedMember;
exports.enumNumberBody = enumNumberBody;
exports.enumNumberMember = enumNumberMember;
exports.enumStringBody = enumStringBody;
exports.enumStringMember = enumStringMember;
exports.enumSymbolBody = enumSymbolBody;
exports.existsTypeAnnotation = existsTypeAnnotation;
exports.exportAllDeclaration = exportAllDeclaration;
exports.exportDefaultDeclaration = exportDefaultDeclaration;
exports.exportDefaultSpecifier = exportDefaultSpecifier;
exports.exportNamedDeclaration = exportNamedDeclaration;
exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
exports.exportSpecifier = exportSpecifier;
exports.expressionStatement = expressionStatement;
exports.file = file;
exports.forInStatement = forInStatement;
exports.forOfStatement = forOfStatement;
exports.forStatement = forStatement;
exports.functionDeclaration = functionDeclaration;
exports.functionExpression = functionExpression;
exports.functionTypeAnnotation = functionTypeAnnotation;
exports.functionTypeParam = functionTypeParam;
exports.genericTypeAnnotation = genericTypeAnnotation;
exports.identifier = identifier;
exports.ifStatement = ifStatement;
exports.import = _import;
exports.importAttribute = importAttribute;
exports.importDeclaration = importDeclaration;
exports.importDefaultSpecifier = importDefaultSpecifier;
exports.importNamespaceSpecifier = importNamespaceSpecifier;
exports.importSpecifier = importSpecifier;
exports.indexedAccessType = indexedAccessType;
exports.inferredPredicate = inferredPredicate;
exports.interfaceDeclaration = interfaceDeclaration;
exports.interfaceExtends = interfaceExtends;
exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
exports.interpreterDirective = interpreterDirective;
exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
exports.jSXElement = exports.jsxElement = jsxElement;
exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
exports.jSXFragment = exports.jsxFragment = jsxFragment;
exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
exports.jSXText = exports.jsxText = jsxText;
exports.labeledStatement = labeledStatement;
exports.logicalExpression = logicalExpression;
exports.memberExpression = memberExpression;
exports.metaProperty = metaProperty;
exports.mixedTypeAnnotation = mixedTypeAnnotation;
exports.moduleExpression = moduleExpression;
exports.newExpression = newExpression;
exports.noop = noop;
exports.nullLiteral = nullLiteral;
exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
exports.nullableTypeAnnotation = nullableTypeAnnotation;
exports.numberLiteral = NumberLiteral;
exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
exports.numberTypeAnnotation = numberTypeAnnotation;
exports.numericLiteral = numericLiteral;
exports.objectExpression = objectExpression;
exports.objectMethod = objectMethod;
exports.objectPattern = objectPattern;
exports.objectProperty = objectProperty;
exports.objectTypeAnnotation = objectTypeAnnotation;
exports.objectTypeCallProperty = objectTypeCallProperty;
exports.objectTypeIndexer = objectTypeIndexer;
exports.objectTypeInternalSlot = objectTypeInternalSlot;
exports.objectTypeProperty = objectTypeProperty;
exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
exports.opaqueType = opaqueType;
exports.optionalCallExpression = optionalCallExpression;
exports.optionalIndexedAccessType = optionalIndexedAccessType;
exports.optionalMemberExpression = optionalMemberExpression;
exports.parenthesizedExpression = parenthesizedExpression;
exports.pipelineBareFunction = pipelineBareFunction;
exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
exports.pipelineTopicExpression = pipelineTopicExpression;
exports.placeholder = placeholder;
exports.privateName = privateName;
exports.program = program;
exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
exports.recordExpression = recordExpression;
exports.regExpLiteral = regExpLiteral;
exports.regexLiteral = RegexLiteral;
exports.restElement = restElement;
exports.restProperty = RestProperty;
exports.returnStatement = returnStatement;
exports.sequenceExpression = sequenceExpression;
exports.spreadElement = spreadElement;
exports.spreadProperty = SpreadProperty;
exports.staticBlock = staticBlock;
exports.stringLiteral = stringLiteral;
exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
exports.stringTypeAnnotation = stringTypeAnnotation;
exports.super = _super;
exports.switchCase = switchCase;
exports.switchStatement = switchStatement;
exports.symbolTypeAnnotation = symbolTypeAnnotation;
exports.taggedTemplateExpression = taggedTemplateExpression;
exports.templateElement = templateElement;
exports.templateLiteral = templateLiteral;
exports.thisExpression = thisExpression;
exports.thisTypeAnnotation = thisTypeAnnotation;
exports.throwStatement = throwStatement;
exports.topicReference = topicReference;
exports.tryStatement = tryStatement;
exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
exports.tSArrayType = exports.tsArrayType = tsArrayType;
exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
exports.tSImportType = exports.tsImportType = tsImportType;
exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
exports.tSInferType = exports.tsInferType = tsInferType;
exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
exports.tSMappedType = exports.tsMappedType = tsMappedType;
exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
exports.tSRestType = exports.tsRestType = tsRestType;
exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
exports.tSThisType = exports.tsThisType = tsThisType;
exports.tSTupleType = exports.tsTupleType = tsTupleType;
exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
exports.tSUnionType = exports.tsUnionType = tsUnionType;
exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
exports.tupleExpression = tupleExpression;
exports.tupleTypeAnnotation = tupleTypeAnnotation;
exports.typeAlias = typeAlias;
exports.typeAnnotation = typeAnnotation;
exports.typeCastExpression = typeCastExpression;
exports.typeParameter = typeParameter;
exports.typeParameterDeclaration = typeParameterDeclaration;
exports.typeParameterInstantiation = typeParameterInstantiation;
exports.typeofTypeAnnotation = typeofTypeAnnotation;
exports.unaryExpression = unaryExpression;
exports.unionTypeAnnotation = unionTypeAnnotation;
exports.updateExpression = updateExpression;
exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
exports.variableDeclaration = variableDeclaration;
exports.variableDeclarator = variableDeclarator;
exports.variance = variance;
exports.voidTypeAnnotation = voidTypeAnnotation;
exports.whileStatement = whileStatement;
exports.withStatement = withStatement;
exports.yieldExpression = yieldExpression;
var _builder = require("../builder");
function arrayExpression(elements) {
    return _builder.default.apply("ArrayExpression", arguments);
}
function assignmentExpression(operator, left, right) {
    return _builder.default.apply("AssignmentExpression", arguments);
}
function binaryExpression(operator, left, right) {
    return _builder.default.apply("BinaryExpression", arguments);
}
function interpreterDirective(value) {
    return _builder.default.apply("InterpreterDirective", arguments);
}
function directive(value) {
    return _builder.default.apply("Directive", arguments);
}
function directiveLiteral(value) {
    return _builder.default.apply("DirectiveLiteral", arguments);
}
function blockStatement(body, directives) {
    return _builder.default.apply("BlockStatement", arguments);
}
function breakStatement(label) {
    return _builder.default.apply("BreakStatement", arguments);
}
function callExpression(callee, _arguments) {
    return _builder.default.apply("CallExpression", arguments);
}
function catchClause(param, body) {
    return _builder.default.apply("CatchClause", arguments);
}
function conditionalExpression(test, consequent, alternate) {
    return _builder.default.apply("ConditionalExpression", arguments);
}
function continueStatement(label) {
    return _builder.default.apply("ContinueStatement", arguments);
}
function debuggerStatement() {
    return _builder.default.apply("DebuggerStatement", arguments);
}
function doWhileStatement(test, body) {
    return _builder.default.apply("DoWhileStatement", arguments);
}
function emptyStatement() {
    return _builder.default.apply("EmptyStatement", arguments);
}
function expressionStatement(expression) {
    return _builder.default.apply("ExpressionStatement", arguments);
}
function file(program, comments, tokens) {
    return _builder.default.apply("File", arguments);
}
function forInStatement(left, right, body) {
    return _builder.default.apply("ForInStatement", arguments);
}
function forStatement(init, test, update, body) {
    return _builder.default.apply("ForStatement", arguments);
}
function functionDeclaration(id, params, body, generator, async) {
    return _builder.default.apply("FunctionDeclaration", arguments);
}
function functionExpression(id, params, body, generator, async) {
    return _builder.default.apply("FunctionExpression", arguments);
}
function identifier(name) {
    return _builder.default.apply("Identifier", arguments);
}
function ifStatement(test, consequent, alternate) {
    return _builder.default.apply("IfStatement", arguments);
}
function labeledStatement(label, body) {
    return _builder.default.apply("LabeledStatement", arguments);
}
function stringLiteral(value) {
    return _builder.default.apply("StringLiteral", arguments);
}
function numericLiteral(value) {
    return _builder.default.apply("NumericLiteral", arguments);
}
function nullLiteral() {
    return _builder.default.apply("NullLiteral", arguments);
}
function booleanLiteral(value) {
    return _builder.default.apply("BooleanLiteral", arguments);
}
function regExpLiteral(pattern, flags) {
    return _builder.default.apply("RegExpLiteral", arguments);
}
function logicalExpression(operator, left, right) {
    return _builder.default.apply("LogicalExpression", arguments);
}
function memberExpression(object, property, computed, optional) {
    return _builder.default.apply("MemberExpression", arguments);
}
function newExpression(callee, _arguments) {
    return _builder.default.apply("NewExpression", arguments);
}
function program(body, directives, sourceType, interpreter) {
    return _builder.default.apply("Program", arguments);
}
function objectExpression(properties) {
    return _builder.default.apply("ObjectExpression", arguments);
}
function objectMethod(kind, key, params, body, computed, generator, async) {
    return _builder.default.apply("ObjectMethod", arguments);
}
function objectProperty(key, value, computed, shorthand, decorators) {
    return _builder.default.apply("ObjectProperty", arguments);
}
function restElement(argument) {
    return _builder.default.apply("RestElement", arguments);
}
function returnStatement(argument) {
    return _builder.default.apply("ReturnStatement", arguments);
}
function sequenceExpression(expressions) {
    return _builder.default.apply("SequenceExpression", arguments);
}
function parenthesizedExpression(expression) {
    return _builder.default.apply("ParenthesizedExpression", arguments);
}
function switchCase(test, consequent) {
    return _builder.default.apply("SwitchCase", arguments);
}
function switchStatement(discriminant, cases) {
    return _builder.default.apply("SwitchStatement", arguments);
}
function thisExpression() {
    return _builder.default.apply("ThisExpression", arguments);
}
function throwStatement(argument) {
    return _builder.default.apply("ThrowStatement", arguments);
}
function tryStatement(block, handler, finalizer) {
    return _builder.default.apply("TryStatement", arguments);
}
function unaryExpression(operator, argument, prefix) {
    return _builder.default.apply("UnaryExpression", arguments);
}
function updateExpression(operator, argument, prefix) {
    return _builder.default.apply("UpdateExpression", arguments);
}
function variableDeclaration(kind, declarations) {
    return _builder.default.apply("VariableDeclaration", arguments);
}
function variableDeclarator(id, init) {
    return _builder.default.apply("VariableDeclarator", arguments);
}
function whileStatement(test, body) {
    return _builder.default.apply("WhileStatement", arguments);
}
function withStatement(object, body) {
    return _builder.default.apply("WithStatement", arguments);
}
function assignmentPattern(left, right) {
    return _builder.default.apply("AssignmentPattern", arguments);
}
function arrayPattern(elements) {
    return _builder.default.apply("ArrayPattern", arguments);
}
function arrowFunctionExpression(params, body, async) {
    return _builder.default.apply("ArrowFunctionExpression", arguments);
}
function classBody(body) {
    return _builder.default.apply("ClassBody", arguments);
}
function classExpression(id, superClass, body, decorators) {
    return _builder.default.apply("ClassExpression", arguments);
}
function classDeclaration(id, superClass, body, decorators) {
    return _builder.default.apply("ClassDeclaration", arguments);
}
function exportAllDeclaration(source) {
    return _builder.default.apply("ExportAllDeclaration", arguments);
}
function exportDefaultDeclaration(declaration) {
    return _builder.default.apply("ExportDefaultDeclaration", arguments);
}
function exportNamedDeclaration(declaration, specifiers, source) {
    return _builder.default.apply("ExportNamedDeclaration", arguments);
}
function exportSpecifier(local, exported) {
    return _builder.default.apply("ExportSpecifier", arguments);
}
function forOfStatement(left, right, body, _await) {
    return _builder.default.apply("ForOfStatement", arguments);
}
function importDeclaration(specifiers, source) {
    return _builder.default.apply("ImportDeclaration", arguments);
}
function importDefaultSpecifier(local) {
    return _builder.default.apply("ImportDefaultSpecifier", arguments);
}
function importNamespaceSpecifier(local) {
    return _builder.default.apply("ImportNamespaceSpecifier", arguments);
}
function importSpecifier(local, imported) {
    return _builder.default.apply("ImportSpecifier", arguments);
}
function metaProperty(meta, property) {
    return _builder.default.apply("MetaProperty", arguments);
}
function classMethod(kind, key, params, body, computed, _static, generator, async) {
    return _builder.default.apply("ClassMethod", arguments);
}
function objectPattern(properties) {
    return _builder.default.apply("ObjectPattern", arguments);
}
function spreadElement(argument) {
    return _builder.default.apply("SpreadElement", arguments);
}
function _super() {
    return _builder.default.apply("Super", arguments);
}
function taggedTemplateExpression(tag, quasi) {
    return _builder.default.apply("TaggedTemplateExpression", arguments);
}
function templateElement(value, tail) {
    return _builder.default.apply("TemplateElement", arguments);
}
function templateLiteral(quasis, expressions) {
    return _builder.default.apply("TemplateLiteral", arguments);
}
function yieldExpression(argument, delegate) {
    return _builder.default.apply("YieldExpression", arguments);
}
function awaitExpression(argument) {
    return _builder.default.apply("AwaitExpression", arguments);
}
function _import() {
    return _builder.default.apply("Import", arguments);
}
function bigIntLiteral(value) {
    return _builder.default.apply("BigIntLiteral", arguments);
}
function exportNamespaceSpecifier(exported) {
    return _builder.default.apply("ExportNamespaceSpecifier", arguments);
}
function optionalMemberExpression(object, property, computed, optional) {
    return _builder.default.apply("OptionalMemberExpression", arguments);
}
function optionalCallExpression(callee, _arguments, optional) {
    return _builder.default.apply("OptionalCallExpression", arguments);
}
function classProperty(key, value, typeAnnotation, decorators, computed, _static) {
    return _builder.default.apply("ClassProperty", arguments);
}
function classPrivateProperty(key, value, decorators, _static) {
    return _builder.default.apply("ClassPrivateProperty", arguments);
}
function classPrivateMethod(kind, key, params, body, _static) {
    return _builder.default.apply("ClassPrivateMethod", arguments);
}
function privateName(id) {
    return _builder.default.apply("PrivateName", arguments);
}
function staticBlock(body) {
    return _builder.default.apply("StaticBlock", arguments);
}
function anyTypeAnnotation() {
    return _builder.default.apply("AnyTypeAnnotation", arguments);
}
function arrayTypeAnnotation(elementType) {
    return _builder.default.apply("ArrayTypeAnnotation", arguments);
}
function booleanTypeAnnotation() {
    return _builder.default.apply("BooleanTypeAnnotation", arguments);
}
function booleanLiteralTypeAnnotation(value) {
    return _builder.default.apply("BooleanLiteralTypeAnnotation", arguments);
}
function nullLiteralTypeAnnotation() {
    return _builder.default.apply("NullLiteralTypeAnnotation", arguments);
}
function classImplements(id, typeParameters) {
    return _builder.default.apply("ClassImplements", arguments);
}
function declareClass(id, typeParameters, _extends, body) {
    return _builder.default.apply("DeclareClass", arguments);
}
function declareFunction(id) {
    return _builder.default.apply("DeclareFunction", arguments);
}
function declareInterface(id, typeParameters, _extends, body) {
    return _builder.default.apply("DeclareInterface", arguments);
}
function declareModule(id, body, kind) {
    return _builder.default.apply("DeclareModule", arguments);
}
function declareModuleExports(typeAnnotation) {
    return _builder.default.apply("DeclareModuleExports", arguments);
}
function declareTypeAlias(id, typeParameters, right) {
    return _builder.default.apply("DeclareTypeAlias", arguments);
}
function declareOpaqueType(id, typeParameters, supertype) {
    return _builder.default.apply("DeclareOpaqueType", arguments);
}
function declareVariable(id) {
    return _builder.default.apply("DeclareVariable", arguments);
}
function declareExportDeclaration(declaration, specifiers, source) {
    return _builder.default.apply("DeclareExportDeclaration", arguments);
}
function declareExportAllDeclaration(source) {
    return _builder.default.apply("DeclareExportAllDeclaration", arguments);
}
function declaredPredicate(value) {
    return _builder.default.apply("DeclaredPredicate", arguments);
}
function existsTypeAnnotation() {
    return _builder.default.apply("ExistsTypeAnnotation", arguments);
}
function functionTypeAnnotation(typeParameters, params, rest, returnType) {
    return _builder.default.apply("FunctionTypeAnnotation", arguments);
}
function functionTypeParam(name, typeAnnotation) {
    return _builder.default.apply("FunctionTypeParam", arguments);
}
function genericTypeAnnotation(id, typeParameters) {
    return _builder.default.apply("GenericTypeAnnotation", arguments);
}
function inferredPredicate() {
    return _builder.default.apply("InferredPredicate", arguments);
}
function interfaceExtends(id, typeParameters) {
    return _builder.default.apply("InterfaceExtends", arguments);
}
function interfaceDeclaration(id, typeParameters, _extends, body) {
    return _builder.default.apply("InterfaceDeclaration", arguments);
}
function interfaceTypeAnnotation(_extends, body) {
    return _builder.default.apply("InterfaceTypeAnnotation", arguments);
}
function intersectionTypeAnnotation(types) {
    return _builder.default.apply("IntersectionTypeAnnotation", arguments);
}
function mixedTypeAnnotation() {
    return _builder.default.apply("MixedTypeAnnotation", arguments);
}
function emptyTypeAnnotation() {
    return _builder.default.apply("EmptyTypeAnnotation", arguments);
}
function nullableTypeAnnotation(typeAnnotation) {
    return _builder.default.apply("NullableTypeAnnotation", arguments);
}
function numberLiteralTypeAnnotation(value) {
    return _builder.default.apply("NumberLiteralTypeAnnotation", arguments);
}
function numberTypeAnnotation() {
    return _builder.default.apply("NumberTypeAnnotation", arguments);
}
function objectTypeAnnotation(properties, indexers, callProperties, internalSlots, exact) {
    return _builder.default.apply("ObjectTypeAnnotation", arguments);
}
function objectTypeInternalSlot(id, value, optional, _static, method) {
    return _builder.default.apply("ObjectTypeInternalSlot", arguments);
}
function objectTypeCallProperty(value) {
    return _builder.default.apply("ObjectTypeCallProperty", arguments);
}
function objectTypeIndexer(id, key, value, variance) {
    return _builder.default.apply("ObjectTypeIndexer", arguments);
}
function objectTypeProperty(key, value, variance) {
    return _builder.default.apply("ObjectTypeProperty", arguments);
}
function objectTypeSpreadProperty(argument) {
    return _builder.default.apply("ObjectTypeSpreadProperty", arguments);
}
function opaqueType(id, typeParameters, supertype, impltype) {
    return _builder.default.apply("OpaqueType", arguments);
}
function qualifiedTypeIdentifier(id, qualification) {
    return _builder.default.apply("QualifiedTypeIdentifier", arguments);
}
function stringLiteralTypeAnnotation(value) {
    return _builder.default.apply("StringLiteralTypeAnnotation", arguments);
}
function stringTypeAnnotation() {
    return _builder.default.apply("StringTypeAnnotation", arguments);
}
function symbolTypeAnnotation() {
    return _builder.default.apply("SymbolTypeAnnotation", arguments);
}
function thisTypeAnnotation() {
    return _builder.default.apply("ThisTypeAnnotation", arguments);
}
function tupleTypeAnnotation(types) {
    return _builder.default.apply("TupleTypeAnnotation", arguments);
}
function typeofTypeAnnotation(argument) {
    return _builder.default.apply("TypeofTypeAnnotation", arguments);
}
function typeAlias(id, typeParameters, right) {
    return _builder.default.apply("TypeAlias", arguments);
}
function typeAnnotation(typeAnnotation) {
    return _builder.default.apply("TypeAnnotation", arguments);
}
function typeCastExpression(expression, typeAnnotation) {
    return _builder.default.apply("TypeCastExpression", arguments);
}
function typeParameter(bound, _default, variance) {
    return _builder.default.apply("TypeParameter", arguments);
}
function typeParameterDeclaration(params) {
    return _builder.default.apply("TypeParameterDeclaration", arguments);
}
function typeParameterInstantiation(params) {
    return _builder.default.apply("TypeParameterInstantiation", arguments);
}
function unionTypeAnnotation(types) {
    return _builder.default.apply("UnionTypeAnnotation", arguments);
}
function variance(kind) {
    return _builder.default.apply("Variance", arguments);
}
function voidTypeAnnotation() {
    return _builder.default.apply("VoidTypeAnnotation", arguments);
}
function enumDeclaration(id, body) {
    return _builder.default.apply("EnumDeclaration", arguments);
}
function enumBooleanBody(members) {
    return _builder.default.apply("EnumBooleanBody", arguments);
}
function enumNumberBody(members) {
    return _builder.default.apply("EnumNumberBody", arguments);
}
function enumStringBody(members) {
    return _builder.default.apply("EnumStringBody", arguments);
}
function enumSymbolBody(members) {
    return _builder.default.apply("EnumSymbolBody", arguments);
}
function enumBooleanMember(id) {
    return _builder.default.apply("EnumBooleanMember", arguments);
}
function enumNumberMember(id, init) {
    return _builder.default.apply("EnumNumberMember", arguments);
}
function enumStringMember(id, init) {
    return _builder.default.apply("EnumStringMember", arguments);
}
function enumDefaultedMember(id) {
    return _builder.default.apply("EnumDefaultedMember", arguments);
}
function indexedAccessType(objectType, indexType) {
    return _builder.default.apply("IndexedAccessType", arguments);
}
function optionalIndexedAccessType(objectType, indexType) {
    return _builder.default.apply("OptionalIndexedAccessType", arguments);
}
function jsxAttribute(name, value) {
    return _builder.default.apply("JSXAttribute", arguments);
}
function jsxClosingElement(name) {
    return _builder.default.apply("JSXClosingElement", arguments);
}
function jsxElement(openingElement, closingElement, children, selfClosing) {
    return _builder.default.apply("JSXElement", arguments);
}
function jsxEmptyExpression() {
    return _builder.default.apply("JSXEmptyExpression", arguments);
}
function jsxExpressionContainer(expression) {
    return _builder.default.apply("JSXExpressionContainer", arguments);
}
function jsxSpreadChild(expression) {
    return _builder.default.apply("JSXSpreadChild", arguments);
}
function jsxIdentifier(name) {
    return _builder.default.apply("JSXIdentifier", arguments);
}
function jsxMemberExpression(object, property) {
    return _builder.default.apply("JSXMemberExpression", arguments);
}
function jsxNamespacedName(namespace, name) {
    return _builder.default.apply("JSXNamespacedName", arguments);
}
function jsxOpeningElement(name, attributes, selfClosing) {
    return _builder.default.apply("JSXOpeningElement", arguments);
}
function jsxSpreadAttribute(argument) {
    return _builder.default.apply("JSXSpreadAttribute", arguments);
}
function jsxText(value) {
    return _builder.default.apply("JSXText", arguments);
}
function jsxFragment(openingFragment, closingFragment, children) {
    return _builder.default.apply("JSXFragment", arguments);
}
function jsxOpeningFragment() {
    return _builder.default.apply("JSXOpeningFragment", arguments);
}
function jsxClosingFragment() {
    return _builder.default.apply("JSXClosingFragment", arguments);
}
function noop() {
    return _builder.default.apply("Noop", arguments);
}
function placeholder(expectedNode, name) {
    return _builder.default.apply("Placeholder", arguments);
}
function v8IntrinsicIdentifier(name) {
    return _builder.default.apply("V8IntrinsicIdentifier", arguments);
}
function argumentPlaceholder() {
    return _builder.default.apply("ArgumentPlaceholder", arguments);
}
function bindExpression(object, callee) {
    return _builder.default.apply("BindExpression", arguments);
}
function importAttribute(key, value) {
    return _builder.default.apply("ImportAttribute", arguments);
}
function decorator(expression) {
    return _builder.default.apply("Decorator", arguments);
}
function doExpression(body, async) {
    return _builder.default.apply("DoExpression", arguments);
}
function exportDefaultSpecifier(exported) {
    return _builder.default.apply("ExportDefaultSpecifier", arguments);
}
function recordExpression(properties) {
    return _builder.default.apply("RecordExpression", arguments);
}
function tupleExpression(elements) {
    return _builder.default.apply("TupleExpression", arguments);
}
function decimalLiteral(value) {
    return _builder.default.apply("DecimalLiteral", arguments);
}
function moduleExpression(body) {
    return _builder.default.apply("ModuleExpression", arguments);
}
function topicReference() {
    return _builder.default.apply("TopicReference", arguments);
}
function pipelineTopicExpression(expression) {
    return _builder.default.apply("PipelineTopicExpression", arguments);
}
function pipelineBareFunction(callee) {
    return _builder.default.apply("PipelineBareFunction", arguments);
}
function pipelinePrimaryTopicReference() {
    return _builder.default.apply("PipelinePrimaryTopicReference", arguments);
}
function tsParameterProperty(parameter) {
    return _builder.default.apply("TSParameterProperty", arguments);
}
function tsDeclareFunction(id, typeParameters, params, returnType) {
    return _builder.default.apply("TSDeclareFunction", arguments);
}
function tsDeclareMethod(decorators, key, typeParameters, params, returnType) {
    return _builder.default.apply("TSDeclareMethod", arguments);
}
function tsQualifiedName(left, right) {
    return _builder.default.apply("TSQualifiedName", arguments);
}
function tsCallSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
    return _builder.default.apply("TSCallSignatureDeclaration", arguments);
}
function tsConstructSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
    return _builder.default.apply("TSConstructSignatureDeclaration", arguments);
}
function tsPropertySignature(key, typeAnnotation, initializer) {
    return _builder.default.apply("TSPropertySignature", arguments);
}
function tsMethodSignature(key, typeParameters, parameters, typeAnnotation) {
    return _builder.default.apply("TSMethodSignature", arguments);
}
function tsIndexSignature(parameters, typeAnnotation) {
    return _builder.default.apply("TSIndexSignature", arguments);
}
function tsAnyKeyword() {
    return _builder.default.apply("TSAnyKeyword", arguments);
}
function tsBooleanKeyword() {
    return _builder.default.apply("TSBooleanKeyword", arguments);
}
function tsBigIntKeyword() {
    return _builder.default.apply("TSBigIntKeyword", arguments);
}
function tsIntrinsicKeyword() {
    return _builder.default.apply("TSIntrinsicKeyword", arguments);
}
function tsNeverKeyword() {
    return _builder.default.apply("TSNeverKeyword", arguments);
}
function tsNullKeyword() {
    return _builder.default.apply("TSNullKeyword", arguments);
}
function tsNumberKeyword() {
    return _builder.default.apply("TSNumberKeyword", arguments);
}
function tsObjectKeyword() {
    return _builder.default.apply("TSObjectKeyword", arguments);
}
function tsStringKeyword() {
    return _builder.default.apply("TSStringKeyword", arguments);
}
function tsSymbolKeyword() {
    return _builder.default.apply("TSSymbolKeyword", arguments);
}
function tsUndefinedKeyword() {
    return _builder.default.apply("TSUndefinedKeyword", arguments);
}
function tsUnknownKeyword() {
    return _builder.default.apply("TSUnknownKeyword", arguments);
}
function tsVoidKeyword() {
    return _builder.default.apply("TSVoidKeyword", arguments);
}
function tsThisType() {
    return _builder.default.apply("TSThisType", arguments);
}
function tsFunctionType(typeParameters, parameters, typeAnnotation) {
    return _builder.default.apply("TSFunctionType", arguments);
}
function tsConstructorType(typeParameters, parameters, typeAnnotation) {
    return _builder.default.apply("TSConstructorType", arguments);
}
function tsTypeReference(typeName, typeParameters) {
    return _builder.default.apply("TSTypeReference", arguments);
}
function tsTypePredicate(parameterName, typeAnnotation, asserts) {
    return _builder.default.apply("TSTypePredicate", arguments);
}
function tsTypeQuery(exprName) {
    return _builder.default.apply("TSTypeQuery", arguments);
}
function tsTypeLiteral(members) {
    return _builder.default.apply("TSTypeLiteral", arguments);
}
function tsArrayType(elementType) {
    return _builder.default.apply("TSArrayType", arguments);
}
function tsTupleType(elementTypes) {
    return _builder.default.apply("TSTupleType", arguments);
}
function tsOptionalType(typeAnnotation) {
    return _builder.default.apply("TSOptionalType", arguments);
}
function tsRestType(typeAnnotation) {
    return _builder.default.apply("TSRestType", arguments);
}
function tsNamedTupleMember(label, elementType, optional) {
    return _builder.default.apply("TSNamedTupleMember", arguments);
}
function tsUnionType(types) {
    return _builder.default.apply("TSUnionType", arguments);
}
function tsIntersectionType(types) {
    return _builder.default.apply("TSIntersectionType", arguments);
}
function tsConditionalType(checkType, extendsType, trueType, falseType) {
    return _builder.default.apply("TSConditionalType", arguments);
}
function tsInferType(typeParameter) {
    return _builder.default.apply("TSInferType", arguments);
}
function tsParenthesizedType(typeAnnotation) {
    return _builder.default.apply("TSParenthesizedType", arguments);
}
function tsTypeOperator(typeAnnotation) {
    return _builder.default.apply("TSTypeOperator", arguments);
}
function tsIndexedAccessType(objectType, indexType) {
    return _builder.default.apply("TSIndexedAccessType", arguments);
}
function tsMappedType(typeParameter, typeAnnotation, nameType) {
    return _builder.default.apply("TSMappedType", arguments);
}
function tsLiteralType(literal) {
    return _builder.default.apply("TSLiteralType", arguments);
}
function tsExpressionWithTypeArguments(expression, typeParameters) {
    return _builder.default.apply("TSExpressionWithTypeArguments", arguments);
}
function tsInterfaceDeclaration(id, typeParameters, _extends, body) {
    return _builder.default.apply("TSInterfaceDeclaration", arguments);
}
function tsInterfaceBody(body) {
    return _builder.default.apply("TSInterfaceBody", arguments);
}
function tsTypeAliasDeclaration(id, typeParameters, typeAnnotation) {
    return _builder.default.apply("TSTypeAliasDeclaration", arguments);
}
function tsAsExpression(expression, typeAnnotation) {
    return _builder.default.apply("TSAsExpression", arguments);
}
function tsTypeAssertion(typeAnnotation, expression) {
    return _builder.default.apply("TSTypeAssertion", arguments);
}
function tsEnumDeclaration(id, members) {
    return _builder.default.apply("TSEnumDeclaration", arguments);
}
function tsEnumMember(id, initializer) {
    return _builder.default.apply("TSEnumMember", arguments);
}
function tsModuleDeclaration(id, body) {
    return _builder.default.apply("TSModuleDeclaration", arguments);
}
function tsModuleBlock(body) {
    return _builder.default.apply("TSModuleBlock", arguments);
}
function tsImportType(argument, qualifier, typeParameters) {
    return _builder.default.apply("TSImportType", arguments);
}
function tsImportEqualsDeclaration(id, moduleReference) {
    return _builder.default.apply("TSImportEqualsDeclaration", arguments);
}
function tsExternalModuleReference(expression) {
    return _builder.default.apply("TSExternalModuleReference", arguments);
}
function tsNonNullExpression(expression) {
    return _builder.default.apply("TSNonNullExpression", arguments);
}
function tsExportAssignment(expression) {
    return _builder.default.apply("TSExportAssignment", arguments);
}
function tsNamespaceExportDeclaration(id) {
    return _builder.default.apply("TSNamespaceExportDeclaration", arguments);
}
function tsTypeAnnotation(typeAnnotation) {
    return _builder.default.apply("TSTypeAnnotation", arguments);
}
function tsTypeParameterInstantiation(params) {
    return _builder.default.apply("TSTypeParameterInstantiation", arguments);
}
function tsTypeParameterDeclaration(params) {
    return _builder.default.apply("TSTypeParameterDeclaration", arguments);
}
function tsTypeParameter(constraint, _default, name) {
    return _builder.default.apply("TSTypeParameter", arguments);
}
function NumberLiteral(value) {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
    return _builder.default.apply("NumberLiteral", arguments);
}
function RegexLiteral(pattern, flags) {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
    return _builder.default.apply("RegexLiteral", arguments);
}
function RestProperty(argument) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    return _builder.default.apply("RestProperty", arguments);
}
function SpreadProperty(argument) {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");
    return _builder.default.apply("SpreadProperty", arguments);
}

},{"../builder":"5LKil"}],"5LKil":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = builder;
var _definitions = require("../definitions");
var _validate = require("../validators/validate");
function builder() {
    const type = this;
    const keys = _definitions.BUILDER_KEYS[type];
    const countArgs = arguments.length;
    if (countArgs > keys.length) throw new Error(`${type}: Too many arguments passed. Received ${countArgs} but can receive no more than ${keys.length}`);
    const node = {
        type
    };
    for(let i = 0; i < keys.length; ++i){
        const key = keys[i];
        const field = _definitions.NODE_FIELDS[type][key];
        let arg;
        if (i < countArgs) arg = arguments[i];
        if (arg === undefined) arg = Array.isArray(field.default) ? [] : field.default;
        node[key] = arg;
    }
    for(const key in node)(0, _validate.default)(node, key, node[key]);
    return node;
}

},{"../definitions":"dzUB7","../validators/validate":"hEMm0"}],"dzUB7":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ALIAS_KEYS", {
    enumerable: true,
    get: function() {
        return _utils.ALIAS_KEYS;
    }
});
Object.defineProperty(exports, "BUILDER_KEYS", {
    enumerable: true,
    get: function() {
        return _utils.BUILDER_KEYS;
    }
});
Object.defineProperty(exports, "DEPRECATED_KEYS", {
    enumerable: true,
    get: function() {
        return _utils.DEPRECATED_KEYS;
    }
});
Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
    enumerable: true,
    get: function() {
        return _utils.FLIPPED_ALIAS_KEYS;
    }
});
Object.defineProperty(exports, "NODE_FIELDS", {
    enumerable: true,
    get: function() {
        return _utils.NODE_FIELDS;
    }
});
Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
    enumerable: true,
    get: function() {
        return _utils.NODE_PARENT_VALIDATIONS;
    }
});
Object.defineProperty(exports, "PLACEHOLDERS", {
    enumerable: true,
    get: function() {
        return _placeholders.PLACEHOLDERS;
    }
});
Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
    enumerable: true,
    get: function() {
        return _placeholders.PLACEHOLDERS_ALIAS;
    }
});
Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: true,
    get: function() {
        return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
    }
});
exports.TYPES = void 0;
Object.defineProperty(exports, "VISITOR_KEYS", {
    enumerable: true,
    get: function() {
        return _utils.VISITOR_KEYS;
    }
});
var _toFastProperties = require("to-fast-properties");
require("./core");
require("./flow");
require("./jsx");
require("./misc");
require("./experimental");
require("./typescript");
var _utils = require("./utils");
var _placeholders = require("./placeholders");
_toFastProperties(_utils.VISITOR_KEYS);
_toFastProperties(_utils.ALIAS_KEYS);
_toFastProperties(_utils.FLIPPED_ALIAS_KEYS);
_toFastProperties(_utils.NODE_FIELDS);
_toFastProperties(_utils.BUILDER_KEYS);
_toFastProperties(_utils.DEPRECATED_KEYS);
_toFastProperties(_placeholders.PLACEHOLDERS_ALIAS);
_toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
const TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
exports.TYPES = TYPES;

},{"to-fast-properties":"60Xij","./core":"9JmbX","./flow":"6qmZL","./jsx":"9wlps","./misc":"9TUgv","./experimental":"4y6d0","./typescript":"ciXvA","./utils":"dghvW","./placeholders":"jlGu5"}],"60Xij":[function(require,module,exports) {
'use strict';
let fastProto = null;
// Creates an object with permanently fast properties in V8. See Toon Verwaest's
// post https://medium.com/@tverwaes/setting-up-prototypes-in-v8-ec9c9491dfe2#5f62
// for more details. Use %HasFastProperties(object) and the Node.js flag
// --allow-natives-syntax to check whether an object has fast properties.
function FastObject(o) {
    // A prototype object will have "fast properties" enabled once it is checked
    // against the inline property cache of a function, e.g. fastProto.property:
    // https://github.com/v8/v8/blob/6.0.122/test/mjsunit/fast-prototype.js#L48-L63
    if (fastProto !== null && typeof fastProto.property) {
        const result = fastProto;
        fastProto = FastObject.prototype = null;
        return result;
    }
    fastProto = FastObject.prototype = o == null ? Object.create(null) : o;
    return new FastObject;
}
// Initialize the inline property cache of FastObject
FastObject();
module.exports = function toFastproperties(o) {
    return FastObject(o);
};

},{}],"9JmbX":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;
var _is = require("../validators/is");
var _isValidIdentifier = require("../validators/isValidIdentifier");
var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");
var _constants = require("../constants");
var _utils = require("./utils");
const defineType = (0, _utils.defineAliasedType)("Standardized");
defineType("ArrayExpression", {
    fields: {
        elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
            default: []
        }
    },
    visitor: [
        "elements"
    ],
    aliases: [
        "Expression"
    ]
});
defineType("AssignmentExpression", {
    fields: {
        operator: {
            validate: function() {
                var node, key, val;
                return (0, _utils.assertValueType)("string");
            }()
        },
        left: {
            validate: (0, _utils.assertNodeType)("LVal")
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    builder: [
        "operator",
        "left",
        "right"
    ],
    visitor: [
        "left",
        "right"
    ],
    aliases: [
        "Expression"
    ]
});
defineType("BinaryExpression", {
    builder: [
        "operator",
        "left",
        "right"
    ],
    fields: {
        operator: {
            validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)
        },
        left: {
            validate: function() {
                const expression = (0, _utils.assertNodeType)("Expression");
                const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
                const validator1 = function(node, key, val) {
                    const validator = node.operator === "in" ? inOp : expression;
                    validator(node, key, val);
                };
                validator1.oneOfNodeTypes = [
                    "Expression",
                    "PrivateName"
                ];
                return validator1;
            }()
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    visitor: [
        "left",
        "right"
    ],
    aliases: [
        "Binary",
        "Expression"
    ]
});
defineType("InterpreterDirective", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    }
});
defineType("Directive", {
    visitor: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertNodeType)("DirectiveLiteral")
        }
    }
});
defineType("DirectiveLiteral", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    }
});
defineType("BlockStatement", {
    builder: [
        "body",
        "directives"
    ],
    visitor: [
        "directives",
        "body"
    ],
    fields: {
        directives: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
            default: []
        },
        body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
    },
    aliases: [
        "Scopable",
        "BlockParent",
        "Block",
        "Statement"
    ]
});
defineType("BreakStatement", {
    visitor: [
        "label"
    ],
    fields: {
        label: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
        }
    },
    aliases: [
        "Statement",
        "Terminatorless",
        "CompletionStatement"
    ]
});
defineType("CallExpression", {
    visitor: [
        "callee",
        "arguments",
        "typeParameters",
        "typeArguments"
    ],
    builder: [
        "callee",
        "arguments"
    ],
    aliases: [
        "Expression"
    ],
    fields: Object.assign({
        callee: {
            validate: (0, _utils.assertNodeType)("Expression", "V8IntrinsicIdentifier")
        },
        arguments: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        }
    }, {
        optional: {
            validate: (0, _utils.assertOneOf)(true, false),
            optional: true
        }
    }, {
        typeArguments: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
            optional: true
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
            optional: true
        }
    })
});
defineType("CatchClause", {
    visitor: [
        "param",
        "body"
    ],
    fields: {
        param: {
            validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    },
    aliases: [
        "Scopable",
        "BlockParent"
    ]
});
defineType("ConditionalExpression", {
    visitor: [
        "test",
        "consequent",
        "alternate"
    ],
    fields: {
        test: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        alternate: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    aliases: [
        "Expression",
        "Conditional"
    ]
});
defineType("ContinueStatement", {
    visitor: [
        "label"
    ],
    fields: {
        label: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
        }
    },
    aliases: [
        "Statement",
        "Terminatorless",
        "CompletionStatement"
    ]
});
defineType("DebuggerStatement", {
    aliases: [
        "Statement"
    ]
});
defineType("DoWhileStatement", {
    visitor: [
        "test",
        "body"
    ],
    fields: {
        test: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    },
    aliases: [
        "Statement",
        "BlockParent",
        "Loop",
        "While",
        "Scopable"
    ]
});
defineType("EmptyStatement", {
    aliases: [
        "Statement"
    ]
});
defineType("ExpressionStatement", {
    visitor: [
        "expression"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    aliases: [
        "Statement",
        "ExpressionWrapper"
    ]
});
defineType("File", {
    builder: [
        "program",
        "comments",
        "tokens"
    ],
    visitor: [
        "program"
    ],
    fields: {
        program: {
            validate: (0, _utils.assertNodeType)("Program")
        },
        comments: {
            validate: Object.assign(()=>{}, {
                each: {
                    oneOfNodeTypes: [
                        "CommentBlock",
                        "CommentLine"
                    ]
                }
            }),
            optional: true
        },
        tokens: {
            validate: (0, _utils.assertEach)(Object.assign(()=>{}, {
                type: "any"
            })),
            optional: true
        }
    }
});
defineType("ForInStatement", {
    visitor: [
        "left",
        "right",
        "body"
    ],
    aliases: [
        "Scopable",
        "Statement",
        "For",
        "BlockParent",
        "Loop",
        "ForXStatement"
    ],
    fields: {
        left: {
            validate: (0, _utils.assertNodeType)("VariableDeclaration", "LVal")
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
defineType("ForStatement", {
    visitor: [
        "init",
        "test",
        "update",
        "body"
    ],
    aliases: [
        "Scopable",
        "Statement",
        "For",
        "BlockParent",
        "Loop"
    ],
    fields: {
        init: {
            validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
            optional: true
        },
        test: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        update: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
const functionCommon = {
    params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement")))
    },
    generator: {
        default: false
    },
    async: {
        default: false
    }
};
exports.functionCommon = functionCommon;
const functionTypeAnnotationCommon = {
    returnType: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
    },
    typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
    }
};
exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
const functionDeclarationCommon = Object.assign({}, functionCommon, {
    declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
    },
    id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
    }
});
exports.functionDeclarationCommon = functionDeclarationCommon;
defineType("FunctionDeclaration", {
    builder: [
        "id",
        "params",
        "body",
        "generator",
        "async"
    ],
    visitor: [
        "id",
        "params",
        "body",
        "returnType",
        "typeParameters"
    ],
    fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    }),
    aliases: [
        "Scopable",
        "Function",
        "BlockParent",
        "FunctionParent",
        "Statement",
        "Pureish",
        "Declaration"
    ],
    validate: function() {
        var parent, key, node;
        return ()=>{};
    }()
});
defineType("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: [
        "Scopable",
        "Function",
        "BlockParent",
        "FunctionParent",
        "Expression",
        "Pureish"
    ],
    fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
        id: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    })
});
const patternLikeCommon = {
    typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
    },
    decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
    }
};
exports.patternLikeCommon = patternLikeCommon;
defineType("Identifier", {
    builder: [
        "name"
    ],
    visitor: [
        "typeAnnotation",
        "decorators"
    ],
    aliases: [
        "Expression",
        "PatternLike",
        "LVal",
        "TSEntityName"
    ],
    fields: Object.assign({}, patternLikeCommon, {
        name: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
                return;
            }, {
                type: "string"
            }))
        },
        optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        }
    }),
    validate (parent, key, node) {
        return;
    }
});
defineType("IfStatement", {
    visitor: [
        "test",
        "consequent",
        "alternate"
    ],
    aliases: [
        "Statement",
        "Conditional"
    ],
    fields: {
        test: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
            validate: (0, _utils.assertNodeType)("Statement")
        },
        alternate: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
defineType("LabeledStatement", {
    visitor: [
        "label",
        "body"
    ],
    aliases: [
        "Statement"
    ],
    fields: {
        label: {
            validate: (0, _utils.assertNodeType)("Identifier")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
defineType("StringLiteral", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    },
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
defineType("NumericLiteral", {
    builder: [
        "value"
    ],
    deprecatedAlias: "NumberLiteral",
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("number")
        }
    },
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
defineType("NullLiteral", {
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
defineType("BooleanLiteral", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("boolean")
        }
    },
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
defineType("RegExpLiteral", {
    builder: [
        "pattern",
        "flags"
    ],
    deprecatedAlias: "RegexLiteral",
    aliases: [
        "Expression",
        "Pureish",
        "Literal"
    ],
    fields: {
        pattern: {
            validate: (0, _utils.assertValueType)("string")
        },
        flags: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
                return;
            }, {
                type: "string"
            })),
            default: ""
        }
    }
});
defineType("LogicalExpression", {
    builder: [
        "operator",
        "left",
        "right"
    ],
    visitor: [
        "left",
        "right"
    ],
    aliases: [
        "Binary",
        "Expression"
    ],
    fields: {
        operator: {
            validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)
        },
        left: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("MemberExpression", {
    builder: [
        "object",
        "property",
        "computed",
        "optional"
    ],
    visitor: [
        "object",
        "property"
    ],
    aliases: [
        "Expression",
        "LVal"
    ],
    fields: Object.assign({
        object: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        property: {
            validate: function() {
                const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
                const computed = (0, _utils.assertNodeType)("Expression");
                const validator2 = function(node, key, val) {
                    const validator = node.computed ? computed : normal;
                    validator(node, key, val);
                };
                validator2.oneOfNodeTypes = [
                    "Expression",
                    "Identifier",
                    "PrivateName"
                ];
                return validator2;
            }()
        },
        computed: {
            default: false
        }
    }, {
        optional: {
            validate: (0, _utils.assertOneOf)(true, false),
            optional: true
        }
    })
});
defineType("NewExpression", {
    inherits: "CallExpression"
});
defineType("Program", {
    visitor: [
        "directives",
        "body"
    ],
    builder: [
        "body",
        "directives",
        "sourceType",
        "interpreter"
    ],
    fields: {
        sourceFile: {
            validate: (0, _utils.assertValueType)("string")
        },
        sourceType: {
            validate: (0, _utils.assertOneOf)("script", "module"),
            default: "script"
        },
        interpreter: {
            validate: (0, _utils.assertNodeType)("InterpreterDirective"),
            default: null,
            optional: true
        },
        directives: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
            default: []
        },
        body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
    },
    aliases: [
        "Scopable",
        "BlockParent",
        "Block"
    ]
});
defineType("ObjectExpression", {
    visitor: [
        "properties"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
        }
    }
});
defineType("ObjectMethod", {
    builder: [
        "kind",
        "key",
        "params",
        "body",
        "computed",
        "generator",
        "async"
    ],
    fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
        kind: Object.assign({
            validate: (0, _utils.assertOneOf)("method", "get", "set")
        }, {
            default: "method"
        }),
        computed: {
            default: false
        },
        key: {
            validate: function() {
                const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
                const computed = (0, _utils.assertNodeType)("Expression");
                const validator3 = function(node, key, val) {
                    const validator = node.computed ? computed : normal;
                    validator(node, key, val);
                };
                validator3.oneOfNodeTypes = [
                    "Expression",
                    "Identifier",
                    "StringLiteral",
                    "NumericLiteral"
                ];
                return validator3;
            }()
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    }),
    visitor: [
        "key",
        "params",
        "body",
        "decorators",
        "returnType",
        "typeParameters"
    ],
    aliases: [
        "UserWhitespacable",
        "Function",
        "Scopable",
        "BlockParent",
        "FunctionParent",
        "Method",
        "ObjectMember"
    ]
});
defineType("ObjectProperty", {
    builder: [
        "key",
        "value",
        "computed",
        "shorthand",
        "decorators"
    ],
    fields: {
        computed: {
            default: false
        },
        key: {
            validate: function() {
                const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
                const computed = (0, _utils.assertNodeType)("Expression");
                const validator4 = function(node, key, val) {
                    const validator = node.computed ? computed : normal;
                    validator(node, key, val);
                };
                validator4.oneOfNodeTypes = [
                    "Expression",
                    "Identifier",
                    "StringLiteral",
                    "NumericLiteral"
                ];
                return validator4;
            }()
        },
        value: {
            validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
        },
        shorthand: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
                return;
            }, {
                type: "boolean"
            }), function(node, key, val) {
                return;
            }),
            default: false
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        }
    },
    visitor: [
        "key",
        "value",
        "decorators"
    ],
    aliases: [
        "UserWhitespacable",
        "Property",
        "ObjectMember"
    ],
    validate: function() {
        const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern");
        const expression = (0, _utils.assertNodeType)("Expression");
        return function(parent, key, node) {
            return;
        };
    }()
});
defineType("RestElement", {
    visitor: [
        "argument",
        "typeAnnotation"
    ],
    builder: [
        "argument"
    ],
    aliases: [
        "LVal",
        "PatternLike"
    ],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, patternLikeCommon, {
        argument: {
            validate: (0, _utils.assertNodeType)("LVal")
        },
        optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        }
    }),
    validate (parent, key) {
        return;
    }
});
defineType("ReturnStatement", {
    visitor: [
        "argument"
    ],
    aliases: [
        "Statement",
        "Terminatorless",
        "CompletionStatement"
    ],
    fields: {
        argument: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        }
    }
});
defineType("SequenceExpression", {
    visitor: [
        "expressions"
    ],
    fields: {
        expressions: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
        }
    },
    aliases: [
        "Expression"
    ]
});
defineType("ParenthesizedExpression", {
    visitor: [
        "expression"
    ],
    aliases: [
        "Expression",
        "ExpressionWrapper"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("SwitchCase", {
    visitor: [
        "test",
        "consequent"
    ],
    fields: {
        test: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        consequent: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
    }
});
defineType("SwitchStatement", {
    visitor: [
        "discriminant",
        "cases"
    ],
    aliases: [
        "Statement",
        "BlockParent",
        "Scopable"
    ],
    fields: {
        discriminant: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        cases: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
        }
    }
});
defineType("ThisExpression", {
    aliases: [
        "Expression"
    ]
});
defineType("ThrowStatement", {
    visitor: [
        "argument"
    ],
    aliases: [
        "Statement",
        "Terminatorless",
        "CompletionStatement"
    ],
    fields: {
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("TryStatement", {
    visitor: [
        "block",
        "handler",
        "finalizer"
    ],
    aliases: [
        "Statement"
    ],
    fields: {
        block: {
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node) {
                return;
            }, {
                oneOfNodeTypes: [
                    "BlockStatement"
                ]
            }))
        },
        handler: {
            optional: true,
            validate: (0, _utils.assertNodeType)("CatchClause")
        },
        finalizer: {
            optional: true,
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    }
});
defineType("UnaryExpression", {
    builder: [
        "operator",
        "argument",
        "prefix"
    ],
    fields: {
        prefix: {
            default: true
        },
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        operator: {
            validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)
        }
    },
    visitor: [
        "argument"
    ],
    aliases: [
        "UnaryLike",
        "Expression"
    ]
});
defineType("UpdateExpression", {
    builder: [
        "operator",
        "argument",
        "prefix"
    ],
    fields: {
        prefix: {
            default: false
        },
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        operator: {
            validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)
        }
    },
    visitor: [
        "argument"
    ],
    aliases: [
        "Expression"
    ]
});
defineType("VariableDeclaration", {
    builder: [
        "kind",
        "declarations"
    ],
    visitor: [
        "declarations"
    ],
    aliases: [
        "Statement",
        "Declaration"
    ],
    fields: {
        declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        kind: {
            validate: (0, _utils.assertOneOf)("var", "let", "const")
        },
        declarations: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
        }
    },
    validate (parent, key, node) {
        return;
    }
});
defineType("VariableDeclarator", {
    visitor: [
        "id",
        "init"
    ],
    fields: {
        id: {
            validate: function() {
                var node, key, val;
                return (0, _utils.assertNodeType)("LVal");
            }()
        },
        definite: {
            optional: true,
            validate: (0, _utils.assertValueType)("boolean")
        },
        init: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("WhileStatement", {
    visitor: [
        "test",
        "body"
    ],
    aliases: [
        "Statement",
        "BlockParent",
        "Loop",
        "While",
        "Scopable"
    ],
    fields: {
        test: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
defineType("WithStatement", {
    visitor: [
        "object",
        "body"
    ],
    aliases: [
        "Statement"
    ],
    fields: {
        object: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
defineType("AssignmentPattern", {
    visitor: [
        "left",
        "right",
        "decorators"
    ],
    builder: [
        "left",
        "right"
    ],
    aliases: [
        "Pattern",
        "PatternLike",
        "LVal"
    ],
    fields: Object.assign({}, patternLikeCommon, {
        left: {
            validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression")
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        }
    })
});
defineType("ArrayPattern", {
    visitor: [
        "elements",
        "typeAnnotation"
    ],
    builder: [
        "elements"
    ],
    aliases: [
        "Pattern",
        "PatternLike",
        "LVal"
    ],
    fields: Object.assign({}, patternLikeCommon, {
        elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike")))
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        }
    })
});
defineType("ArrowFunctionExpression", {
    builder: [
        "params",
        "body",
        "async"
    ],
    visitor: [
        "params",
        "body",
        "returnType",
        "typeParameters"
    ],
    aliases: [
        "Scopable",
        "Function",
        "BlockParent",
        "FunctionParent",
        "Expression",
        "Pureish"
    ],
    fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
        expression: {
            validate: (0, _utils.assertValueType)("boolean")
        },
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
        }
    })
});
defineType("ClassBody", {
    visitor: [
        "body"
    ],
    fields: {
        body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))
        }
    }
});
defineType("ClassExpression", {
    builder: [
        "id",
        "superClass",
        "body",
        "decorators"
    ],
    visitor: [
        "id",
        "body",
        "superClass",
        "mixins",
        "typeParameters",
        "superTypeParameters",
        "implements",
        "decorators"
    ],
    aliases: [
        "Scopable",
        "Class",
        "Expression"
    ],
    fields: {
        id: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
        },
        superTypeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
        },
        implements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        mixins: {
            validate: (0, _utils.assertNodeType)("InterfaceExtends"),
            optional: true
        }
    }
});
defineType("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: [
        "Scopable",
        "Class",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: {
            validate: (0, _utils.assertNodeType)("Identifier")
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
        },
        superTypeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
        },
        implements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        mixins: {
            validate: (0, _utils.assertNodeType)("InterfaceExtends"),
            optional: true
        },
        declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        abstract: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        }
    },
    validate: function() {
        const identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node) {
            return;
        };
    }()
});
defineType("ExportAllDeclaration", {
    visitor: [
        "source"
    ],
    aliases: [
        "Statement",
        "Declaration",
        "ModuleDeclaration",
        "ExportDeclaration"
    ],
    fields: {
        source: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")),
        assertions: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        }
    }
});
defineType("ExportDefaultDeclaration", {
    visitor: [
        "declaration"
    ],
    aliases: [
        "Statement",
        "Declaration",
        "ModuleDeclaration",
        "ExportDeclaration"
    ],
    fields: {
        declaration: {
            validate: (0, _utils.assertNodeType)("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
    }
});
defineType("ExportNamedDeclaration", {
    visitor: [
        "declaration",
        "specifiers",
        "source"
    ],
    aliases: [
        "Statement",
        "Declaration",
        "ModuleDeclaration",
        "ExportDeclaration"
    ],
    fields: {
        declaration: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node, key, val) {
                return;
            }, {
                oneOfNodeTypes: [
                    "Declaration"
                ]
            }), function(node, key, val) {
                return;
            })
        },
        assertions: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        specifiers: {
            default: [],
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function() {
                const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
                const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
                var node, key, val;
                return sourced;
            }()))
        },
        source: {
            validate: (0, _utils.assertNodeType)("StringLiteral"),
            optional: true
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }
});
defineType("ExportSpecifier", {
    visitor: [
        "local",
        "exported"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        local: {
            validate: (0, _utils.assertNodeType)("Identifier")
        },
        exported: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        exportKind: {
            validate: (0, _utils.assertOneOf)("type", "value"),
            optional: true
        }
    }
});
defineType("ForOfStatement", {
    visitor: [
        "left",
        "right",
        "body"
    ],
    builder: [
        "left",
        "right",
        "body",
        "await"
    ],
    aliases: [
        "Scopable",
        "Statement",
        "For",
        "BlockParent",
        "Loop",
        "ForXStatement"
    ],
    fields: {
        left: {
            validate: function() {
                var node, key, val;
                return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
            }()
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        },
        await: {
            default: false
        }
    }
});
defineType("ImportDeclaration", {
    visitor: [
        "specifiers",
        "source"
    ],
    aliases: [
        "Statement",
        "Declaration",
        "ModuleDeclaration"
    ],
    fields: {
        assertions: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        specifiers: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
        },
        source: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        importKind: {
            validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
            optional: true
        }
    }
});
defineType("ImportDefaultSpecifier", {
    visitor: [
        "local"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        local: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
defineType("ImportNamespaceSpecifier", {
    visitor: [
        "local"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        local: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
defineType("ImportSpecifier", {
    visitor: [
        "local",
        "imported"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        local: {
            validate: (0, _utils.assertNodeType)("Identifier")
        },
        imported: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        importKind: {
            validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
            optional: true
        }
    }
});
defineType("MetaProperty", {
    visitor: [
        "meta",
        "property"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        meta: {
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node, key, val) {
                return;
            }, {
                oneOfNodeTypes: [
                    "Identifier"
                ]
            }))
        },
        property: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
const classMethodOrPropertyCommon = {
    abstract: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
    },
    accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true
    },
    static: {
        default: false
    },
    override: {
        default: false
    },
    computed: {
        default: false
    },
    optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
    },
    key: {
        validate: (0, _utils.chain)(function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
            const computed = (0, _utils.assertNodeType)("Expression");
            return function(node, key, val) {
                const validator = node.computed ? computed : normal;
                validator(node, key, val);
            };
        }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
    }
};
exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
const classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {
    params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
    },
    kind: {
        validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
        default: "method"
    },
    access: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
        optional: true
    },
    decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
    }
});
exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
defineType("ClassMethod", {
    aliases: [
        "Function",
        "Scopable",
        "BlockParent",
        "FunctionParent",
        "Method"
    ],
    builder: [
        "kind",
        "key",
        "params",
        "body",
        "computed",
        "static",
        "generator",
        "async"
    ],
    visitor: [
        "key",
        "params",
        "body",
        "decorators",
        "returnType",
        "typeParameters"
    ],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    })
});
defineType("ObjectPattern", {
    visitor: [
        "properties",
        "typeAnnotation",
        "decorators"
    ],
    builder: [
        "properties"
    ],
    aliases: [
        "Pattern",
        "PatternLike",
        "LVal"
    ],
    fields: Object.assign({}, patternLikeCommon, {
        properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
        }
    })
});
defineType("SpreadElement", {
    visitor: [
        "argument"
    ],
    aliases: [
        "UnaryLike"
    ],
    deprecatedAlias: "SpreadProperty",
    fields: {
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("Super", {
    aliases: [
        "Expression"
    ]
});
defineType("TaggedTemplateExpression", {
    visitor: [
        "tag",
        "quasi",
        "typeParameters"
    ],
    builder: [
        "tag",
        "quasi"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        tag: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        quasi: {
            validate: (0, _utils.assertNodeType)("TemplateLiteral")
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
        }
    }
});
defineType("TemplateElement", {
    builder: [
        "value",
        "tail"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertShape)({
                raw: {
                    validate: (0, _utils.assertValueType)("string")
                },
                cooked: {
                    validate: (0, _utils.assertValueType)("string"),
                    optional: true
                }
            })
        },
        tail: {
            default: false
        }
    }
});
defineType("TemplateLiteral", {
    visitor: [
        "quasis",
        "expressions"
    ],
    aliases: [
        "Expression",
        "Literal"
    ],
    fields: {
        quasis: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
        },
        expressions: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node, key, val) {
                if (node.quasis.length !== val.length + 1) throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);
            })
        }
    }
});
defineType("YieldExpression", {
    builder: [
        "argument",
        "delegate"
    ],
    visitor: [
        "argument"
    ],
    aliases: [
        "Expression",
        "Terminatorless"
    ],
    fields: {
        delegate: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
                return;
            }, {
                type: "boolean"
            })),
            default: false
        },
        argument: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("AwaitExpression", {
    builder: [
        "argument"
    ],
    visitor: [
        "argument"
    ],
    aliases: [
        "Expression",
        "Terminatorless"
    ],
    fields: {
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("Import", {
    aliases: [
        "Expression"
    ]
});
defineType("BigIntLiteral", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    },
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
defineType("ExportNamespaceSpecifier", {
    visitor: [
        "exported"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        exported: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
defineType("OptionalMemberExpression", {
    builder: [
        "object",
        "property",
        "computed",
        "optional"
    ],
    visitor: [
        "object",
        "property"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        object: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        property: {
            validate: function() {
                const normal = (0, _utils.assertNodeType)("Identifier");
                const computed = (0, _utils.assertNodeType)("Expression");
                const validator5 = function(node, key, val) {
                    const validator = node.computed ? computed : normal;
                    validator(node, key, val);
                };
                validator5.oneOfNodeTypes = [
                    "Expression",
                    "Identifier"
                ];
                return validator5;
            }()
        },
        computed: {
            default: false
        },
        optional: {
            validate: (0, _utils.assertValueType)("boolean")
        }
    }
});
defineType("OptionalCallExpression", {
    visitor: [
        "callee",
        "arguments",
        "typeParameters",
        "typeArguments"
    ],
    builder: [
        "callee",
        "arguments",
        "optional"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        callee: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        arguments: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        },
        optional: {
            validate: (0, _utils.assertValueType)("boolean")
        },
        typeArguments: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
            optional: true
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
            optional: true
        }
    }
});
defineType("ClassProperty", {
    visitor: [
        "key",
        "value",
        "typeAnnotation",
        "decorators"
    ],
    builder: [
        "key",
        "value",
        "typeAnnotation",
        "decorators",
        "computed",
        "static"
    ],
    aliases: [
        "Property"
    ],
    fields: Object.assign({}, classMethodOrPropertyCommon, {
        value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: true
        }
    })
});
defineType("ClassPrivateProperty", {
    visitor: [
        "key",
        "value",
        "decorators",
        "typeAnnotation"
    ],
    builder: [
        "key",
        "value",
        "decorators",
        "static"
    ],
    aliases: [
        "Property",
        "Private"
    ],
    fields: {
        key: {
            validate: (0, _utils.assertNodeType)("PrivateName")
        },
        value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: true
        }
    }
});
defineType("ClassPrivateMethod", {
    builder: [
        "kind",
        "key",
        "params",
        "body",
        "static"
    ],
    visitor: [
        "key",
        "params",
        "body",
        "decorators",
        "returnType",
        "typeParameters"
    ],
    aliases: [
        "Function",
        "Scopable",
        "BlockParent",
        "FunctionParent",
        "Method",
        "Private"
    ],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
        key: {
            validate: (0, _utils.assertNodeType)("PrivateName")
        },
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    })
});
defineType("PrivateName", {
    visitor: [
        "id"
    ],
    aliases: [
        "Private"
    ],
    fields: {
        id: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
defineType("StaticBlock", {
    visitor: [
        "body"
    ],
    fields: {
        body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
    },
    aliases: [
        "Scopable",
        "BlockParent",
        "FunctionParent"
    ]
});

},{"../validators/is":"g9VKJ","../validators/isValidIdentifier":"gb2G9","@babel/helper-validator-identifier":"f9R0u","../constants":"lrpJ7","./utils":"dghvW"}],"g9VKJ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = is;
var _shallowEqual = require("../utils/shallowEqual");
var _isType = require("./isType");
var _isPlaceholderType = require("./isPlaceholderType");
var _definitions = require("../definitions");
function is(type, node, opts) {
    if (!node) return false;
    const matches = (0, _isType.default)(node.type, type);
    if (!matches) {
        if (!opts && node.type === "Placeholder" && type in _definitions.FLIPPED_ALIAS_KEYS) return (0, _isPlaceholderType.default)(node.expectedNode, type);
        return false;
    }
    if (typeof opts === "undefined") return true;
    else return (0, _shallowEqual.default)(node, opts);
}

},{"../utils/shallowEqual":"9y7Dh","./isType":"dZEXP","./isPlaceholderType":"dO0QO","../definitions":"dzUB7"}],"dZEXP":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isType;
var _definitions = require("../definitions");
function isType(nodeType, targetType) {
    if (nodeType === targetType) return true;
    if (_definitions.ALIAS_KEYS[targetType]) return false;
    const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];
    if (aliases) {
        if (aliases[0] === nodeType) return true;
        for (const alias of aliases){
            if (nodeType === alias) return true;
        }
    }
    return false;
}

},{"../definitions":"dzUB7"}],"dO0QO":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isPlaceholderType;
var _definitions = require("../definitions");
function isPlaceholderType(placeholderType, targetType) {
    if (placeholderType === targetType) return true;
    const aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];
    if (aliases) for (const alias of aliases){
        if (targetType === alias) return true;
    }
    return false;
}

},{"../definitions":"dzUB7"}],"gb2G9":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isValidIdentifier;
var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");
function isValidIdentifier(name, reserved = true) {
    if (typeof name !== "string") return false;
    if (reserved) {
        if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) return false;
    }
    return (0, _helperValidatorIdentifier.isIdentifierName)(name);
}

},{"@babel/helper-validator-identifier":"f9R0u"}],"f9R0u":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isIdentifierName", {
    enumerable: true,
    get: function() {
        return _identifier.isIdentifierName;
    }
});
Object.defineProperty(exports, "isIdentifierChar", {
    enumerable: true,
    get: function() {
        return _identifier.isIdentifierChar;
    }
});
Object.defineProperty(exports, "isIdentifierStart", {
    enumerable: true,
    get: function() {
        return _identifier.isIdentifierStart;
    }
});
Object.defineProperty(exports, "isReservedWord", {
    enumerable: true,
    get: function() {
        return _keyword.isReservedWord;
    }
});
Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
    enumerable: true,
    get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
    }
});
Object.defineProperty(exports, "isStrictBindReservedWord", {
    enumerable: true,
    get: function() {
        return _keyword.isStrictBindReservedWord;
    }
});
Object.defineProperty(exports, "isStrictReservedWord", {
    enumerable: true,
    get: function() {
        return _keyword.isStrictReservedWord;
    }
});
Object.defineProperty(exports, "isKeyword", {
    enumerable: true,
    get: function() {
        return _keyword.isKeyword;
    }
});
var _identifier = require("./identifier");
var _keyword = require("./keyword");

},{"./identifier":"3lM37","./keyword":"i8ErG"}],"3lM37":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isIdentifierStart = isIdentifierStart;
exports.isIdentifierChar = isIdentifierChar;
exports.isIdentifierName = isIdentifierName;
let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
let nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
const astralIdentifierStartCodes = [
    0,
    11,
    2,
    25,
    2,
    18,
    2,
    1,
    2,
    14,
    3,
    13,
    35,
    122,
    70,
    52,
    268,
    28,
    4,
    48,
    48,
    31,
    14,
    29,
    6,
    37,
    11,
    29,
    3,
    35,
    5,
    7,
    2,
    4,
    43,
    157,
    19,
    35,
    5,
    35,
    5,
    39,
    9,
    51,
    13,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    2,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    68,
    310,
    10,
    21,
    11,
    7,
    25,
    5,
    2,
    41,
    2,
    8,
    70,
    5,
    3,
    0,
    2,
    43,
    2,
    1,
    4,
    0,
    3,
    22,
    11,
    22,
    10,
    30,
    66,
    18,
    2,
    1,
    11,
    21,
    11,
    25,
    71,
    55,
    7,
    1,
    65,
    0,
    16,
    3,
    2,
    2,
    2,
    28,
    43,
    28,
    4,
    28,
    36,
    7,
    2,
    27,
    28,
    53,
    11,
    21,
    11,
    18,
    14,
    17,
    111,
    72,
    56,
    50,
    14,
    50,
    14,
    35,
    349,
    41,
    7,
    1,
    79,
    28,
    11,
    0,
    9,
    21,
    43,
    17,
    47,
    20,
    28,
    22,
    13,
    52,
    58,
    1,
    3,
    0,
    14,
    44,
    33,
    24,
    27,
    35,
    30,
    0,
    3,
    0,
    9,
    34,
    4,
    0,
    13,
    47,
    15,
    3,
    22,
    0,
    2,
    0,
    36,
    17,
    2,
    24,
    85,
    6,
    2,
    0,
    2,
    3,
    2,
    14,
    2,
    9,
    8,
    46,
    39,
    7,
    3,
    1,
    3,
    21,
    2,
    6,
    2,
    1,
    2,
    4,
    4,
    0,
    19,
    0,
    13,
    4,
    159,
    52,
    19,
    3,
    21,
    2,
    31,
    47,
    21,
    1,
    2,
    0,
    185,
    46,
    42,
    3,
    37,
    47,
    21,
    0,
    60,
    42,
    14,
    0,
    72,
    26,
    38,
    6,
    186,
    43,
    117,
    63,
    32,
    7,
    3,
    0,
    3,
    7,
    2,
    1,
    2,
    23,
    16,
    0,
    2,
    0,
    95,
    7,
    3,
    38,
    17,
    0,
    2,
    0,
    29,
    0,
    11,
    39,
    8,
    0,
    22,
    0,
    12,
    45,
    20,
    0,
    19,
    72,
    264,
    8,
    2,
    36,
    18,
    0,
    50,
    29,
    113,
    6,
    2,
    1,
    2,
    37,
    22,
    0,
    26,
    5,
    2,
    1,
    2,
    31,
    15,
    0,
    328,
    18,
    190,
    0,
    80,
    921,
    103,
    110,
    18,
    195,
    2637,
    96,
    16,
    1070,
    4050,
    582,
    8634,
    568,
    8,
    30,
    18,
    78,
    18,
    29,
    19,
    47,
    17,
    3,
    32,
    20,
    6,
    18,
    689,
    63,
    129,
    74,
    6,
    0,
    67,
    12,
    65,
    1,
    2,
    0,
    29,
    6135,
    9,
    1237,
    43,
    8,
    8936,
    3,
    2,
    6,
    2,
    1,
    2,
    290,
    46,
    2,
    18,
    3,
    9,
    395,
    2309,
    106,
    6,
    12,
    4,
    8,
    8,
    9,
    5991,
    84,
    2,
    70,
    2,
    1,
    3,
    0,
    3,
    1,
    3,
    3,
    2,
    11,
    2,
    0,
    2,
    6,
    2,
    64,
    2,
    3,
    3,
    7,
    2,
    6,
    2,
    27,
    2,
    3,
    2,
    4,
    2,
    0,
    4,
    6,
    2,
    339,
    3,
    24,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    7,
    1845,
    30,
    482,
    44,
    11,
    6,
    17,
    0,
    322,
    29,
    19,
    43,
    1269,
    6,
    2,
    3,
    2,
    1,
    2,
    14,
    2,
    196,
    60,
    67,
    8,
    0,
    1205,
    3,
    2,
    26,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    9,
    2,
    3,
    2,
    0,
    2,
    0,
    7,
    0,
    5,
    0,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    2,
    0,
    3,
    3,
    2,
    6,
    2,
    3,
    2,
    3,
    2,
    0,
    2,
    9,
    2,
    16,
    6,
    2,
    2,
    4,
    2,
    16,
    4421,
    42719,
    33,
    4152,
    8,
    221,
    3,
    5761,
    15,
    7472,
    3104,
    541,
    1507,
    4938
];
const astralIdentifierCodes = [
    509,
    0,
    227,
    0,
    150,
    4,
    294,
    9,
    1368,
    2,
    2,
    1,
    6,
    3,
    41,
    2,
    5,
    0,
    166,
    1,
    574,
    3,
    9,
    9,
    370,
    1,
    154,
    10,
    50,
    3,
    123,
    2,
    54,
    14,
    32,
    10,
    3,
    1,
    11,
    3,
    46,
    10,
    8,
    0,
    46,
    9,
    7,
    2,
    37,
    13,
    2,
    9,
    6,
    1,
    45,
    0,
    13,
    2,
    49,
    13,
    9,
    3,
    2,
    11,
    83,
    11,
    7,
    0,
    161,
    11,
    6,
    9,
    7,
    3,
    56,
    1,
    2,
    6,
    3,
    1,
    3,
    2,
    10,
    0,
    11,
    1,
    3,
    6,
    4,
    4,
    193,
    17,
    10,
    9,
    5,
    0,
    82,
    19,
    13,
    9,
    214,
    6,
    3,
    8,
    28,
    1,
    83,
    16,
    16,
    9,
    82,
    12,
    9,
    9,
    84,
    14,
    5,
    9,
    243,
    14,
    166,
    9,
    71,
    5,
    2,
    1,
    3,
    3,
    2,
    0,
    2,
    1,
    13,
    9,
    120,
    6,
    3,
    6,
    4,
    0,
    29,
    9,
    41,
    6,
    2,
    3,
    9,
    0,
    10,
    10,
    47,
    15,
    406,
    7,
    2,
    7,
    17,
    9,
    57,
    21,
    2,
    13,
    123,
    5,
    4,
    0,
    2,
    1,
    2,
    6,
    2,
    0,
    9,
    9,
    49,
    4,
    2,
    1,
    2,
    4,
    9,
    9,
    330,
    3,
    19306,
    9,
    87,
    9,
    39,
    4,
    60,
    6,
    26,
    9,
    1014,
    0,
    2,
    54,
    8,
    3,
    82,
    0,
    12,
    1,
    19628,
    1,
    4706,
    45,
    3,
    22,
    543,
    4,
    4,
    5,
    9,
    7,
    3,
    6,
    31,
    3,
    149,
    2,
    1418,
    49,
    513,
    54,
    5,
    49,
    9,
    0,
    15,
    0,
    23,
    4,
    2,
    14,
    1361,
    6,
    2,
    16,
    3,
    6,
    2,
    1,
    2,
    4,
    262,
    6,
    10,
    9,
    357,
    0,
    62,
    13,
    1495,
    6,
    110,
    6,
    6,
    9,
    4759,
    9,
    787719,
    239
];
function isInAstralSet(code, set) {
    let pos = 65536;
    for(let i = 0, length = set.length; i < length; i += 2){
        pos += set[i];
        if (pos > code) return false;
        pos += set[i + 1];
        if (pos >= code) return true;
    }
    return false;
}
function isIdentifierStart(code) {
    if (code < 65) return code === 36;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 65535) return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
    return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 65535) return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
function isIdentifierName(name) {
    let isFirst = true;
    for(let i = 0; i < name.length; i++){
        let cp = name.charCodeAt(i);
        if ((cp & 64512) === 55296 && i + 1 < name.length) {
            const trail = name.charCodeAt(++i);
            if ((trail & 64512) === 56320) cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
        }
        if (isFirst) {
            isFirst = false;
            if (!isIdentifierStart(cp)) return false;
        } else if (!isIdentifierChar(cp)) return false;
    }
    return !isFirst;
}

},{}],"i8ErG":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isReservedWord = isReservedWord;
exports.isStrictReservedWord = isStrictReservedWord;
exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
exports.isStrictBindReservedWord = isStrictBindReservedWord;
exports.isKeyword = isKeyword;
const reservedWords = {
    keyword: [
        "break",
        "case",
        "catch",
        "continue",
        "debugger",
        "default",
        "do",
        "else",
        "finally",
        "for",
        "function",
        "if",
        "return",
        "switch",
        "throw",
        "try",
        "var",
        "const",
        "while",
        "with",
        "new",
        "this",
        "super",
        "class",
        "extends",
        "export",
        "import",
        "null",
        "true",
        "false",
        "in",
        "instanceof",
        "typeof",
        "void",
        "delete"
    ],
    strict: [
        "implements",
        "interface",
        "let",
        "package",
        "private",
        "protected",
        "public",
        "static",
        "yield"
    ],
    strictBind: [
        "eval",
        "arguments"
    ]
};
const keywords = new Set(reservedWords.keyword);
const reservedWordsStrictSet = new Set(reservedWords.strict);
const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
}
function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}
function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
}
function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
}
function isKeyword(word) {
    return keywords.has(word);
}

},{}],"lrpJ7":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.NOT_LOCAL_BINDING = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BLOCK_SCOPED_SYMBOL = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = void 0;
const STATEMENT_OR_BLOCK_KEYS = [
    "consequent",
    "body",
    "alternate"
];
exports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
const FLATTENABLE_KEYS = [
    "body",
    "expressions"
];
exports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
const FOR_INIT_KEYS = [
    "left",
    "init"
];
exports.FOR_INIT_KEYS = FOR_INIT_KEYS;
const COMMENT_KEYS = [
    "leadingComments",
    "trailingComments",
    "innerComments"
];
exports.COMMENT_KEYS = COMMENT_KEYS;
const LOGICAL_OPERATORS = [
    "||",
    "&&",
    "??"
];
exports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
const UPDATE_OPERATORS = [
    "++",
    "--"
];
exports.UPDATE_OPERATORS = UPDATE_OPERATORS;
const BOOLEAN_NUMBER_BINARY_OPERATORS = [
    ">",
    "<",
    ">=",
    "<="
];
exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
const EQUALITY_BINARY_OPERATORS = [
    "==",
    "===",
    "!=",
    "!=="
];
exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
const COMPARISON_BINARY_OPERATORS = [
    ...EQUALITY_BINARY_OPERATORS,
    "in",
    "instanceof"
];
exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
const BOOLEAN_BINARY_OPERATORS = [
    ...COMPARISON_BINARY_OPERATORS,
    ...BOOLEAN_NUMBER_BINARY_OPERATORS
];
exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
const NUMBER_BINARY_OPERATORS = [
    "-",
    "/",
    "%",
    "*",
    "**",
    "&",
    "|",
    ">>",
    ">>>",
    "<<",
    "^"
];
exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
const BINARY_OPERATORS = [
    "+",
    ...NUMBER_BINARY_OPERATORS,
    ...BOOLEAN_BINARY_OPERATORS
];
exports.BINARY_OPERATORS = BINARY_OPERATORS;
const ASSIGNMENT_OPERATORS = [
    "=",
    "+=",
    ...NUMBER_BINARY_OPERATORS.map((op)=>op + "="
    ),
    ...LOGICAL_OPERATORS.map((op)=>op + "="
    )
];
exports.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
const BOOLEAN_UNARY_OPERATORS = [
    "delete",
    "!"
];
exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
const NUMBER_UNARY_OPERATORS = [
    "+",
    "-",
    "~"
];
exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
const STRING_UNARY_OPERATORS = [
    "typeof"
];
exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
const UNARY_OPERATORS = [
    "void",
    "throw",
    ...BOOLEAN_UNARY_OPERATORS,
    ...NUMBER_UNARY_OPERATORS,
    ...STRING_UNARY_OPERATORS
];
exports.UNARY_OPERATORS = UNARY_OPERATORS;
const INHERIT_KEYS = {
    optional: [
        "typeAnnotation",
        "typeParameters",
        "returnType"
    ],
    force: [
        "start",
        "loc",
        "end"
    ]
};
exports.INHERIT_KEYS = INHERIT_KEYS;
const BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
exports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
const NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
exports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;

},{}],"dghvW":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;
exports.arrayOf = arrayOf;
exports.arrayOfType = arrayOfType;
exports.assertEach = assertEach;
exports.assertNodeOrValueType = assertNodeOrValueType;
exports.assertNodeType = assertNodeType;
exports.assertOneOf = assertOneOf;
exports.assertOptionalChainStart = assertOptionalChainStart;
exports.assertShape = assertShape;
exports.assertValueType = assertValueType;
exports.chain = chain;
exports.default = defineType;
exports.defineAliasedType = defineAliasedType;
exports.typeIs = typeIs;
exports.validate = validate;
exports.validateArrayOfType = validateArrayOfType;
exports.validateOptional = validateOptional;
exports.validateOptionalType = validateOptionalType;
exports.validateType = validateType;
var _is = require("../validators/is");
var _validate = require("../validators/validate");
const VISITOR_KEYS = {};
exports.VISITOR_KEYS = VISITOR_KEYS;
const ALIAS_KEYS = {};
exports.ALIAS_KEYS = ALIAS_KEYS;
const FLIPPED_ALIAS_KEYS = {};
exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
const NODE_FIELDS = {};
exports.NODE_FIELDS = NODE_FIELDS;
const BUILDER_KEYS = {};
exports.BUILDER_KEYS = BUILDER_KEYS;
const DEPRECATED_KEYS = {};
exports.DEPRECATED_KEYS = DEPRECATED_KEYS;
const NODE_PARENT_VALIDATIONS = {};
exports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;
function getType(val) {
    if (Array.isArray(val)) return "array";
    else if (val === null) return "null";
    else return typeof val;
}
function validate(validate1) {
    return {
        validate: validate1
    };
}
function typeIs(typeName) {
    return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
}
function validateType(typeName) {
    return validate(typeIs(typeName));
}
function validateOptional(validate2) {
    return {
        validate: validate2,
        optional: true
    };
}
function validateOptionalType(typeName) {
    return {
        validate: typeIs(typeName),
        optional: true
    };
}
function arrayOf(elementType) {
    return chain(assertValueType("array"), assertEach(elementType));
}
function arrayOfType(typeName) {
    return arrayOf(typeIs(typeName));
}
function validateArrayOfType(typeName) {
    return validate(arrayOfType(typeName));
}
function assertEach(callback) {
    function validator(node, key, val) {
        if (!Array.isArray(val)) return;
        for(let i = 0; i < val.length; i++){
            const subkey = `${key}[${i}]`;
            const v = val[i];
            callback(node, subkey, v);
        }
    }
    validator.each = callback;
    return validator;
}
function assertOneOf(...values) {
    function validate3(node, key, val) {
        if (values.indexOf(val) < 0) throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
    }
    validate3.oneOf = values;
    return validate3;
}
function assertNodeType(...types) {
    function validate4(node, key, val) {
        for (const type of types)if ((0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
    }
    validate4.oneOfNodeTypes = types;
    return validate4;
}
function assertNodeOrValueType(...types) {
    function validate5(node, key, val) {
        for (const type of types)if (getType(val) === type || (0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
    }
    validate5.oneOfNodeOrValueTypes = types;
    return validate5;
}
function assertValueType(type) {
    function validate6(node, key, val) {
        const valid = getType(val) === type;
        if (!valid) throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
    }
    validate6.type = type;
    return validate6;
}
function assertShape(shape) {
    function validate7(node, key, val) {
        const errors = [];
        for (const property of Object.keys(shape))try {
            (0, _validate.validateField)(node, property, val[property], shape[property]);
        } catch (error) {
            if (error instanceof TypeError) {
                errors.push(error.message);
                continue;
            }
            throw error;
        }
        if (errors.length) throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\n${errors.join("\n")}`);
    }
    validate7.shapeOf = shape;
    return validate7;
}
function assertOptionalChainStart() {
    function validate8(node) {
        var _current;
        let current = node;
        while(node){
            const { type  } = current;
            if (type === "OptionalCallExpression") {
                if (current.optional) return;
                current = current.callee;
                continue;
            }
            if (type === "OptionalMemberExpression") {
                if (current.optional) return;
                current = current.object;
                continue;
            }
            break;
        }
        throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
    }
    return validate8;
}
function chain(...fns) {
    function validate9(...args) {
        for (const fn of fns)fn(...args);
    }
    validate9.chainOf = fns;
    if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
    return validate9;
}
const validTypeOpts = [
    "aliases",
    "builder",
    "deprecatedAlias",
    "fields",
    "inherits",
    "visitor",
    "validate"
];
const validFieldKeys = [
    "default",
    "optional",
    "validate"
];
function defineAliasedType(...aliases) {
    return (type, opts = {})=>{
        let defined = opts.aliases;
        if (!defined) {
            var _store$opts$inherits$, _defined;
            if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
            (_defined = defined) != null || (defined = []);
            opts.aliases = defined;
        }
        const additional = aliases.filter((a)=>!defined.includes(a)
        );
        defined.unshift(...additional);
        return defineType(type, opts);
    };
}
function defineType(type, opts = {}) {
    const inherits = opts.inherits && store[opts.inherits] || {};
    let fields = opts.fields;
    if (!fields) {
        fields = {};
        if (inherits.fields) {
            const keys = Object.getOwnPropertyNames(inherits.fields);
            for (const key of keys){
                const field = inherits.fields[key];
                const def = field.default;
                if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") throw new Error("field defaults can only be primitives or empty arrays currently");
                fields[key] = {
                    default: Array.isArray(def) ? [] : def,
                    optional: field.optional,
                    validate: field.validate
                };
            }
        }
    }
    const visitor = opts.visitor || inherits.visitor || [];
    const aliases = opts.aliases || inherits.aliases || [];
    const builder = opts.builder || inherits.builder || opts.visitor || [];
    for (const k of Object.keys(opts)){
        if (validTypeOpts.indexOf(k) === -1) throw new Error(`Unknown type option "${k}" on ${type}`);
    }
    if (opts.deprecatedAlias) DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    for (const key of visitor.concat(builder))fields[key] = fields[key] || {};
    for (const key1 of Object.keys(fields)){
        const field = fields[key1];
        if (field.default !== undefined && builder.indexOf(key1) === -1) field.optional = true;
        if (field.default === undefined) field.default = null;
        else if (!field.validate && field.default != null) field.validate = assertValueType(getType(field.default));
        for (const k of Object.keys(field)){
            if (validFieldKeys.indexOf(k) === -1) throw new Error(`Unknown field key "${k}" on ${type}.${key1}`);
        }
    }
    VISITOR_KEYS[type] = opts.visitor = visitor;
    BUILDER_KEYS[type] = opts.builder = builder;
    NODE_FIELDS[type] = opts.fields = fields;
    ALIAS_KEYS[type] = opts.aliases = aliases;
    aliases.forEach((alias)=>{
        FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
        FLIPPED_ALIAS_KEYS[alias].push(type);
    });
    if (opts.validate) NODE_PARENT_VALIDATIONS[type] = opts.validate;
    store[type] = opts;
}
const store = {};

},{"../validators/is":"g9VKJ","../validators/validate":"hEMm0"}],"hEMm0":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = validate;
exports.validateChild = validateChild;
exports.validateField = validateField;
var _definitions = require("../definitions");
function validate(node, key, val) {
    if (!node) return;
    const fields = _definitions.NODE_FIELDS[node.type];
    if (!fields) return;
    const field = fields[key];
    validateField(node, key, val, field);
    validateChild(node, key, val);
}
function validateField(node, key, val, field) {
    if (!(field != null && field.validate)) return;
    if (field.optional && val == null) return;
    field.validate(node, key, val);
}
function validateChild(node, key, val) {
    if (val == null) return;
    const validate1 = _definitions.NODE_PARENT_VALIDATIONS[val.type];
    if (!validate1) return;
    validate1(node, key, val);
}

},{"../definitions":"dzUB7"}],"6qmZL":[function(require,module,exports) {
"use strict";
var _utils = require("./utils");
const defineType = (0, _utils.defineAliasedType)("Flow");
const defineInterfaceishType = (name, typeParameterType = "TypeParameterDeclaration")=>{
    defineType(name, {
        builder: [
            "id",
            "typeParameters",
            "extends",
            "body"
        ],
        visitor: [
            "id",
            "typeParameters",
            "extends",
            "mixins",
            "implements",
            "body"
        ],
        aliases: [
            "FlowDeclaration",
            "Statement",
            "Declaration"
        ],
        fields: {
            id: (0, _utils.validateType)("Identifier"),
            typeParameters: (0, _utils.validateOptionalType)(typeParameterType),
            extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
            mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
            implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements")),
            body: (0, _utils.validateType)("ObjectTypeAnnotation")
        }
    });
};
defineType("AnyTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("ArrayTypeAnnotation", {
    visitor: [
        "elementType"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        elementType: (0, _utils.validateType)("FlowType")
    }
});
defineType("BooleanTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("BooleanLiteralTypeAnnotation", {
    builder: [
        "value"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("NullLiteralTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("ClassImplements", {
    visitor: [
        "id",
        "typeParameters"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
});
defineInterfaceishType("DeclareClass");
defineType("DeclareFunction", {
    visitor: [
        "id"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
    }
});
defineInterfaceishType("DeclareInterface");
defineType("DeclareModule", {
    builder: [
        "id",
        "body",
        "kind"
    ],
    visitor: [
        "id",
        "body"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)([
            "Identifier",
            "StringLiteral"
        ]),
        body: (0, _utils.validateType)("BlockStatement"),
        kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
    }
});
defineType("DeclareModuleExports", {
    visitor: [
        "typeAnnotation"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
});
defineType("DeclareTypeAlias", {
    visitor: [
        "id",
        "typeParameters",
        "right"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
    }
});
defineType("DeclareOpaqueType", {
    visitor: [
        "id",
        "typeParameters",
        "supertype"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateOptionalType)("FlowType")
    }
});
defineType("DeclareVariable", {
    visitor: [
        "id"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier")
    }
});
defineType("DeclareExportDeclaration", {
    visitor: [
        "declaration",
        "specifiers",
        "source"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        declaration: (0, _utils.validateOptionalType)("Flow"),
        specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)([
            "ExportSpecifier",
            "ExportNamespaceSpecifier"
        ])),
        source: (0, _utils.validateOptionalType)("StringLiteral"),
        default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("DeclareExportAllDeclaration", {
    visitor: [
        "source"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        source: (0, _utils.validateType)("StringLiteral"),
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }
});
defineType("DeclaredPredicate", {
    visitor: [
        "value"
    ],
    aliases: [
        "FlowPredicate"
    ],
    fields: {
        value: (0, _utils.validateType)("Flow")
    }
});
defineType("ExistsTypeAnnotation", {
    aliases: [
        "FlowType"
    ]
});
defineType("FunctionTypeAnnotation", {
    visitor: [
        "typeParameters",
        "params",
        "rest",
        "returnType"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
        rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        returnType: (0, _utils.validateType)("FlowType")
    }
});
defineType("FunctionTypeParam", {
    visitor: [
        "name",
        "typeAnnotation"
    ],
    fields: {
        name: (0, _utils.validateOptionalType)("Identifier"),
        typeAnnotation: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("GenericTypeAnnotation", {
    visitor: [
        "id",
        "typeParameters"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        id: (0, _utils.validateType)([
            "Identifier",
            "QualifiedTypeIdentifier"
        ]),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
});
defineType("InferredPredicate", {
    aliases: [
        "FlowPredicate"
    ]
});
defineType("InterfaceExtends", {
    visitor: [
        "id",
        "typeParameters"
    ],
    fields: {
        id: (0, _utils.validateType)([
            "Identifier",
            "QualifiedTypeIdentifier"
        ]),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
});
defineInterfaceishType("InterfaceDeclaration");
defineType("InterfaceTypeAnnotation", {
    visitor: [
        "extends",
        "body"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        body: (0, _utils.validateType)("ObjectTypeAnnotation")
    }
});
defineType("IntersectionTypeAnnotation", {
    visitor: [
        "types"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
});
defineType("MixedTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("EmptyTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("NullableTypeAnnotation", {
    visitor: [
        "typeAnnotation"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
    }
});
defineType("NumberLiteralTypeAnnotation", {
    builder: [
        "value"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
    }
});
defineType("NumberTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("ObjectTypeAnnotation", {
    visitor: [
        "properties",
        "indexers",
        "callProperties",
        "internalSlots"
    ],
    aliases: [
        "FlowType"
    ],
    builder: [
        "properties",
        "indexers",
        "callProperties",
        "internalSlots",
        "exact"
    ],
    fields: {
        properties: (0, _utils.validate)((0, _utils.arrayOfType)([
            "ObjectTypeProperty",
            "ObjectTypeSpreadProperty"
        ])),
        indexers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeIndexer")),
        callProperties: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeCallProperty")),
        internalSlots: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeInternalSlot")),
        exact: {
            validate: (0, _utils.assertValueType)("boolean"),
            default: false
        },
        inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("ObjectTypeInternalSlot", {
    visitor: [
        "id",
        "value",
        "optional",
        "static",
        "method"
    ],
    aliases: [
        "UserWhitespacable"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        value: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("ObjectTypeCallProperty", {
    visitor: [
        "value"
    ],
    aliases: [
        "UserWhitespacable"
    ],
    fields: {
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("ObjectTypeIndexer", {
    visitor: [
        "id",
        "key",
        "value",
        "variance"
    ],
    aliases: [
        "UserWhitespacable"
    ],
    fields: {
        id: (0, _utils.validateOptionalType)("Identifier"),
        key: (0, _utils.validateType)("FlowType"),
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance")
    }
});
defineType("ObjectTypeProperty", {
    visitor: [
        "key",
        "value",
        "variance"
    ],
    aliases: [
        "UserWhitespacable"
    ],
    fields: {
        key: (0, _utils.validateType)([
            "Identifier",
            "StringLiteral"
        ]),
        value: (0, _utils.validateType)("FlowType"),
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance"),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("ObjectTypeSpreadProperty", {
    visitor: [
        "argument"
    ],
    aliases: [
        "UserWhitespacable"
    ],
    fields: {
        argument: (0, _utils.validateType)("FlowType")
    }
});
defineType("OpaqueType", {
    visitor: [
        "id",
        "typeParameters",
        "supertype",
        "impltype"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateType)("FlowType")
    }
});
defineType("QualifiedTypeIdentifier", {
    visitor: [
        "id",
        "qualification"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        qualification: (0, _utils.validateType)([
            "Identifier",
            "QualifiedTypeIdentifier"
        ])
    }
});
defineType("StringLiteralTypeAnnotation", {
    builder: [
        "value"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
    }
});
defineType("StringTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("SymbolTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("ThisTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("TupleTypeAnnotation", {
    visitor: [
        "types"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
});
defineType("TypeofTypeAnnotation", {
    visitor: [
        "argument"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        argument: (0, _utils.validateType)("FlowType")
    }
});
defineType("TypeAlias", {
    visitor: [
        "id",
        "typeParameters",
        "right"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
    }
});
defineType("TypeAnnotation", {
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
    }
});
defineType("TypeCastExpression", {
    visitor: [
        "expression",
        "typeAnnotation"
    ],
    aliases: [
        "ExpressionWrapper",
        "Expression"
    ],
    fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
});
defineType("TypeParameter", {
    visitor: [
        "bound",
        "default",
        "variance"
    ],
    fields: {
        name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
        default: (0, _utils.validateOptionalType)("FlowType"),
        variance: (0, _utils.validateOptionalType)("Variance")
    }
});
defineType("TypeParameterDeclaration", {
    visitor: [
        "params"
    ],
    fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
    }
});
defineType("TypeParameterInstantiation", {
    visitor: [
        "params"
    ],
    fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
});
defineType("UnionTypeAnnotation", {
    visitor: [
        "types"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
});
defineType("Variance", {
    builder: [
        "kind"
    ],
    fields: {
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
    }
});
defineType("VoidTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("EnumDeclaration", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "body"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        body: (0, _utils.validateType)([
            "EnumBooleanBody",
            "EnumNumberBody",
            "EnumStringBody",
            "EnumSymbolBody"
        ])
    }
});
defineType("EnumBooleanBody", {
    aliases: [
        "EnumBody"
    ],
    visitor: [
        "members"
    ],
    fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("EnumNumberBody", {
    aliases: [
        "EnumBody"
    ],
    visitor: [
        "members"
    ],
    fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("EnumStringBody", {
    aliases: [
        "EnumBody"
    ],
    visitor: [
        "members"
    ],
    fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)([
            "EnumStringMember",
            "EnumDefaultedMember"
        ]),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("EnumSymbolBody", {
    aliases: [
        "EnumBody"
    ],
    visitor: [
        "members"
    ],
    fields: {
        members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("EnumBooleanMember", {
    aliases: [
        "EnumMember"
    ],
    visitor: [
        "id"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("BooleanLiteral")
    }
});
defineType("EnumNumberMember", {
    aliases: [
        "EnumMember"
    ],
    visitor: [
        "id",
        "init"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("NumericLiteral")
    }
});
defineType("EnumStringMember", {
    aliases: [
        "EnumMember"
    ],
    visitor: [
        "id",
        "init"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("StringLiteral")
    }
});
defineType("EnumDefaultedMember", {
    aliases: [
        "EnumMember"
    ],
    visitor: [
        "id"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier")
    }
});
defineType("IndexedAccessType", {
    visitor: [
        "objectType",
        "indexType"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType")
    }
});
defineType("OptionalIndexedAccessType", {
    visitor: [
        "objectType",
        "indexType"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});

},{"./utils":"dghvW"}],"9wlps":[function(require,module,exports) {
"use strict";
var _utils = require("./utils");
const defineType = (0, _utils.defineAliasedType)("JSX");
defineType("JSXAttribute", {
    visitor: [
        "name",
        "value"
    ],
    aliases: [
        "Immutable"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
        },
        value: {
            optional: true,
            validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
        }
    }
});
defineType("JSXClosingElement", {
    visitor: [
        "name"
    ],
    aliases: [
        "Immutable"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        }
    }
});
defineType("JSXElement", {
    builder: [
        "openingElement",
        "closingElement",
        "children",
        "selfClosing"
    ],
    visitor: [
        "openingElement",
        "children",
        "closingElement"
    ],
    aliases: [
        "Immutable",
        "Expression"
    ],
    fields: {
        openingElement: {
            validate: (0, _utils.assertNodeType)("JSXOpeningElement")
        },
        closingElement: {
            optional: true,
            validate: (0, _utils.assertNodeType)("JSXClosingElement")
        },
        children: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        },
        selfClosing: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        }
    }
});
defineType("JSXEmptyExpression", {});
defineType("JSXExpressionContainer", {
    visitor: [
        "expression"
    ],
    aliases: [
        "Immutable"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
        }
    }
});
defineType("JSXSpreadChild", {
    visitor: [
        "expression"
    ],
    aliases: [
        "Immutable"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("JSXIdentifier", {
    builder: [
        "name"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertValueType)("string")
        }
    }
});
defineType("JSXMemberExpression", {
    visitor: [
        "object",
        "property"
    ],
    fields: {
        object: {
            validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
        },
        property: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
    }
});
defineType("JSXNamespacedName", {
    visitor: [
        "namespace",
        "name"
    ],
    fields: {
        namespace: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
        },
        name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
    }
});
defineType("JSXOpeningElement", {
    builder: [
        "name",
        "attributes",
        "selfClosing"
    ],
    visitor: [
        "name",
        "attributes"
    ],
    aliases: [
        "Immutable"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        },
        selfClosing: {
            default: false
        },
        attributes: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
        }
    }
});
defineType("JSXSpreadAttribute", {
    visitor: [
        "argument"
    ],
    fields: {
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("JSXText", {
    aliases: [
        "Immutable"
    ],
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    }
});
defineType("JSXFragment", {
    builder: [
        "openingFragment",
        "closingFragment",
        "children"
    ],
    visitor: [
        "openingFragment",
        "children",
        "closingFragment"
    ],
    aliases: [
        "Immutable",
        "Expression"
    ],
    fields: {
        openingFragment: {
            validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
        },
        closingFragment: {
            validate: (0, _utils.assertNodeType)("JSXClosingFragment")
        },
        children: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        }
    }
});
defineType("JSXOpeningFragment", {
    aliases: [
        "Immutable"
    ]
});
defineType("JSXClosingFragment", {
    aliases: [
        "Immutable"
    ]
});

},{"./utils":"dghvW"}],"9TUgv":[function(require,module,exports) {
"use strict";
var _utils = require("./utils");
var _placeholders = require("./placeholders");
const defineType = (0, _utils.defineAliasedType)("Miscellaneous");
defineType("Noop", {
    visitor: []
});
defineType("Placeholder", {
    visitor: [],
    builder: [
        "expectedNode",
        "name"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertNodeType)("Identifier")
        },
        expectedNode: {
            validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
        }
    }
});
defineType("V8IntrinsicIdentifier", {
    builder: [
        "name"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertValueType)("string")
        }
    }
});

},{"./utils":"dghvW","./placeholders":"jlGu5"}],"jlGu5":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;
var _utils = require("./utils");
const PLACEHOLDERS = [
    "Identifier",
    "StringLiteral",
    "Expression",
    "Statement",
    "Declaration",
    "BlockStatement",
    "ClassBody",
    "Pattern"
];
exports.PLACEHOLDERS = PLACEHOLDERS;
const PLACEHOLDERS_ALIAS = {
    Declaration: [
        "Statement"
    ],
    Pattern: [
        "PatternLike",
        "LVal"
    ]
};
exports.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;
for (const type of PLACEHOLDERS){
    const alias = _utils.ALIAS_KEYS[type];
    if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;
}
const PLACEHOLDERS_FLIPPED_ALIAS = {};
exports.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;
Object.keys(PLACEHOLDERS_ALIAS).forEach((type1)=>{
    PLACEHOLDERS_ALIAS[type1].forEach((alias)=>{
        if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
        PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type1);
    });
});

},{"./utils":"dghvW"}],"4y6d0":[function(require,module,exports) {
"use strict";
var _utils = require("./utils");
(0, _utils.default)("ArgumentPlaceholder", {});
(0, _utils.default)("BindExpression", {
    visitor: [
        "object",
        "callee"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        object: {
            validate: Object.assign(()=>{}, {
                oneOfNodeTypes: [
                    "Expression"
                ]
            })
        },
        callee: {
            validate: Object.assign(()=>{}, {
                oneOfNodeTypes: [
                    "Expression"
                ]
            })
        }
    }
});
(0, _utils.default)("ImportAttribute", {
    visitor: [
        "key",
        "value"
    ],
    fields: {
        key: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        value: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
        }
    }
});
(0, _utils.default)("Decorator", {
    visitor: [
        "expression"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
(0, _utils.default)("DoExpression", {
    visitor: [
        "body"
    ],
    builder: [
        "body",
        "async"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        async: {
            validate: (0, _utils.assertValueType)("boolean"),
            default: false
        }
    }
});
(0, _utils.default)("ExportDefaultSpecifier", {
    visitor: [
        "exported"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        exported: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
(0, _utils.default)("RecordExpression", {
    visitor: [
        "properties"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty", "SpreadElement")))
        }
    }
});
(0, _utils.default)("TupleExpression", {
    fields: {
        elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))),
            default: []
        }
    },
    visitor: [
        "elements"
    ],
    aliases: [
        "Expression"
    ]
});
(0, _utils.default)("DecimalLiteral", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    },
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
(0, _utils.default)("ModuleExpression", {
    visitor: [
        "body"
    ],
    fields: {
        body: {
            validate: (0, _utils.assertNodeType)("Program")
        }
    },
    aliases: [
        "Expression"
    ]
});
(0, _utils.default)("TopicReference", {
    aliases: [
        "Expression"
    ]
});
(0, _utils.default)("PipelineTopicExpression", {
    builder: [
        "expression"
    ],
    visitor: [
        "expression"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    aliases: [
        "Expression"
    ]
});
(0, _utils.default)("PipelineBareFunction", {
    builder: [
        "callee"
    ],
    visitor: [
        "callee"
    ],
    fields: {
        callee: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    aliases: [
        "Expression"
    ]
});
(0, _utils.default)("PipelinePrimaryTopicReference", {
    aliases: [
        "Expression"
    ]
});

},{"./utils":"dghvW"}],"ciXvA":[function(require,module,exports) {
"use strict";
var _utils = require("./utils");
var _core = require("./core");
var _is = require("../validators/is");
const defineType = (0, _utils.defineAliasedType)("TypeScript");
const bool = (0, _utils.assertValueType)("boolean");
const tSFunctionTypeAnnotationCommon = {
    returnType: {
        validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
        optional: true
    },
    typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
        optional: true
    }
};
defineType("TSParameterProperty", {
    aliases: [
        "LVal"
    ],
    visitor: [
        "parameter"
    ],
    fields: {
        accessibility: {
            validate: (0, _utils.assertOneOf)("public", "private", "protected"),
            optional: true
        },
        readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        parameter: {
            validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
        },
        override: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        }
    }
});
defineType("TSDeclareFunction", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "typeParameters",
        "params",
        "returnType"
    ],
    fields: Object.assign({}, _core.functionDeclarationCommon, tSFunctionTypeAnnotationCommon)
});
defineType("TSDeclareMethod", {
    visitor: [
        "decorators",
        "key",
        "typeParameters",
        "params",
        "returnType"
    ],
    fields: Object.assign({}, _core.classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon)
});
defineType("TSQualifiedName", {
    aliases: [
        "TSEntityName"
    ],
    visitor: [
        "left",
        "right"
    ],
    fields: {
        left: (0, _utils.validateType)("TSEntityName"),
        right: (0, _utils.validateType)("Identifier")
    }
});
const signatureDeclarationCommon = {
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, _utils.validateArrayOfType)([
        "Identifier",
        "RestElement"
    ]),
    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
};
const callConstructSignatureDeclaration = {
    aliases: [
        "TSTypeElement"
    ],
    visitor: [
        "typeParameters",
        "parameters",
        "typeAnnotation"
    ],
    fields: signatureDeclarationCommon
};
defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
const namedTypeElementCommon = {
    key: (0, _utils.validateType)("Expression"),
    computed: (0, _utils.validate)(bool),
    optional: (0, _utils.validateOptional)(bool)
};
defineType("TSPropertySignature", {
    aliases: [
        "TSTypeElement"
    ],
    visitor: [
        "key",
        "typeAnnotation",
        "initializer"
    ],
    fields: Object.assign({}, namedTypeElementCommon, {
        readonly: (0, _utils.validateOptional)(bool),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        initializer: (0, _utils.validateOptionalType)("Expression"),
        kind: {
            validate: (0, _utils.assertOneOf)("get", "set")
        }
    })
});
defineType("TSMethodSignature", {
    aliases: [
        "TSTypeElement"
    ],
    visitor: [
        "key",
        "typeParameters",
        "parameters",
        "typeAnnotation"
    ],
    fields: Object.assign({}, signatureDeclarationCommon, namedTypeElementCommon, {
        kind: {
            validate: (0, _utils.assertOneOf)("method", "get", "set")
        }
    })
});
defineType("TSIndexSignature", {
    aliases: [
        "TSTypeElement"
    ],
    visitor: [
        "parameters",
        "typeAnnotation"
    ],
    fields: {
        readonly: (0, _utils.validateOptional)(bool),
        static: (0, _utils.validateOptional)(bool),
        parameters: (0, _utils.validateArrayOfType)("Identifier"),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    }
});
const tsKeywordTypes = [
    "TSAnyKeyword",
    "TSBooleanKeyword",
    "TSBigIntKeyword",
    "TSIntrinsicKeyword",
    "TSNeverKeyword",
    "TSNullKeyword",
    "TSNumberKeyword",
    "TSObjectKeyword",
    "TSStringKeyword",
    "TSSymbolKeyword",
    "TSUndefinedKeyword",
    "TSUnknownKeyword",
    "TSVoidKeyword"
];
for (const type of tsKeywordTypes)defineType(type, {
    aliases: [
        "TSType",
        "TSBaseType"
    ],
    visitor: [],
    fields: {}
});
defineType("TSThisType", {
    aliases: [
        "TSType",
        "TSBaseType"
    ],
    visitor: [],
    fields: {}
});
const fnOrCtrBase = {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeParameters",
        "parameters",
        "typeAnnotation"
    ]
};
defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
    fields: signatureDeclarationCommon
}));
defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
    fields: Object.assign({}, signatureDeclarationCommon, {
        abstract: (0, _utils.validateOptional)(bool)
    })
}));
defineType("TSTypeReference", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeName",
        "typeParameters"
    ],
    fields: {
        typeName: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
});
defineType("TSTypePredicate", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "parameterName",
        "typeAnnotation"
    ],
    builder: [
        "parameterName",
        "typeAnnotation",
        "asserts"
    ],
    fields: {
        parameterName: (0, _utils.validateType)([
            "Identifier",
            "TSThisType"
        ]),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        asserts: (0, _utils.validateOptional)(bool)
    }
});
defineType("TSTypeQuery", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "exprName"
    ],
    fields: {
        exprName: (0, _utils.validateType)([
            "TSEntityName",
            "TSImportType"
        ])
    }
});
defineType("TSTypeLiteral", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "members"
    ],
    fields: {
        members: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
});
defineType("TSArrayType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "elementType"
    ],
    fields: {
        elementType: (0, _utils.validateType)("TSType")
    }
});
defineType("TSTupleType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "elementTypes"
    ],
    fields: {
        elementTypes: (0, _utils.validateArrayOfType)([
            "TSType",
            "TSNamedTupleMember"
        ])
    }
});
defineType("TSOptionalType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSRestType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSNamedTupleMember", {
    visitor: [
        "label",
        "elementType"
    ],
    builder: [
        "label",
        "elementType",
        "optional"
    ],
    fields: {
        label: (0, _utils.validateType)("Identifier"),
        optional: {
            validate: bool,
            default: false
        },
        elementType: (0, _utils.validateType)("TSType")
    }
});
const unionOrIntersection = {
    aliases: [
        "TSType"
    ],
    visitor: [
        "types"
    ],
    fields: {
        types: (0, _utils.validateArrayOfType)("TSType")
    }
};
defineType("TSUnionType", unionOrIntersection);
defineType("TSIntersectionType", unionOrIntersection);
defineType("TSConditionalType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "checkType",
        "extendsType",
        "trueType",
        "falseType"
    ],
    fields: {
        checkType: (0, _utils.validateType)("TSType"),
        extendsType: (0, _utils.validateType)("TSType"),
        trueType: (0, _utils.validateType)("TSType"),
        falseType: (0, _utils.validateType)("TSType")
    }
});
defineType("TSInferType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeParameter"
    ],
    fields: {
        typeParameter: (0, _utils.validateType)("TSTypeParameter")
    }
});
defineType("TSParenthesizedType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSTypeOperator", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSIndexedAccessType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "objectType",
        "indexType"
    ],
    fields: {
        objectType: (0, _utils.validateType)("TSType"),
        indexType: (0, _utils.validateType)("TSType")
    }
});
defineType("TSMappedType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeParameter",
        "typeAnnotation",
        "nameType"
    ],
    fields: {
        readonly: (0, _utils.validateOptional)(bool),
        typeParameter: (0, _utils.validateType)("TSTypeParameter"),
        optional: (0, _utils.validateOptional)(bool),
        typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
        nameType: (0, _utils.validateOptionalType)("TSType")
    }
});
defineType("TSLiteralType", {
    aliases: [
        "TSType",
        "TSBaseType"
    ],
    visitor: [
        "literal"
    ],
    fields: {
        literal: {
            validate: function() {
                const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
                const unaryOperator = (0, _utils.assertOneOf)("-");
                const literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral");
                function validator(parent, key, node) {
                    if ((0, _is.default)("UnaryExpression", node)) {
                        unaryOperator(node, "operator", node.operator);
                        unaryExpression(node, "argument", node.argument);
                    } else literal(parent, key, node);
                }
                validator.oneOfNodeTypes = [
                    "NumericLiteral",
                    "StringLiteral",
                    "BooleanLiteral",
                    "BigIntLiteral",
                    "UnaryExpression"
                ];
                return validator;
            }()
        }
    }
});
defineType("TSExpressionWithTypeArguments", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "expression",
        "typeParameters"
    ],
    fields: {
        expression: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
});
defineType("TSInterfaceDeclaration", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "typeParameters",
        "extends",
        "body"
    ],
    fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
        body: (0, _utils.validateType)("TSInterfaceBody")
    }
});
defineType("TSInterfaceBody", {
    visitor: [
        "body"
    ],
    fields: {
        body: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
});
defineType("TSTypeAliasDeclaration", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "typeParameters",
        "typeAnnotation"
    ],
    fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSAsExpression", {
    aliases: [
        "Expression"
    ],
    visitor: [
        "expression",
        "typeAnnotation"
    ],
    fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSTypeAssertion", {
    aliases: [
        "Expression"
    ],
    visitor: [
        "typeAnnotation",
        "expression"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("TSType"),
        expression: (0, _utils.validateType)("Expression")
    }
});
defineType("TSEnumDeclaration", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "members"
    ],
    fields: {
        declare: (0, _utils.validateOptional)(bool),
        const: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        members: (0, _utils.validateArrayOfType)("TSEnumMember"),
        initializer: (0, _utils.validateOptionalType)("Expression")
    }
});
defineType("TSEnumMember", {
    visitor: [
        "id",
        "initializer"
    ],
    fields: {
        id: (0, _utils.validateType)([
            "Identifier",
            "StringLiteral"
        ]),
        initializer: (0, _utils.validateOptionalType)("Expression")
    }
});
defineType("TSModuleDeclaration", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "body"
    ],
    fields: {
        declare: (0, _utils.validateOptional)(bool),
        global: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)([
            "Identifier",
            "StringLiteral"
        ]),
        body: (0, _utils.validateType)([
            "TSModuleBlock",
            "TSModuleDeclaration"
        ])
    }
});
defineType("TSModuleBlock", {
    aliases: [
        "Scopable",
        "Block",
        "BlockParent"
    ],
    visitor: [
        "body"
    ],
    fields: {
        body: (0, _utils.validateArrayOfType)("Statement")
    }
});
defineType("TSImportType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "argument",
        "qualifier",
        "typeParameters"
    ],
    fields: {
        argument: (0, _utils.validateType)("StringLiteral"),
        qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
});
defineType("TSImportEqualsDeclaration", {
    aliases: [
        "Statement"
    ],
    visitor: [
        "id",
        "moduleReference"
    ],
    fields: {
        isExport: (0, _utils.validate)(bool),
        id: (0, _utils.validateType)("Identifier"),
        moduleReference: (0, _utils.validateType)([
            "TSEntityName",
            "TSExternalModuleReference"
        ]),
        importKind: {
            validate: (0, _utils.assertOneOf)("type", "value"),
            optional: true
        }
    }
});
defineType("TSExternalModuleReference", {
    visitor: [
        "expression"
    ],
    fields: {
        expression: (0, _utils.validateType)("StringLiteral")
    }
});
defineType("TSNonNullExpression", {
    aliases: [
        "Expression"
    ],
    visitor: [
        "expression"
    ],
    fields: {
        expression: (0, _utils.validateType)("Expression")
    }
});
defineType("TSExportAssignment", {
    aliases: [
        "Statement"
    ],
    visitor: [
        "expression"
    ],
    fields: {
        expression: (0, _utils.validateType)("Expression")
    }
});
defineType("TSNamespaceExportDeclaration", {
    aliases: [
        "Statement"
    ],
    visitor: [
        "id"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier")
    }
});
defineType("TSTypeAnnotation", {
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TSType")
        }
    }
});
defineType("TSTypeParameterInstantiation", {
    visitor: [
        "params"
    ],
    fields: {
        params: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
        }
    }
});
defineType("TSTypeParameterDeclaration", {
    visitor: [
        "params"
    ],
    fields: {
        params: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
        }
    }
});
defineType("TSTypeParameter", {
    builder: [
        "constraint",
        "default",
        "name"
    ],
    visitor: [
        "constraint",
        "default"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertValueType)("string")
        },
        constraint: {
            validate: (0, _utils.assertNodeType)("TSType"),
            optional: true
        },
        default: {
            validate: (0, _utils.assertNodeType)("TSType"),
            optional: true
        }
    }
});

},{"./utils":"dghvW","./core":"9JmbX","../validators/is":"g9VKJ"}],"kwNUX":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = assertNode;
var _isNode = require("../validators/isNode");
function assertNode(node) {
    if (!(0, _isNode.default)(node)) {
        var _node$type;
        const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
        throw new TypeError(`Not a valid node of type "${type}"`);
    }
}

},{"../validators/isNode":"AMA6N"}],"AMA6N":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isNode;
var _definitions = require("../definitions");
function isNode(node) {
    return !!(node && _definitions.VISITOR_KEYS[node.type]);
}

},{"../definitions":"dzUB7"}],"jw7Eg":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
exports.assertArrayExpression = assertArrayExpression;
exports.assertArrayPattern = assertArrayPattern;
exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
exports.assertAssignmentExpression = assertAssignmentExpression;
exports.assertAssignmentPattern = assertAssignmentPattern;
exports.assertAwaitExpression = assertAwaitExpression;
exports.assertBigIntLiteral = assertBigIntLiteral;
exports.assertBinary = assertBinary;
exports.assertBinaryExpression = assertBinaryExpression;
exports.assertBindExpression = assertBindExpression;
exports.assertBlock = assertBlock;
exports.assertBlockParent = assertBlockParent;
exports.assertBlockStatement = assertBlockStatement;
exports.assertBooleanLiteral = assertBooleanLiteral;
exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
exports.assertBreakStatement = assertBreakStatement;
exports.assertCallExpression = assertCallExpression;
exports.assertCatchClause = assertCatchClause;
exports.assertClass = assertClass;
exports.assertClassBody = assertClassBody;
exports.assertClassDeclaration = assertClassDeclaration;
exports.assertClassExpression = assertClassExpression;
exports.assertClassImplements = assertClassImplements;
exports.assertClassMethod = assertClassMethod;
exports.assertClassPrivateMethod = assertClassPrivateMethod;
exports.assertClassPrivateProperty = assertClassPrivateProperty;
exports.assertClassProperty = assertClassProperty;
exports.assertCompletionStatement = assertCompletionStatement;
exports.assertConditional = assertConditional;
exports.assertConditionalExpression = assertConditionalExpression;
exports.assertContinueStatement = assertContinueStatement;
exports.assertDebuggerStatement = assertDebuggerStatement;
exports.assertDecimalLiteral = assertDecimalLiteral;
exports.assertDeclaration = assertDeclaration;
exports.assertDeclareClass = assertDeclareClass;
exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
exports.assertDeclareFunction = assertDeclareFunction;
exports.assertDeclareInterface = assertDeclareInterface;
exports.assertDeclareModule = assertDeclareModule;
exports.assertDeclareModuleExports = assertDeclareModuleExports;
exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
exports.assertDeclareVariable = assertDeclareVariable;
exports.assertDeclaredPredicate = assertDeclaredPredicate;
exports.assertDecorator = assertDecorator;
exports.assertDirective = assertDirective;
exports.assertDirectiveLiteral = assertDirectiveLiteral;
exports.assertDoExpression = assertDoExpression;
exports.assertDoWhileStatement = assertDoWhileStatement;
exports.assertEmptyStatement = assertEmptyStatement;
exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
exports.assertEnumBody = assertEnumBody;
exports.assertEnumBooleanBody = assertEnumBooleanBody;
exports.assertEnumBooleanMember = assertEnumBooleanMember;
exports.assertEnumDeclaration = assertEnumDeclaration;
exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
exports.assertEnumMember = assertEnumMember;
exports.assertEnumNumberBody = assertEnumNumberBody;
exports.assertEnumNumberMember = assertEnumNumberMember;
exports.assertEnumStringBody = assertEnumStringBody;
exports.assertEnumStringMember = assertEnumStringMember;
exports.assertEnumSymbolBody = assertEnumSymbolBody;
exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
exports.assertExportAllDeclaration = assertExportAllDeclaration;
exports.assertExportDeclaration = assertExportDeclaration;
exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
exports.assertExportSpecifier = assertExportSpecifier;
exports.assertExpression = assertExpression;
exports.assertExpressionStatement = assertExpressionStatement;
exports.assertExpressionWrapper = assertExpressionWrapper;
exports.assertFile = assertFile;
exports.assertFlow = assertFlow;
exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
exports.assertFlowDeclaration = assertFlowDeclaration;
exports.assertFlowPredicate = assertFlowPredicate;
exports.assertFlowType = assertFlowType;
exports.assertFor = assertFor;
exports.assertForInStatement = assertForInStatement;
exports.assertForOfStatement = assertForOfStatement;
exports.assertForStatement = assertForStatement;
exports.assertForXStatement = assertForXStatement;
exports.assertFunction = assertFunction;
exports.assertFunctionDeclaration = assertFunctionDeclaration;
exports.assertFunctionExpression = assertFunctionExpression;
exports.assertFunctionParent = assertFunctionParent;
exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
exports.assertFunctionTypeParam = assertFunctionTypeParam;
exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
exports.assertIdentifier = assertIdentifier;
exports.assertIfStatement = assertIfStatement;
exports.assertImmutable = assertImmutable;
exports.assertImport = assertImport;
exports.assertImportAttribute = assertImportAttribute;
exports.assertImportDeclaration = assertImportDeclaration;
exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
exports.assertImportSpecifier = assertImportSpecifier;
exports.assertIndexedAccessType = assertIndexedAccessType;
exports.assertInferredPredicate = assertInferredPredicate;
exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
exports.assertInterfaceExtends = assertInterfaceExtends;
exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
exports.assertInterpreterDirective = assertInterpreterDirective;
exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
exports.assertJSX = assertJSX;
exports.assertJSXAttribute = assertJSXAttribute;
exports.assertJSXClosingElement = assertJSXClosingElement;
exports.assertJSXClosingFragment = assertJSXClosingFragment;
exports.assertJSXElement = assertJSXElement;
exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
exports.assertJSXFragment = assertJSXFragment;
exports.assertJSXIdentifier = assertJSXIdentifier;
exports.assertJSXMemberExpression = assertJSXMemberExpression;
exports.assertJSXNamespacedName = assertJSXNamespacedName;
exports.assertJSXOpeningElement = assertJSXOpeningElement;
exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
exports.assertJSXSpreadChild = assertJSXSpreadChild;
exports.assertJSXText = assertJSXText;
exports.assertLVal = assertLVal;
exports.assertLabeledStatement = assertLabeledStatement;
exports.assertLiteral = assertLiteral;
exports.assertLogicalExpression = assertLogicalExpression;
exports.assertLoop = assertLoop;
exports.assertMemberExpression = assertMemberExpression;
exports.assertMetaProperty = assertMetaProperty;
exports.assertMethod = assertMethod;
exports.assertMiscellaneous = assertMiscellaneous;
exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
exports.assertModuleDeclaration = assertModuleDeclaration;
exports.assertModuleExpression = assertModuleExpression;
exports.assertModuleSpecifier = assertModuleSpecifier;
exports.assertNewExpression = assertNewExpression;
exports.assertNoop = assertNoop;
exports.assertNullLiteral = assertNullLiteral;
exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
exports.assertNumberLiteral = assertNumberLiteral;
exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
exports.assertNumericLiteral = assertNumericLiteral;
exports.assertObjectExpression = assertObjectExpression;
exports.assertObjectMember = assertObjectMember;
exports.assertObjectMethod = assertObjectMethod;
exports.assertObjectPattern = assertObjectPattern;
exports.assertObjectProperty = assertObjectProperty;
exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
exports.assertObjectTypeProperty = assertObjectTypeProperty;
exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
exports.assertOpaqueType = assertOpaqueType;
exports.assertOptionalCallExpression = assertOptionalCallExpression;
exports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
exports.assertParenthesizedExpression = assertParenthesizedExpression;
exports.assertPattern = assertPattern;
exports.assertPatternLike = assertPatternLike;
exports.assertPipelineBareFunction = assertPipelineBareFunction;
exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
exports.assertPlaceholder = assertPlaceholder;
exports.assertPrivate = assertPrivate;
exports.assertPrivateName = assertPrivateName;
exports.assertProgram = assertProgram;
exports.assertProperty = assertProperty;
exports.assertPureish = assertPureish;
exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
exports.assertRecordExpression = assertRecordExpression;
exports.assertRegExpLiteral = assertRegExpLiteral;
exports.assertRegexLiteral = assertRegexLiteral;
exports.assertRestElement = assertRestElement;
exports.assertRestProperty = assertRestProperty;
exports.assertReturnStatement = assertReturnStatement;
exports.assertScopable = assertScopable;
exports.assertSequenceExpression = assertSequenceExpression;
exports.assertSpreadElement = assertSpreadElement;
exports.assertSpreadProperty = assertSpreadProperty;
exports.assertStandardized = assertStandardized;
exports.assertStatement = assertStatement;
exports.assertStaticBlock = assertStaticBlock;
exports.assertStringLiteral = assertStringLiteral;
exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
exports.assertSuper = assertSuper;
exports.assertSwitchCase = assertSwitchCase;
exports.assertSwitchStatement = assertSwitchStatement;
exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
exports.assertTSAnyKeyword = assertTSAnyKeyword;
exports.assertTSArrayType = assertTSArrayType;
exports.assertTSAsExpression = assertTSAsExpression;
exports.assertTSBaseType = assertTSBaseType;
exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
exports.assertTSConditionalType = assertTSConditionalType;
exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
exports.assertTSConstructorType = assertTSConstructorType;
exports.assertTSDeclareFunction = assertTSDeclareFunction;
exports.assertTSDeclareMethod = assertTSDeclareMethod;
exports.assertTSEntityName = assertTSEntityName;
exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
exports.assertTSEnumMember = assertTSEnumMember;
exports.assertTSExportAssignment = assertTSExportAssignment;
exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
exports.assertTSFunctionType = assertTSFunctionType;
exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
exports.assertTSImportType = assertTSImportType;
exports.assertTSIndexSignature = assertTSIndexSignature;
exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
exports.assertTSInferType = assertTSInferType;
exports.assertTSInterfaceBody = assertTSInterfaceBody;
exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
exports.assertTSIntersectionType = assertTSIntersectionType;
exports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
exports.assertTSLiteralType = assertTSLiteralType;
exports.assertTSMappedType = assertTSMappedType;
exports.assertTSMethodSignature = assertTSMethodSignature;
exports.assertTSModuleBlock = assertTSModuleBlock;
exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
exports.assertTSNamedTupleMember = assertTSNamedTupleMember;
exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
exports.assertTSNeverKeyword = assertTSNeverKeyword;
exports.assertTSNonNullExpression = assertTSNonNullExpression;
exports.assertTSNullKeyword = assertTSNullKeyword;
exports.assertTSNumberKeyword = assertTSNumberKeyword;
exports.assertTSObjectKeyword = assertTSObjectKeyword;
exports.assertTSOptionalType = assertTSOptionalType;
exports.assertTSParameterProperty = assertTSParameterProperty;
exports.assertTSParenthesizedType = assertTSParenthesizedType;
exports.assertTSPropertySignature = assertTSPropertySignature;
exports.assertTSQualifiedName = assertTSQualifiedName;
exports.assertTSRestType = assertTSRestType;
exports.assertTSStringKeyword = assertTSStringKeyword;
exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
exports.assertTSThisType = assertTSThisType;
exports.assertTSTupleType = assertTSTupleType;
exports.assertTSType = assertTSType;
exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
exports.assertTSTypeAssertion = assertTSTypeAssertion;
exports.assertTSTypeElement = assertTSTypeElement;
exports.assertTSTypeLiteral = assertTSTypeLiteral;
exports.assertTSTypeOperator = assertTSTypeOperator;
exports.assertTSTypeParameter = assertTSTypeParameter;
exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
exports.assertTSTypePredicate = assertTSTypePredicate;
exports.assertTSTypeQuery = assertTSTypeQuery;
exports.assertTSTypeReference = assertTSTypeReference;
exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
exports.assertTSUnionType = assertTSUnionType;
exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
exports.assertTSVoidKeyword = assertTSVoidKeyword;
exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
exports.assertTemplateElement = assertTemplateElement;
exports.assertTemplateLiteral = assertTemplateLiteral;
exports.assertTerminatorless = assertTerminatorless;
exports.assertThisExpression = assertThisExpression;
exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
exports.assertThrowStatement = assertThrowStatement;
exports.assertTopicReference = assertTopicReference;
exports.assertTryStatement = assertTryStatement;
exports.assertTupleExpression = assertTupleExpression;
exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
exports.assertTypeAlias = assertTypeAlias;
exports.assertTypeAnnotation = assertTypeAnnotation;
exports.assertTypeCastExpression = assertTypeCastExpression;
exports.assertTypeParameter = assertTypeParameter;
exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
exports.assertTypeScript = assertTypeScript;
exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
exports.assertUnaryExpression = assertUnaryExpression;
exports.assertUnaryLike = assertUnaryLike;
exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
exports.assertUpdateExpression = assertUpdateExpression;
exports.assertUserWhitespacable = assertUserWhitespacable;
exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
exports.assertVariableDeclaration = assertVariableDeclaration;
exports.assertVariableDeclarator = assertVariableDeclarator;
exports.assertVariance = assertVariance;
exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
exports.assertWhile = assertWhile;
exports.assertWhileStatement = assertWhileStatement;
exports.assertWithStatement = assertWithStatement;
exports.assertYieldExpression = assertYieldExpression;
var _is = require("../../validators/is");
function assert(type, node, opts) {
    if (!(0, _is.default)(type, node, opts)) throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, ` + `but instead got "${node.type}".`);
}
function assertArrayExpression(node, opts) {
    assert("ArrayExpression", node, opts);
}
function assertAssignmentExpression(node, opts) {
    assert("AssignmentExpression", node, opts);
}
function assertBinaryExpression(node, opts) {
    assert("BinaryExpression", node, opts);
}
function assertInterpreterDirective(node, opts) {
    assert("InterpreterDirective", node, opts);
}
function assertDirective(node, opts) {
    assert("Directive", node, opts);
}
function assertDirectiveLiteral(node, opts) {
    assert("DirectiveLiteral", node, opts);
}
function assertBlockStatement(node, opts) {
    assert("BlockStatement", node, opts);
}
function assertBreakStatement(node, opts) {
    assert("BreakStatement", node, opts);
}
function assertCallExpression(node, opts) {
    assert("CallExpression", node, opts);
}
function assertCatchClause(node, opts) {
    assert("CatchClause", node, opts);
}
function assertConditionalExpression(node, opts) {
    assert("ConditionalExpression", node, opts);
}
function assertContinueStatement(node, opts) {
    assert("ContinueStatement", node, opts);
}
function assertDebuggerStatement(node, opts) {
    assert("DebuggerStatement", node, opts);
}
function assertDoWhileStatement(node, opts) {
    assert("DoWhileStatement", node, opts);
}
function assertEmptyStatement(node, opts) {
    assert("EmptyStatement", node, opts);
}
function assertExpressionStatement(node, opts) {
    assert("ExpressionStatement", node, opts);
}
function assertFile(node, opts) {
    assert("File", node, opts);
}
function assertForInStatement(node, opts) {
    assert("ForInStatement", node, opts);
}
function assertForStatement(node, opts) {
    assert("ForStatement", node, opts);
}
function assertFunctionDeclaration(node, opts) {
    assert("FunctionDeclaration", node, opts);
}
function assertFunctionExpression(node, opts) {
    assert("FunctionExpression", node, opts);
}
function assertIdentifier(node, opts) {
    assert("Identifier", node, opts);
}
function assertIfStatement(node, opts) {
    assert("IfStatement", node, opts);
}
function assertLabeledStatement(node, opts) {
    assert("LabeledStatement", node, opts);
}
function assertStringLiteral(node, opts) {
    assert("StringLiteral", node, opts);
}
function assertNumericLiteral(node, opts) {
    assert("NumericLiteral", node, opts);
}
function assertNullLiteral(node, opts) {
    assert("NullLiteral", node, opts);
}
function assertBooleanLiteral(node, opts) {
    assert("BooleanLiteral", node, opts);
}
function assertRegExpLiteral(node, opts) {
    assert("RegExpLiteral", node, opts);
}
function assertLogicalExpression(node, opts) {
    assert("LogicalExpression", node, opts);
}
function assertMemberExpression(node, opts) {
    assert("MemberExpression", node, opts);
}
function assertNewExpression(node, opts) {
    assert("NewExpression", node, opts);
}
function assertProgram(node, opts) {
    assert("Program", node, opts);
}
function assertObjectExpression(node, opts) {
    assert("ObjectExpression", node, opts);
}
function assertObjectMethod(node, opts) {
    assert("ObjectMethod", node, opts);
}
function assertObjectProperty(node, opts) {
    assert("ObjectProperty", node, opts);
}
function assertRestElement(node, opts) {
    assert("RestElement", node, opts);
}
function assertReturnStatement(node, opts) {
    assert("ReturnStatement", node, opts);
}
function assertSequenceExpression(node, opts) {
    assert("SequenceExpression", node, opts);
}
function assertParenthesizedExpression(node, opts) {
    assert("ParenthesizedExpression", node, opts);
}
function assertSwitchCase(node, opts) {
    assert("SwitchCase", node, opts);
}
function assertSwitchStatement(node, opts) {
    assert("SwitchStatement", node, opts);
}
function assertThisExpression(node, opts) {
    assert("ThisExpression", node, opts);
}
function assertThrowStatement(node, opts) {
    assert("ThrowStatement", node, opts);
}
function assertTryStatement(node, opts) {
    assert("TryStatement", node, opts);
}
function assertUnaryExpression(node, opts) {
    assert("UnaryExpression", node, opts);
}
function assertUpdateExpression(node, opts) {
    assert("UpdateExpression", node, opts);
}
function assertVariableDeclaration(node, opts) {
    assert("VariableDeclaration", node, opts);
}
function assertVariableDeclarator(node, opts) {
    assert("VariableDeclarator", node, opts);
}
function assertWhileStatement(node, opts) {
    assert("WhileStatement", node, opts);
}
function assertWithStatement(node, opts) {
    assert("WithStatement", node, opts);
}
function assertAssignmentPattern(node, opts) {
    assert("AssignmentPattern", node, opts);
}
function assertArrayPattern(node, opts) {
    assert("ArrayPattern", node, opts);
}
function assertArrowFunctionExpression(node, opts) {
    assert("ArrowFunctionExpression", node, opts);
}
function assertClassBody(node, opts) {
    assert("ClassBody", node, opts);
}
function assertClassExpression(node, opts) {
    assert("ClassExpression", node, opts);
}
function assertClassDeclaration(node, opts) {
    assert("ClassDeclaration", node, opts);
}
function assertExportAllDeclaration(node, opts) {
    assert("ExportAllDeclaration", node, opts);
}
function assertExportDefaultDeclaration(node, opts) {
    assert("ExportDefaultDeclaration", node, opts);
}
function assertExportNamedDeclaration(node, opts) {
    assert("ExportNamedDeclaration", node, opts);
}
function assertExportSpecifier(node, opts) {
    assert("ExportSpecifier", node, opts);
}
function assertForOfStatement(node, opts) {
    assert("ForOfStatement", node, opts);
}
function assertImportDeclaration(node, opts) {
    assert("ImportDeclaration", node, opts);
}
function assertImportDefaultSpecifier(node, opts) {
    assert("ImportDefaultSpecifier", node, opts);
}
function assertImportNamespaceSpecifier(node, opts) {
    assert("ImportNamespaceSpecifier", node, opts);
}
function assertImportSpecifier(node, opts) {
    assert("ImportSpecifier", node, opts);
}
function assertMetaProperty(node, opts) {
    assert("MetaProperty", node, opts);
}
function assertClassMethod(node, opts) {
    assert("ClassMethod", node, opts);
}
function assertObjectPattern(node, opts) {
    assert("ObjectPattern", node, opts);
}
function assertSpreadElement(node, opts) {
    assert("SpreadElement", node, opts);
}
function assertSuper(node, opts) {
    assert("Super", node, opts);
}
function assertTaggedTemplateExpression(node, opts) {
    assert("TaggedTemplateExpression", node, opts);
}
function assertTemplateElement(node, opts) {
    assert("TemplateElement", node, opts);
}
function assertTemplateLiteral(node, opts) {
    assert("TemplateLiteral", node, opts);
}
function assertYieldExpression(node, opts) {
    assert("YieldExpression", node, opts);
}
function assertAwaitExpression(node, opts) {
    assert("AwaitExpression", node, opts);
}
function assertImport(node, opts) {
    assert("Import", node, opts);
}
function assertBigIntLiteral(node, opts) {
    assert("BigIntLiteral", node, opts);
}
function assertExportNamespaceSpecifier(node, opts) {
    assert("ExportNamespaceSpecifier", node, opts);
}
function assertOptionalMemberExpression(node, opts) {
    assert("OptionalMemberExpression", node, opts);
}
function assertOptionalCallExpression(node, opts) {
    assert("OptionalCallExpression", node, opts);
}
function assertClassProperty(node, opts) {
    assert("ClassProperty", node, opts);
}
function assertClassPrivateProperty(node, opts) {
    assert("ClassPrivateProperty", node, opts);
}
function assertClassPrivateMethod(node, opts) {
    assert("ClassPrivateMethod", node, opts);
}
function assertPrivateName(node, opts) {
    assert("PrivateName", node, opts);
}
function assertStaticBlock(node, opts) {
    assert("StaticBlock", node, opts);
}
function assertAnyTypeAnnotation(node, opts) {
    assert("AnyTypeAnnotation", node, opts);
}
function assertArrayTypeAnnotation(node, opts) {
    assert("ArrayTypeAnnotation", node, opts);
}
function assertBooleanTypeAnnotation(node, opts) {
    assert("BooleanTypeAnnotation", node, opts);
}
function assertBooleanLiteralTypeAnnotation(node, opts) {
    assert("BooleanLiteralTypeAnnotation", node, opts);
}
function assertNullLiteralTypeAnnotation(node, opts) {
    assert("NullLiteralTypeAnnotation", node, opts);
}
function assertClassImplements(node, opts) {
    assert("ClassImplements", node, opts);
}
function assertDeclareClass(node, opts) {
    assert("DeclareClass", node, opts);
}
function assertDeclareFunction(node, opts) {
    assert("DeclareFunction", node, opts);
}
function assertDeclareInterface(node, opts) {
    assert("DeclareInterface", node, opts);
}
function assertDeclareModule(node, opts) {
    assert("DeclareModule", node, opts);
}
function assertDeclareModuleExports(node, opts) {
    assert("DeclareModuleExports", node, opts);
}
function assertDeclareTypeAlias(node, opts) {
    assert("DeclareTypeAlias", node, opts);
}
function assertDeclareOpaqueType(node, opts) {
    assert("DeclareOpaqueType", node, opts);
}
function assertDeclareVariable(node, opts) {
    assert("DeclareVariable", node, opts);
}
function assertDeclareExportDeclaration(node, opts) {
    assert("DeclareExportDeclaration", node, opts);
}
function assertDeclareExportAllDeclaration(node, opts) {
    assert("DeclareExportAllDeclaration", node, opts);
}
function assertDeclaredPredicate(node, opts) {
    assert("DeclaredPredicate", node, opts);
}
function assertExistsTypeAnnotation(node, opts) {
    assert("ExistsTypeAnnotation", node, opts);
}
function assertFunctionTypeAnnotation(node, opts) {
    assert("FunctionTypeAnnotation", node, opts);
}
function assertFunctionTypeParam(node, opts) {
    assert("FunctionTypeParam", node, opts);
}
function assertGenericTypeAnnotation(node, opts) {
    assert("GenericTypeAnnotation", node, opts);
}
function assertInferredPredicate(node, opts) {
    assert("InferredPredicate", node, opts);
}
function assertInterfaceExtends(node, opts) {
    assert("InterfaceExtends", node, opts);
}
function assertInterfaceDeclaration(node, opts) {
    assert("InterfaceDeclaration", node, opts);
}
function assertInterfaceTypeAnnotation(node, opts) {
    assert("InterfaceTypeAnnotation", node, opts);
}
function assertIntersectionTypeAnnotation(node, opts) {
    assert("IntersectionTypeAnnotation", node, opts);
}
function assertMixedTypeAnnotation(node, opts) {
    assert("MixedTypeAnnotation", node, opts);
}
function assertEmptyTypeAnnotation(node, opts) {
    assert("EmptyTypeAnnotation", node, opts);
}
function assertNullableTypeAnnotation(node, opts) {
    assert("NullableTypeAnnotation", node, opts);
}
function assertNumberLiteralTypeAnnotation(node, opts) {
    assert("NumberLiteralTypeAnnotation", node, opts);
}
function assertNumberTypeAnnotation(node, opts) {
    assert("NumberTypeAnnotation", node, opts);
}
function assertObjectTypeAnnotation(node, opts) {
    assert("ObjectTypeAnnotation", node, opts);
}
function assertObjectTypeInternalSlot(node, opts) {
    assert("ObjectTypeInternalSlot", node, opts);
}
function assertObjectTypeCallProperty(node, opts) {
    assert("ObjectTypeCallProperty", node, opts);
}
function assertObjectTypeIndexer(node, opts) {
    assert("ObjectTypeIndexer", node, opts);
}
function assertObjectTypeProperty(node, opts) {
    assert("ObjectTypeProperty", node, opts);
}
function assertObjectTypeSpreadProperty(node, opts) {
    assert("ObjectTypeSpreadProperty", node, opts);
}
function assertOpaqueType(node, opts) {
    assert("OpaqueType", node, opts);
}
function assertQualifiedTypeIdentifier(node, opts) {
    assert("QualifiedTypeIdentifier", node, opts);
}
function assertStringLiteralTypeAnnotation(node, opts) {
    assert("StringLiteralTypeAnnotation", node, opts);
}
function assertStringTypeAnnotation(node, opts) {
    assert("StringTypeAnnotation", node, opts);
}
function assertSymbolTypeAnnotation(node, opts) {
    assert("SymbolTypeAnnotation", node, opts);
}
function assertThisTypeAnnotation(node, opts) {
    assert("ThisTypeAnnotation", node, opts);
}
function assertTupleTypeAnnotation(node, opts) {
    assert("TupleTypeAnnotation", node, opts);
}
function assertTypeofTypeAnnotation(node, opts) {
    assert("TypeofTypeAnnotation", node, opts);
}
function assertTypeAlias(node, opts) {
    assert("TypeAlias", node, opts);
}
function assertTypeAnnotation(node, opts) {
    assert("TypeAnnotation", node, opts);
}
function assertTypeCastExpression(node, opts) {
    assert("TypeCastExpression", node, opts);
}
function assertTypeParameter(node, opts) {
    assert("TypeParameter", node, opts);
}
function assertTypeParameterDeclaration(node, opts) {
    assert("TypeParameterDeclaration", node, opts);
}
function assertTypeParameterInstantiation(node, opts) {
    assert("TypeParameterInstantiation", node, opts);
}
function assertUnionTypeAnnotation(node, opts) {
    assert("UnionTypeAnnotation", node, opts);
}
function assertVariance(node, opts) {
    assert("Variance", node, opts);
}
function assertVoidTypeAnnotation(node, opts) {
    assert("VoidTypeAnnotation", node, opts);
}
function assertEnumDeclaration(node, opts) {
    assert("EnumDeclaration", node, opts);
}
function assertEnumBooleanBody(node, opts) {
    assert("EnumBooleanBody", node, opts);
}
function assertEnumNumberBody(node, opts) {
    assert("EnumNumberBody", node, opts);
}
function assertEnumStringBody(node, opts) {
    assert("EnumStringBody", node, opts);
}
function assertEnumSymbolBody(node, opts) {
    assert("EnumSymbolBody", node, opts);
}
function assertEnumBooleanMember(node, opts) {
    assert("EnumBooleanMember", node, opts);
}
function assertEnumNumberMember(node, opts) {
    assert("EnumNumberMember", node, opts);
}
function assertEnumStringMember(node, opts) {
    assert("EnumStringMember", node, opts);
}
function assertEnumDefaultedMember(node, opts) {
    assert("EnumDefaultedMember", node, opts);
}
function assertIndexedAccessType(node, opts) {
    assert("IndexedAccessType", node, opts);
}
function assertOptionalIndexedAccessType(node, opts) {
    assert("OptionalIndexedAccessType", node, opts);
}
function assertJSXAttribute(node, opts) {
    assert("JSXAttribute", node, opts);
}
function assertJSXClosingElement(node, opts) {
    assert("JSXClosingElement", node, opts);
}
function assertJSXElement(node, opts) {
    assert("JSXElement", node, opts);
}
function assertJSXEmptyExpression(node, opts) {
    assert("JSXEmptyExpression", node, opts);
}
function assertJSXExpressionContainer(node, opts) {
    assert("JSXExpressionContainer", node, opts);
}
function assertJSXSpreadChild(node, opts) {
    assert("JSXSpreadChild", node, opts);
}
function assertJSXIdentifier(node, opts) {
    assert("JSXIdentifier", node, opts);
}
function assertJSXMemberExpression(node, opts) {
    assert("JSXMemberExpression", node, opts);
}
function assertJSXNamespacedName(node, opts) {
    assert("JSXNamespacedName", node, opts);
}
function assertJSXOpeningElement(node, opts) {
    assert("JSXOpeningElement", node, opts);
}
function assertJSXSpreadAttribute(node, opts) {
    assert("JSXSpreadAttribute", node, opts);
}
function assertJSXText(node, opts) {
    assert("JSXText", node, opts);
}
function assertJSXFragment(node, opts) {
    assert("JSXFragment", node, opts);
}
function assertJSXOpeningFragment(node, opts) {
    assert("JSXOpeningFragment", node, opts);
}
function assertJSXClosingFragment(node, opts) {
    assert("JSXClosingFragment", node, opts);
}
function assertNoop(node, opts) {
    assert("Noop", node, opts);
}
function assertPlaceholder(node, opts) {
    assert("Placeholder", node, opts);
}
function assertV8IntrinsicIdentifier(node, opts) {
    assert("V8IntrinsicIdentifier", node, opts);
}
function assertArgumentPlaceholder(node, opts) {
    assert("ArgumentPlaceholder", node, opts);
}
function assertBindExpression(node, opts) {
    assert("BindExpression", node, opts);
}
function assertImportAttribute(node, opts) {
    assert("ImportAttribute", node, opts);
}
function assertDecorator(node, opts) {
    assert("Decorator", node, opts);
}
function assertDoExpression(node, opts) {
    assert("DoExpression", node, opts);
}
function assertExportDefaultSpecifier(node, opts) {
    assert("ExportDefaultSpecifier", node, opts);
}
function assertRecordExpression(node, opts) {
    assert("RecordExpression", node, opts);
}
function assertTupleExpression(node, opts) {
    assert("TupleExpression", node, opts);
}
function assertDecimalLiteral(node, opts) {
    assert("DecimalLiteral", node, opts);
}
function assertModuleExpression(node, opts) {
    assert("ModuleExpression", node, opts);
}
function assertTopicReference(node, opts) {
    assert("TopicReference", node, opts);
}
function assertPipelineTopicExpression(node, opts) {
    assert("PipelineTopicExpression", node, opts);
}
function assertPipelineBareFunction(node, opts) {
    assert("PipelineBareFunction", node, opts);
}
function assertPipelinePrimaryTopicReference(node, opts) {
    assert("PipelinePrimaryTopicReference", node, opts);
}
function assertTSParameterProperty(node, opts) {
    assert("TSParameterProperty", node, opts);
}
function assertTSDeclareFunction(node, opts) {
    assert("TSDeclareFunction", node, opts);
}
function assertTSDeclareMethod(node, opts) {
    assert("TSDeclareMethod", node, opts);
}
function assertTSQualifiedName(node, opts) {
    assert("TSQualifiedName", node, opts);
}
function assertTSCallSignatureDeclaration(node, opts) {
    assert("TSCallSignatureDeclaration", node, opts);
}
function assertTSConstructSignatureDeclaration(node, opts) {
    assert("TSConstructSignatureDeclaration", node, opts);
}
function assertTSPropertySignature(node, opts) {
    assert("TSPropertySignature", node, opts);
}
function assertTSMethodSignature(node, opts) {
    assert("TSMethodSignature", node, opts);
}
function assertTSIndexSignature(node, opts) {
    assert("TSIndexSignature", node, opts);
}
function assertTSAnyKeyword(node, opts) {
    assert("TSAnyKeyword", node, opts);
}
function assertTSBooleanKeyword(node, opts) {
    assert("TSBooleanKeyword", node, opts);
}
function assertTSBigIntKeyword(node, opts) {
    assert("TSBigIntKeyword", node, opts);
}
function assertTSIntrinsicKeyword(node, opts) {
    assert("TSIntrinsicKeyword", node, opts);
}
function assertTSNeverKeyword(node, opts) {
    assert("TSNeverKeyword", node, opts);
}
function assertTSNullKeyword(node, opts) {
    assert("TSNullKeyword", node, opts);
}
function assertTSNumberKeyword(node, opts) {
    assert("TSNumberKeyword", node, opts);
}
function assertTSObjectKeyword(node, opts) {
    assert("TSObjectKeyword", node, opts);
}
function assertTSStringKeyword(node, opts) {
    assert("TSStringKeyword", node, opts);
}
function assertTSSymbolKeyword(node, opts) {
    assert("TSSymbolKeyword", node, opts);
}
function assertTSUndefinedKeyword(node, opts) {
    assert("TSUndefinedKeyword", node, opts);
}
function assertTSUnknownKeyword(node, opts) {
    assert("TSUnknownKeyword", node, opts);
}
function assertTSVoidKeyword(node, opts) {
    assert("TSVoidKeyword", node, opts);
}
function assertTSThisType(node, opts) {
    assert("TSThisType", node, opts);
}
function assertTSFunctionType(node, opts) {
    assert("TSFunctionType", node, opts);
}
function assertTSConstructorType(node, opts) {
    assert("TSConstructorType", node, opts);
}
function assertTSTypeReference(node, opts) {
    assert("TSTypeReference", node, opts);
}
function assertTSTypePredicate(node, opts) {
    assert("TSTypePredicate", node, opts);
}
function assertTSTypeQuery(node, opts) {
    assert("TSTypeQuery", node, opts);
}
function assertTSTypeLiteral(node, opts) {
    assert("TSTypeLiteral", node, opts);
}
function assertTSArrayType(node, opts) {
    assert("TSArrayType", node, opts);
}
function assertTSTupleType(node, opts) {
    assert("TSTupleType", node, opts);
}
function assertTSOptionalType(node, opts) {
    assert("TSOptionalType", node, opts);
}
function assertTSRestType(node, opts) {
    assert("TSRestType", node, opts);
}
function assertTSNamedTupleMember(node, opts) {
    assert("TSNamedTupleMember", node, opts);
}
function assertTSUnionType(node, opts) {
    assert("TSUnionType", node, opts);
}
function assertTSIntersectionType(node, opts) {
    assert("TSIntersectionType", node, opts);
}
function assertTSConditionalType(node, opts) {
    assert("TSConditionalType", node, opts);
}
function assertTSInferType(node, opts) {
    assert("TSInferType", node, opts);
}
function assertTSParenthesizedType(node, opts) {
    assert("TSParenthesizedType", node, opts);
}
function assertTSTypeOperator(node, opts) {
    assert("TSTypeOperator", node, opts);
}
function assertTSIndexedAccessType(node, opts) {
    assert("TSIndexedAccessType", node, opts);
}
function assertTSMappedType(node, opts) {
    assert("TSMappedType", node, opts);
}
function assertTSLiteralType(node, opts) {
    assert("TSLiteralType", node, opts);
}
function assertTSExpressionWithTypeArguments(node, opts) {
    assert("TSExpressionWithTypeArguments", node, opts);
}
function assertTSInterfaceDeclaration(node, opts) {
    assert("TSInterfaceDeclaration", node, opts);
}
function assertTSInterfaceBody(node, opts) {
    assert("TSInterfaceBody", node, opts);
}
function assertTSTypeAliasDeclaration(node, opts) {
    assert("TSTypeAliasDeclaration", node, opts);
}
function assertTSAsExpression(node, opts) {
    assert("TSAsExpression", node, opts);
}
function assertTSTypeAssertion(node, opts) {
    assert("TSTypeAssertion", node, opts);
}
function assertTSEnumDeclaration(node, opts) {
    assert("TSEnumDeclaration", node, opts);
}
function assertTSEnumMember(node, opts) {
    assert("TSEnumMember", node, opts);
}
function assertTSModuleDeclaration(node, opts) {
    assert("TSModuleDeclaration", node, opts);
}
function assertTSModuleBlock(node, opts) {
    assert("TSModuleBlock", node, opts);
}
function assertTSImportType(node, opts) {
    assert("TSImportType", node, opts);
}
function assertTSImportEqualsDeclaration(node, opts) {
    assert("TSImportEqualsDeclaration", node, opts);
}
function assertTSExternalModuleReference(node, opts) {
    assert("TSExternalModuleReference", node, opts);
}
function assertTSNonNullExpression(node, opts) {
    assert("TSNonNullExpression", node, opts);
}
function assertTSExportAssignment(node, opts) {
    assert("TSExportAssignment", node, opts);
}
function assertTSNamespaceExportDeclaration(node, opts) {
    assert("TSNamespaceExportDeclaration", node, opts);
}
function assertTSTypeAnnotation(node, opts) {
    assert("TSTypeAnnotation", node, opts);
}
function assertTSTypeParameterInstantiation(node, opts) {
    assert("TSTypeParameterInstantiation", node, opts);
}
function assertTSTypeParameterDeclaration(node, opts) {
    assert("TSTypeParameterDeclaration", node, opts);
}
function assertTSTypeParameter(node, opts) {
    assert("TSTypeParameter", node, opts);
}
function assertStandardized(node, opts) {
    assert("Standardized", node, opts);
}
function assertExpression(node, opts) {
    assert("Expression", node, opts);
}
function assertBinary(node, opts) {
    assert("Binary", node, opts);
}
function assertScopable(node, opts) {
    assert("Scopable", node, opts);
}
function assertBlockParent(node, opts) {
    assert("BlockParent", node, opts);
}
function assertBlock(node, opts) {
    assert("Block", node, opts);
}
function assertStatement(node, opts) {
    assert("Statement", node, opts);
}
function assertTerminatorless(node, opts) {
    assert("Terminatorless", node, opts);
}
function assertCompletionStatement(node, opts) {
    assert("CompletionStatement", node, opts);
}
function assertConditional(node, opts) {
    assert("Conditional", node, opts);
}
function assertLoop(node, opts) {
    assert("Loop", node, opts);
}
function assertWhile(node, opts) {
    assert("While", node, opts);
}
function assertExpressionWrapper(node, opts) {
    assert("ExpressionWrapper", node, opts);
}
function assertFor(node, opts) {
    assert("For", node, opts);
}
function assertForXStatement(node, opts) {
    assert("ForXStatement", node, opts);
}
function assertFunction(node, opts) {
    assert("Function", node, opts);
}
function assertFunctionParent(node, opts) {
    assert("FunctionParent", node, opts);
}
function assertPureish(node, opts) {
    assert("Pureish", node, opts);
}
function assertDeclaration(node, opts) {
    assert("Declaration", node, opts);
}
function assertPatternLike(node, opts) {
    assert("PatternLike", node, opts);
}
function assertLVal(node, opts) {
    assert("LVal", node, opts);
}
function assertTSEntityName(node, opts) {
    assert("TSEntityName", node, opts);
}
function assertLiteral(node, opts) {
    assert("Literal", node, opts);
}
function assertImmutable(node, opts) {
    assert("Immutable", node, opts);
}
function assertUserWhitespacable(node, opts) {
    assert("UserWhitespacable", node, opts);
}
function assertMethod(node, opts) {
    assert("Method", node, opts);
}
function assertObjectMember(node, opts) {
    assert("ObjectMember", node, opts);
}
function assertProperty(node, opts) {
    assert("Property", node, opts);
}
function assertUnaryLike(node, opts) {
    assert("UnaryLike", node, opts);
}
function assertPattern(node, opts) {
    assert("Pattern", node, opts);
}
function assertClass(node, opts) {
    assert("Class", node, opts);
}
function assertModuleDeclaration(node, opts) {
    assert("ModuleDeclaration", node, opts);
}
function assertExportDeclaration(node, opts) {
    assert("ExportDeclaration", node, opts);
}
function assertModuleSpecifier(node, opts) {
    assert("ModuleSpecifier", node, opts);
}
function assertPrivate(node, opts) {
    assert("Private", node, opts);
}
function assertFlow(node, opts) {
    assert("Flow", node, opts);
}
function assertFlowType(node, opts) {
    assert("FlowType", node, opts);
}
function assertFlowBaseAnnotation(node, opts) {
    assert("FlowBaseAnnotation", node, opts);
}
function assertFlowDeclaration(node, opts) {
    assert("FlowDeclaration", node, opts);
}
function assertFlowPredicate(node, opts) {
    assert("FlowPredicate", node, opts);
}
function assertEnumBody(node, opts) {
    assert("EnumBody", node, opts);
}
function assertEnumMember(node, opts) {
    assert("EnumMember", node, opts);
}
function assertJSX(node, opts) {
    assert("JSX", node, opts);
}
function assertMiscellaneous(node, opts) {
    assert("Miscellaneous", node, opts);
}
function assertTypeScript(node, opts) {
    assert("TypeScript", node, opts);
}
function assertTSTypeElement(node, opts) {
    assert("TSTypeElement", node, opts);
}
function assertTSType(node, opts) {
    assert("TSType", node, opts);
}
function assertTSBaseType(node, opts) {
    assert("TSBaseType", node, opts);
}
function assertNumberLiteral(node, opts) {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
    assert("NumberLiteral", node, opts);
}
function assertRegexLiteral(node, opts) {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
    assert("RegexLiteral", node, opts);
}
function assertRestProperty(node, opts) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    assert("RestProperty", node, opts);
}
function assertSpreadProperty(node, opts) {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");
    assert("SpreadProperty", node, opts);
}

},{"../../validators/is":"g9VKJ"}],"7OaWy":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _generated = require("../generated");
var _default = createTypeAnnotationBasedOnTypeof;
exports.default = _default;
function createTypeAnnotationBasedOnTypeof(type) {
    switch(type){
        case "string":
            return (0, _generated.stringTypeAnnotation)();
        case "number":
            return (0, _generated.numberTypeAnnotation)();
        case "undefined":
            return (0, _generated.voidTypeAnnotation)();
        case "boolean":
            return (0, _generated.booleanTypeAnnotation)();
        case "function":
            return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));
        case "object":
            return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));
        case "symbol":
            return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));
        case "bigint":
            return (0, _generated.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + type);
}

},{"../generated":"1t4GT"}],"ilG9a":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = createFlowUnionType;
var _generated = require("../generated");
var _removeTypeDuplicates = require("../../modifications/flow/removeTypeDuplicates");
function createFlowUnionType(types) {
    const flattened = (0, _removeTypeDuplicates.default)(types);
    if (flattened.length === 1) return flattened[0];
    else return (0, _generated.unionTypeAnnotation)(flattened);
}

},{"../generated":"1t4GT","../../modifications/flow/removeTypeDuplicates":"syAKf"}],"syAKf":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removeTypeDuplicates;
var _generated = require("../../validators/generated");
function getQualifiedName(node) {
    return (0, _generated.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
}
function removeTypeDuplicates(nodes) {
    const generics = {};
    const bases = {};
    const typeGroups = new Set();
    const types = [];
    for(let i = 0; i < nodes.length; i++){
        const node = nodes[i];
        if (!node) continue;
        if (types.indexOf(node) >= 0) continue;
        if ((0, _generated.isAnyTypeAnnotation)(node)) return [
            node
        ];
        if ((0, _generated.isFlowBaseAnnotation)(node)) {
            bases[node.type] = node;
            continue;
        }
        if ((0, _generated.isUnionTypeAnnotation)(node)) {
            if (!typeGroups.has(node.types)) {
                nodes = nodes.concat(node.types);
                typeGroups.add(node.types);
            }
            continue;
        }
        if ((0, _generated.isGenericTypeAnnotation)(node)) {
            const name = getQualifiedName(node.id);
            if (generics[name]) {
                let existing = generics[name];
                if (existing.typeParameters) {
                    if (node.typeParameters) existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
                } else existing = node.typeParameters;
            } else generics[name] = node;
            continue;
        }
        types.push(node);
    }
    for (const type of Object.keys(bases))types.push(bases[type]);
    for (const name of Object.keys(generics))types.push(generics[name]);
    return types;
}

},{"../../validators/generated":"bjDwT"}],"kfOse":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = createTSUnionType;
var _generated = require("../generated");
var _removeTypeDuplicates = require("../../modifications/typescript/removeTypeDuplicates");
function createTSUnionType(typeAnnotations) {
    const types = typeAnnotations.map((type)=>type.typeAnnotation
    );
    const flattened = (0, _removeTypeDuplicates.default)(types);
    if (flattened.length === 1) return flattened[0];
    else return (0, _generated.tsUnionType)(flattened);
}

},{"../generated":"1t4GT","../../modifications/typescript/removeTypeDuplicates":"hCaaV"}],"hCaaV":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removeTypeDuplicates;
var _generated = require("../../validators/generated");
function removeTypeDuplicates(nodes) {
    const generics = {};
    const bases = {};
    const typeGroups = new Set();
    const types = [];
    for(let i = 0; i < nodes.length; i++){
        const node = nodes[i];
        if (!node) continue;
        if (types.indexOf(node) >= 0) continue;
        if ((0, _generated.isTSAnyKeyword)(node)) return [
            node
        ];
        if ((0, _generated.isTSBaseType)(node)) {
            bases[node.type] = node;
            continue;
        }
        if ((0, _generated.isTSUnionType)(node)) {
            if (!typeGroups.has(node.types)) {
                nodes.push(...node.types);
                typeGroups.add(node.types);
            }
            continue;
        }
        types.push(node);
    }
    for (const type of Object.keys(bases))types.push(bases[type]);
    for (const name of Object.keys(generics))types.push(generics[name]);
    return types;
}

},{"../../validators/generated":"bjDwT"}],"3Bbdf":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "AnyTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.anyTypeAnnotation;
    }
});
Object.defineProperty(exports, "ArgumentPlaceholder", {
    enumerable: true,
    get: function() {
        return _index.argumentPlaceholder;
    }
});
Object.defineProperty(exports, "ArrayExpression", {
    enumerable: true,
    get: function() {
        return _index.arrayExpression;
    }
});
Object.defineProperty(exports, "ArrayPattern", {
    enumerable: true,
    get: function() {
        return _index.arrayPattern;
    }
});
Object.defineProperty(exports, "ArrayTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.arrayTypeAnnotation;
    }
});
Object.defineProperty(exports, "ArrowFunctionExpression", {
    enumerable: true,
    get: function() {
        return _index.arrowFunctionExpression;
    }
});
Object.defineProperty(exports, "AssignmentExpression", {
    enumerable: true,
    get: function() {
        return _index.assignmentExpression;
    }
});
Object.defineProperty(exports, "AssignmentPattern", {
    enumerable: true,
    get: function() {
        return _index.assignmentPattern;
    }
});
Object.defineProperty(exports, "AwaitExpression", {
    enumerable: true,
    get: function() {
        return _index.awaitExpression;
    }
});
Object.defineProperty(exports, "BigIntLiteral", {
    enumerable: true,
    get: function() {
        return _index.bigIntLiteral;
    }
});
Object.defineProperty(exports, "BinaryExpression", {
    enumerable: true,
    get: function() {
        return _index.binaryExpression;
    }
});
Object.defineProperty(exports, "BindExpression", {
    enumerable: true,
    get: function() {
        return _index.bindExpression;
    }
});
Object.defineProperty(exports, "BlockStatement", {
    enumerable: true,
    get: function() {
        return _index.blockStatement;
    }
});
Object.defineProperty(exports, "BooleanLiteral", {
    enumerable: true,
    get: function() {
        return _index.booleanLiteral;
    }
});
Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.booleanLiteralTypeAnnotation;
    }
});
Object.defineProperty(exports, "BooleanTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.booleanTypeAnnotation;
    }
});
Object.defineProperty(exports, "BreakStatement", {
    enumerable: true,
    get: function() {
        return _index.breakStatement;
    }
});
Object.defineProperty(exports, "CallExpression", {
    enumerable: true,
    get: function() {
        return _index.callExpression;
    }
});
Object.defineProperty(exports, "CatchClause", {
    enumerable: true,
    get: function() {
        return _index.catchClause;
    }
});
Object.defineProperty(exports, "ClassBody", {
    enumerable: true,
    get: function() {
        return _index.classBody;
    }
});
Object.defineProperty(exports, "ClassDeclaration", {
    enumerable: true,
    get: function() {
        return _index.classDeclaration;
    }
});
Object.defineProperty(exports, "ClassExpression", {
    enumerable: true,
    get: function() {
        return _index.classExpression;
    }
});
Object.defineProperty(exports, "ClassImplements", {
    enumerable: true,
    get: function() {
        return _index.classImplements;
    }
});
Object.defineProperty(exports, "ClassMethod", {
    enumerable: true,
    get: function() {
        return _index.classMethod;
    }
});
Object.defineProperty(exports, "ClassPrivateMethod", {
    enumerable: true,
    get: function() {
        return _index.classPrivateMethod;
    }
});
Object.defineProperty(exports, "ClassPrivateProperty", {
    enumerable: true,
    get: function() {
        return _index.classPrivateProperty;
    }
});
Object.defineProperty(exports, "ClassProperty", {
    enumerable: true,
    get: function() {
        return _index.classProperty;
    }
});
Object.defineProperty(exports, "ConditionalExpression", {
    enumerable: true,
    get: function() {
        return _index.conditionalExpression;
    }
});
Object.defineProperty(exports, "ContinueStatement", {
    enumerable: true,
    get: function() {
        return _index.continueStatement;
    }
});
Object.defineProperty(exports, "DebuggerStatement", {
    enumerable: true,
    get: function() {
        return _index.debuggerStatement;
    }
});
Object.defineProperty(exports, "DecimalLiteral", {
    enumerable: true,
    get: function() {
        return _index.decimalLiteral;
    }
});
Object.defineProperty(exports, "DeclareClass", {
    enumerable: true,
    get: function() {
        return _index.declareClass;
    }
});
Object.defineProperty(exports, "DeclareExportAllDeclaration", {
    enumerable: true,
    get: function() {
        return _index.declareExportAllDeclaration;
    }
});
Object.defineProperty(exports, "DeclareExportDeclaration", {
    enumerable: true,
    get: function() {
        return _index.declareExportDeclaration;
    }
});
Object.defineProperty(exports, "DeclareFunction", {
    enumerable: true,
    get: function() {
        return _index.declareFunction;
    }
});
Object.defineProperty(exports, "DeclareInterface", {
    enumerable: true,
    get: function() {
        return _index.declareInterface;
    }
});
Object.defineProperty(exports, "DeclareModule", {
    enumerable: true,
    get: function() {
        return _index.declareModule;
    }
});
Object.defineProperty(exports, "DeclareModuleExports", {
    enumerable: true,
    get: function() {
        return _index.declareModuleExports;
    }
});
Object.defineProperty(exports, "DeclareOpaqueType", {
    enumerable: true,
    get: function() {
        return _index.declareOpaqueType;
    }
});
Object.defineProperty(exports, "DeclareTypeAlias", {
    enumerable: true,
    get: function() {
        return _index.declareTypeAlias;
    }
});
Object.defineProperty(exports, "DeclareVariable", {
    enumerable: true,
    get: function() {
        return _index.declareVariable;
    }
});
Object.defineProperty(exports, "DeclaredPredicate", {
    enumerable: true,
    get: function() {
        return _index.declaredPredicate;
    }
});
Object.defineProperty(exports, "Decorator", {
    enumerable: true,
    get: function() {
        return _index.decorator;
    }
});
Object.defineProperty(exports, "Directive", {
    enumerable: true,
    get: function() {
        return _index.directive;
    }
});
Object.defineProperty(exports, "DirectiveLiteral", {
    enumerable: true,
    get: function() {
        return _index.directiveLiteral;
    }
});
Object.defineProperty(exports, "DoExpression", {
    enumerable: true,
    get: function() {
        return _index.doExpression;
    }
});
Object.defineProperty(exports, "DoWhileStatement", {
    enumerable: true,
    get: function() {
        return _index.doWhileStatement;
    }
});
Object.defineProperty(exports, "EmptyStatement", {
    enumerable: true,
    get: function() {
        return _index.emptyStatement;
    }
});
Object.defineProperty(exports, "EmptyTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.emptyTypeAnnotation;
    }
});
Object.defineProperty(exports, "EnumBooleanBody", {
    enumerable: true,
    get: function() {
        return _index.enumBooleanBody;
    }
});
Object.defineProperty(exports, "EnumBooleanMember", {
    enumerable: true,
    get: function() {
        return _index.enumBooleanMember;
    }
});
Object.defineProperty(exports, "EnumDeclaration", {
    enumerable: true,
    get: function() {
        return _index.enumDeclaration;
    }
});
Object.defineProperty(exports, "EnumDefaultedMember", {
    enumerable: true,
    get: function() {
        return _index.enumDefaultedMember;
    }
});
Object.defineProperty(exports, "EnumNumberBody", {
    enumerable: true,
    get: function() {
        return _index.enumNumberBody;
    }
});
Object.defineProperty(exports, "EnumNumberMember", {
    enumerable: true,
    get: function() {
        return _index.enumNumberMember;
    }
});
Object.defineProperty(exports, "EnumStringBody", {
    enumerable: true,
    get: function() {
        return _index.enumStringBody;
    }
});
Object.defineProperty(exports, "EnumStringMember", {
    enumerable: true,
    get: function() {
        return _index.enumStringMember;
    }
});
Object.defineProperty(exports, "EnumSymbolBody", {
    enumerable: true,
    get: function() {
        return _index.enumSymbolBody;
    }
});
Object.defineProperty(exports, "ExistsTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.existsTypeAnnotation;
    }
});
Object.defineProperty(exports, "ExportAllDeclaration", {
    enumerable: true,
    get: function() {
        return _index.exportAllDeclaration;
    }
});
Object.defineProperty(exports, "ExportDefaultDeclaration", {
    enumerable: true,
    get: function() {
        return _index.exportDefaultDeclaration;
    }
});
Object.defineProperty(exports, "ExportDefaultSpecifier", {
    enumerable: true,
    get: function() {
        return _index.exportDefaultSpecifier;
    }
});
Object.defineProperty(exports, "ExportNamedDeclaration", {
    enumerable: true,
    get: function() {
        return _index.exportNamedDeclaration;
    }
});
Object.defineProperty(exports, "ExportNamespaceSpecifier", {
    enumerable: true,
    get: function() {
        return _index.exportNamespaceSpecifier;
    }
});
Object.defineProperty(exports, "ExportSpecifier", {
    enumerable: true,
    get: function() {
        return _index.exportSpecifier;
    }
});
Object.defineProperty(exports, "ExpressionStatement", {
    enumerable: true,
    get: function() {
        return _index.expressionStatement;
    }
});
Object.defineProperty(exports, "File", {
    enumerable: true,
    get: function() {
        return _index.file;
    }
});
Object.defineProperty(exports, "ForInStatement", {
    enumerable: true,
    get: function() {
        return _index.forInStatement;
    }
});
Object.defineProperty(exports, "ForOfStatement", {
    enumerable: true,
    get: function() {
        return _index.forOfStatement;
    }
});
Object.defineProperty(exports, "ForStatement", {
    enumerable: true,
    get: function() {
        return _index.forStatement;
    }
});
Object.defineProperty(exports, "FunctionDeclaration", {
    enumerable: true,
    get: function() {
        return _index.functionDeclaration;
    }
});
Object.defineProperty(exports, "FunctionExpression", {
    enumerable: true,
    get: function() {
        return _index.functionExpression;
    }
});
Object.defineProperty(exports, "FunctionTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.functionTypeAnnotation;
    }
});
Object.defineProperty(exports, "FunctionTypeParam", {
    enumerable: true,
    get: function() {
        return _index.functionTypeParam;
    }
});
Object.defineProperty(exports, "GenericTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.genericTypeAnnotation;
    }
});
Object.defineProperty(exports, "Identifier", {
    enumerable: true,
    get: function() {
        return _index.identifier;
    }
});
Object.defineProperty(exports, "IfStatement", {
    enumerable: true,
    get: function() {
        return _index.ifStatement;
    }
});
Object.defineProperty(exports, "Import", {
    enumerable: true,
    get: function() {
        return _index.import;
    }
});
Object.defineProperty(exports, "ImportAttribute", {
    enumerable: true,
    get: function() {
        return _index.importAttribute;
    }
});
Object.defineProperty(exports, "ImportDeclaration", {
    enumerable: true,
    get: function() {
        return _index.importDeclaration;
    }
});
Object.defineProperty(exports, "ImportDefaultSpecifier", {
    enumerable: true,
    get: function() {
        return _index.importDefaultSpecifier;
    }
});
Object.defineProperty(exports, "ImportNamespaceSpecifier", {
    enumerable: true,
    get: function() {
        return _index.importNamespaceSpecifier;
    }
});
Object.defineProperty(exports, "ImportSpecifier", {
    enumerable: true,
    get: function() {
        return _index.importSpecifier;
    }
});
Object.defineProperty(exports, "IndexedAccessType", {
    enumerable: true,
    get: function() {
        return _index.indexedAccessType;
    }
});
Object.defineProperty(exports, "InferredPredicate", {
    enumerable: true,
    get: function() {
        return _index.inferredPredicate;
    }
});
Object.defineProperty(exports, "InterfaceDeclaration", {
    enumerable: true,
    get: function() {
        return _index.interfaceDeclaration;
    }
});
Object.defineProperty(exports, "InterfaceExtends", {
    enumerable: true,
    get: function() {
        return _index.interfaceExtends;
    }
});
Object.defineProperty(exports, "InterfaceTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.interfaceTypeAnnotation;
    }
});
Object.defineProperty(exports, "InterpreterDirective", {
    enumerable: true,
    get: function() {
        return _index.interpreterDirective;
    }
});
Object.defineProperty(exports, "IntersectionTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.intersectionTypeAnnotation;
    }
});
Object.defineProperty(exports, "JSXAttribute", {
    enumerable: true,
    get: function() {
        return _index.jsxAttribute;
    }
});
Object.defineProperty(exports, "JSXClosingElement", {
    enumerable: true,
    get: function() {
        return _index.jsxClosingElement;
    }
});
Object.defineProperty(exports, "JSXClosingFragment", {
    enumerable: true,
    get: function() {
        return _index.jsxClosingFragment;
    }
});
Object.defineProperty(exports, "JSXElement", {
    enumerable: true,
    get: function() {
        return _index.jsxElement;
    }
});
Object.defineProperty(exports, "JSXEmptyExpression", {
    enumerable: true,
    get: function() {
        return _index.jsxEmptyExpression;
    }
});
Object.defineProperty(exports, "JSXExpressionContainer", {
    enumerable: true,
    get: function() {
        return _index.jsxExpressionContainer;
    }
});
Object.defineProperty(exports, "JSXFragment", {
    enumerable: true,
    get: function() {
        return _index.jsxFragment;
    }
});
Object.defineProperty(exports, "JSXIdentifier", {
    enumerable: true,
    get: function() {
        return _index.jsxIdentifier;
    }
});
Object.defineProperty(exports, "JSXMemberExpression", {
    enumerable: true,
    get: function() {
        return _index.jsxMemberExpression;
    }
});
Object.defineProperty(exports, "JSXNamespacedName", {
    enumerable: true,
    get: function() {
        return _index.jsxNamespacedName;
    }
});
Object.defineProperty(exports, "JSXOpeningElement", {
    enumerable: true,
    get: function() {
        return _index.jsxOpeningElement;
    }
});
Object.defineProperty(exports, "JSXOpeningFragment", {
    enumerable: true,
    get: function() {
        return _index.jsxOpeningFragment;
    }
});
Object.defineProperty(exports, "JSXSpreadAttribute", {
    enumerable: true,
    get: function() {
        return _index.jsxSpreadAttribute;
    }
});
Object.defineProperty(exports, "JSXSpreadChild", {
    enumerable: true,
    get: function() {
        return _index.jsxSpreadChild;
    }
});
Object.defineProperty(exports, "JSXText", {
    enumerable: true,
    get: function() {
        return _index.jsxText;
    }
});
Object.defineProperty(exports, "LabeledStatement", {
    enumerable: true,
    get: function() {
        return _index.labeledStatement;
    }
});
Object.defineProperty(exports, "LogicalExpression", {
    enumerable: true,
    get: function() {
        return _index.logicalExpression;
    }
});
Object.defineProperty(exports, "MemberExpression", {
    enumerable: true,
    get: function() {
        return _index.memberExpression;
    }
});
Object.defineProperty(exports, "MetaProperty", {
    enumerable: true,
    get: function() {
        return _index.metaProperty;
    }
});
Object.defineProperty(exports, "MixedTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.mixedTypeAnnotation;
    }
});
Object.defineProperty(exports, "ModuleExpression", {
    enumerable: true,
    get: function() {
        return _index.moduleExpression;
    }
});
Object.defineProperty(exports, "NewExpression", {
    enumerable: true,
    get: function() {
        return _index.newExpression;
    }
});
Object.defineProperty(exports, "Noop", {
    enumerable: true,
    get: function() {
        return _index.noop;
    }
});
Object.defineProperty(exports, "NullLiteral", {
    enumerable: true,
    get: function() {
        return _index.nullLiteral;
    }
});
Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.nullLiteralTypeAnnotation;
    }
});
Object.defineProperty(exports, "NullableTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.nullableTypeAnnotation;
    }
});
Object.defineProperty(exports, "NumberLiteral", {
    enumerable: true,
    get: function() {
        return _index.numberLiteral;
    }
});
Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.numberLiteralTypeAnnotation;
    }
});
Object.defineProperty(exports, "NumberTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.numberTypeAnnotation;
    }
});
Object.defineProperty(exports, "NumericLiteral", {
    enumerable: true,
    get: function() {
        return _index.numericLiteral;
    }
});
Object.defineProperty(exports, "ObjectExpression", {
    enumerable: true,
    get: function() {
        return _index.objectExpression;
    }
});
Object.defineProperty(exports, "ObjectMethod", {
    enumerable: true,
    get: function() {
        return _index.objectMethod;
    }
});
Object.defineProperty(exports, "ObjectPattern", {
    enumerable: true,
    get: function() {
        return _index.objectPattern;
    }
});
Object.defineProperty(exports, "ObjectProperty", {
    enumerable: true,
    get: function() {
        return _index.objectProperty;
    }
});
Object.defineProperty(exports, "ObjectTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.objectTypeAnnotation;
    }
});
Object.defineProperty(exports, "ObjectTypeCallProperty", {
    enumerable: true,
    get: function() {
        return _index.objectTypeCallProperty;
    }
});
Object.defineProperty(exports, "ObjectTypeIndexer", {
    enumerable: true,
    get: function() {
        return _index.objectTypeIndexer;
    }
});
Object.defineProperty(exports, "ObjectTypeInternalSlot", {
    enumerable: true,
    get: function() {
        return _index.objectTypeInternalSlot;
    }
});
Object.defineProperty(exports, "ObjectTypeProperty", {
    enumerable: true,
    get: function() {
        return _index.objectTypeProperty;
    }
});
Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
    enumerable: true,
    get: function() {
        return _index.objectTypeSpreadProperty;
    }
});
Object.defineProperty(exports, "OpaqueType", {
    enumerable: true,
    get: function() {
        return _index.opaqueType;
    }
});
Object.defineProperty(exports, "OptionalCallExpression", {
    enumerable: true,
    get: function() {
        return _index.optionalCallExpression;
    }
});
Object.defineProperty(exports, "OptionalIndexedAccessType", {
    enumerable: true,
    get: function() {
        return _index.optionalIndexedAccessType;
    }
});
Object.defineProperty(exports, "OptionalMemberExpression", {
    enumerable: true,
    get: function() {
        return _index.optionalMemberExpression;
    }
});
Object.defineProperty(exports, "ParenthesizedExpression", {
    enumerable: true,
    get: function() {
        return _index.parenthesizedExpression;
    }
});
Object.defineProperty(exports, "PipelineBareFunction", {
    enumerable: true,
    get: function() {
        return _index.pipelineBareFunction;
    }
});
Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
    enumerable: true,
    get: function() {
        return _index.pipelinePrimaryTopicReference;
    }
});
Object.defineProperty(exports, "PipelineTopicExpression", {
    enumerable: true,
    get: function() {
        return _index.pipelineTopicExpression;
    }
});
Object.defineProperty(exports, "Placeholder", {
    enumerable: true,
    get: function() {
        return _index.placeholder;
    }
});
Object.defineProperty(exports, "PrivateName", {
    enumerable: true,
    get: function() {
        return _index.privateName;
    }
});
Object.defineProperty(exports, "Program", {
    enumerable: true,
    get: function() {
        return _index.program;
    }
});
Object.defineProperty(exports, "QualifiedTypeIdentifier", {
    enumerable: true,
    get: function() {
        return _index.qualifiedTypeIdentifier;
    }
});
Object.defineProperty(exports, "RecordExpression", {
    enumerable: true,
    get: function() {
        return _index.recordExpression;
    }
});
Object.defineProperty(exports, "RegExpLiteral", {
    enumerable: true,
    get: function() {
        return _index.regExpLiteral;
    }
});
Object.defineProperty(exports, "RegexLiteral", {
    enumerable: true,
    get: function() {
        return _index.regexLiteral;
    }
});
Object.defineProperty(exports, "RestElement", {
    enumerable: true,
    get: function() {
        return _index.restElement;
    }
});
Object.defineProperty(exports, "RestProperty", {
    enumerable: true,
    get: function() {
        return _index.restProperty;
    }
});
Object.defineProperty(exports, "ReturnStatement", {
    enumerable: true,
    get: function() {
        return _index.returnStatement;
    }
});
Object.defineProperty(exports, "SequenceExpression", {
    enumerable: true,
    get: function() {
        return _index.sequenceExpression;
    }
});
Object.defineProperty(exports, "SpreadElement", {
    enumerable: true,
    get: function() {
        return _index.spreadElement;
    }
});
Object.defineProperty(exports, "SpreadProperty", {
    enumerable: true,
    get: function() {
        return _index.spreadProperty;
    }
});
Object.defineProperty(exports, "StaticBlock", {
    enumerable: true,
    get: function() {
        return _index.staticBlock;
    }
});
Object.defineProperty(exports, "StringLiteral", {
    enumerable: true,
    get: function() {
        return _index.stringLiteral;
    }
});
Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.stringLiteralTypeAnnotation;
    }
});
Object.defineProperty(exports, "StringTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.stringTypeAnnotation;
    }
});
Object.defineProperty(exports, "Super", {
    enumerable: true,
    get: function() {
        return _index.super;
    }
});
Object.defineProperty(exports, "SwitchCase", {
    enumerable: true,
    get: function() {
        return _index.switchCase;
    }
});
Object.defineProperty(exports, "SwitchStatement", {
    enumerable: true,
    get: function() {
        return _index.switchStatement;
    }
});
Object.defineProperty(exports, "SymbolTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.symbolTypeAnnotation;
    }
});
Object.defineProperty(exports, "TSAnyKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsAnyKeyword;
    }
});
Object.defineProperty(exports, "TSArrayType", {
    enumerable: true,
    get: function() {
        return _index.tsArrayType;
    }
});
Object.defineProperty(exports, "TSAsExpression", {
    enumerable: true,
    get: function() {
        return _index.tsAsExpression;
    }
});
Object.defineProperty(exports, "TSBigIntKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsBigIntKeyword;
    }
});
Object.defineProperty(exports, "TSBooleanKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsBooleanKeyword;
    }
});
Object.defineProperty(exports, "TSCallSignatureDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsCallSignatureDeclaration;
    }
});
Object.defineProperty(exports, "TSConditionalType", {
    enumerable: true,
    get: function() {
        return _index.tsConditionalType;
    }
});
Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsConstructSignatureDeclaration;
    }
});
Object.defineProperty(exports, "TSConstructorType", {
    enumerable: true,
    get: function() {
        return _index.tsConstructorType;
    }
});
Object.defineProperty(exports, "TSDeclareFunction", {
    enumerable: true,
    get: function() {
        return _index.tsDeclareFunction;
    }
});
Object.defineProperty(exports, "TSDeclareMethod", {
    enumerable: true,
    get: function() {
        return _index.tsDeclareMethod;
    }
});
Object.defineProperty(exports, "TSEnumDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsEnumDeclaration;
    }
});
Object.defineProperty(exports, "TSEnumMember", {
    enumerable: true,
    get: function() {
        return _index.tsEnumMember;
    }
});
Object.defineProperty(exports, "TSExportAssignment", {
    enumerable: true,
    get: function() {
        return _index.tsExportAssignment;
    }
});
Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
    enumerable: true,
    get: function() {
        return _index.tsExpressionWithTypeArguments;
    }
});
Object.defineProperty(exports, "TSExternalModuleReference", {
    enumerable: true,
    get: function() {
        return _index.tsExternalModuleReference;
    }
});
Object.defineProperty(exports, "TSFunctionType", {
    enumerable: true,
    get: function() {
        return _index.tsFunctionType;
    }
});
Object.defineProperty(exports, "TSImportEqualsDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsImportEqualsDeclaration;
    }
});
Object.defineProperty(exports, "TSImportType", {
    enumerable: true,
    get: function() {
        return _index.tsImportType;
    }
});
Object.defineProperty(exports, "TSIndexSignature", {
    enumerable: true,
    get: function() {
        return _index.tsIndexSignature;
    }
});
Object.defineProperty(exports, "TSIndexedAccessType", {
    enumerable: true,
    get: function() {
        return _index.tsIndexedAccessType;
    }
});
Object.defineProperty(exports, "TSInferType", {
    enumerable: true,
    get: function() {
        return _index.tsInferType;
    }
});
Object.defineProperty(exports, "TSInterfaceBody", {
    enumerable: true,
    get: function() {
        return _index.tsInterfaceBody;
    }
});
Object.defineProperty(exports, "TSInterfaceDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsInterfaceDeclaration;
    }
});
Object.defineProperty(exports, "TSIntersectionType", {
    enumerable: true,
    get: function() {
        return _index.tsIntersectionType;
    }
});
Object.defineProperty(exports, "TSIntrinsicKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsIntrinsicKeyword;
    }
});
Object.defineProperty(exports, "TSLiteralType", {
    enumerable: true,
    get: function() {
        return _index.tsLiteralType;
    }
});
Object.defineProperty(exports, "TSMappedType", {
    enumerable: true,
    get: function() {
        return _index.tsMappedType;
    }
});
Object.defineProperty(exports, "TSMethodSignature", {
    enumerable: true,
    get: function() {
        return _index.tsMethodSignature;
    }
});
Object.defineProperty(exports, "TSModuleBlock", {
    enumerable: true,
    get: function() {
        return _index.tsModuleBlock;
    }
});
Object.defineProperty(exports, "TSModuleDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsModuleDeclaration;
    }
});
Object.defineProperty(exports, "TSNamedTupleMember", {
    enumerable: true,
    get: function() {
        return _index.tsNamedTupleMember;
    }
});
Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsNamespaceExportDeclaration;
    }
});
Object.defineProperty(exports, "TSNeverKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsNeverKeyword;
    }
});
Object.defineProperty(exports, "TSNonNullExpression", {
    enumerable: true,
    get: function() {
        return _index.tsNonNullExpression;
    }
});
Object.defineProperty(exports, "TSNullKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsNullKeyword;
    }
});
Object.defineProperty(exports, "TSNumberKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsNumberKeyword;
    }
});
Object.defineProperty(exports, "TSObjectKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsObjectKeyword;
    }
});
Object.defineProperty(exports, "TSOptionalType", {
    enumerable: true,
    get: function() {
        return _index.tsOptionalType;
    }
});
Object.defineProperty(exports, "TSParameterProperty", {
    enumerable: true,
    get: function() {
        return _index.tsParameterProperty;
    }
});
Object.defineProperty(exports, "TSParenthesizedType", {
    enumerable: true,
    get: function() {
        return _index.tsParenthesizedType;
    }
});
Object.defineProperty(exports, "TSPropertySignature", {
    enumerable: true,
    get: function() {
        return _index.tsPropertySignature;
    }
});
Object.defineProperty(exports, "TSQualifiedName", {
    enumerable: true,
    get: function() {
        return _index.tsQualifiedName;
    }
});
Object.defineProperty(exports, "TSRestType", {
    enumerable: true,
    get: function() {
        return _index.tsRestType;
    }
});
Object.defineProperty(exports, "TSStringKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsStringKeyword;
    }
});
Object.defineProperty(exports, "TSSymbolKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsSymbolKeyword;
    }
});
Object.defineProperty(exports, "TSThisType", {
    enumerable: true,
    get: function() {
        return _index.tsThisType;
    }
});
Object.defineProperty(exports, "TSTupleType", {
    enumerable: true,
    get: function() {
        return _index.tsTupleType;
    }
});
Object.defineProperty(exports, "TSTypeAliasDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsTypeAliasDeclaration;
    }
});
Object.defineProperty(exports, "TSTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.tsTypeAnnotation;
    }
});
Object.defineProperty(exports, "TSTypeAssertion", {
    enumerable: true,
    get: function() {
        return _index.tsTypeAssertion;
    }
});
Object.defineProperty(exports, "TSTypeLiteral", {
    enumerable: true,
    get: function() {
        return _index.tsTypeLiteral;
    }
});
Object.defineProperty(exports, "TSTypeOperator", {
    enumerable: true,
    get: function() {
        return _index.tsTypeOperator;
    }
});
Object.defineProperty(exports, "TSTypeParameter", {
    enumerable: true,
    get: function() {
        return _index.tsTypeParameter;
    }
});
Object.defineProperty(exports, "TSTypeParameterDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsTypeParameterDeclaration;
    }
});
Object.defineProperty(exports, "TSTypeParameterInstantiation", {
    enumerable: true,
    get: function() {
        return _index.tsTypeParameterInstantiation;
    }
});
Object.defineProperty(exports, "TSTypePredicate", {
    enumerable: true,
    get: function() {
        return _index.tsTypePredicate;
    }
});
Object.defineProperty(exports, "TSTypeQuery", {
    enumerable: true,
    get: function() {
        return _index.tsTypeQuery;
    }
});
Object.defineProperty(exports, "TSTypeReference", {
    enumerable: true,
    get: function() {
        return _index.tsTypeReference;
    }
});
Object.defineProperty(exports, "TSUndefinedKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsUndefinedKeyword;
    }
});
Object.defineProperty(exports, "TSUnionType", {
    enumerable: true,
    get: function() {
        return _index.tsUnionType;
    }
});
Object.defineProperty(exports, "TSUnknownKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsUnknownKeyword;
    }
});
Object.defineProperty(exports, "TSVoidKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsVoidKeyword;
    }
});
Object.defineProperty(exports, "TaggedTemplateExpression", {
    enumerable: true,
    get: function() {
        return _index.taggedTemplateExpression;
    }
});
Object.defineProperty(exports, "TemplateElement", {
    enumerable: true,
    get: function() {
        return _index.templateElement;
    }
});
Object.defineProperty(exports, "TemplateLiteral", {
    enumerable: true,
    get: function() {
        return _index.templateLiteral;
    }
});
Object.defineProperty(exports, "ThisExpression", {
    enumerable: true,
    get: function() {
        return _index.thisExpression;
    }
});
Object.defineProperty(exports, "ThisTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.thisTypeAnnotation;
    }
});
Object.defineProperty(exports, "ThrowStatement", {
    enumerable: true,
    get: function() {
        return _index.throwStatement;
    }
});
Object.defineProperty(exports, "TopicReference", {
    enumerable: true,
    get: function() {
        return _index.topicReference;
    }
});
Object.defineProperty(exports, "TryStatement", {
    enumerable: true,
    get: function() {
        return _index.tryStatement;
    }
});
Object.defineProperty(exports, "TupleExpression", {
    enumerable: true,
    get: function() {
        return _index.tupleExpression;
    }
});
Object.defineProperty(exports, "TupleTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.tupleTypeAnnotation;
    }
});
Object.defineProperty(exports, "TypeAlias", {
    enumerable: true,
    get: function() {
        return _index.typeAlias;
    }
});
Object.defineProperty(exports, "TypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.typeAnnotation;
    }
});
Object.defineProperty(exports, "TypeCastExpression", {
    enumerable: true,
    get: function() {
        return _index.typeCastExpression;
    }
});
Object.defineProperty(exports, "TypeParameter", {
    enumerable: true,
    get: function() {
        return _index.typeParameter;
    }
});
Object.defineProperty(exports, "TypeParameterDeclaration", {
    enumerable: true,
    get: function() {
        return _index.typeParameterDeclaration;
    }
});
Object.defineProperty(exports, "TypeParameterInstantiation", {
    enumerable: true,
    get: function() {
        return _index.typeParameterInstantiation;
    }
});
Object.defineProperty(exports, "TypeofTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.typeofTypeAnnotation;
    }
});
Object.defineProperty(exports, "UnaryExpression", {
    enumerable: true,
    get: function() {
        return _index.unaryExpression;
    }
});
Object.defineProperty(exports, "UnionTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.unionTypeAnnotation;
    }
});
Object.defineProperty(exports, "UpdateExpression", {
    enumerable: true,
    get: function() {
        return _index.updateExpression;
    }
});
Object.defineProperty(exports, "V8IntrinsicIdentifier", {
    enumerable: true,
    get: function() {
        return _index.v8IntrinsicIdentifier;
    }
});
Object.defineProperty(exports, "VariableDeclaration", {
    enumerable: true,
    get: function() {
        return _index.variableDeclaration;
    }
});
Object.defineProperty(exports, "VariableDeclarator", {
    enumerable: true,
    get: function() {
        return _index.variableDeclarator;
    }
});
Object.defineProperty(exports, "Variance", {
    enumerable: true,
    get: function() {
        return _index.variance;
    }
});
Object.defineProperty(exports, "VoidTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.voidTypeAnnotation;
    }
});
Object.defineProperty(exports, "WhileStatement", {
    enumerable: true,
    get: function() {
        return _index.whileStatement;
    }
});
Object.defineProperty(exports, "WithStatement", {
    enumerable: true,
    get: function() {
        return _index.withStatement;
    }
});
Object.defineProperty(exports, "YieldExpression", {
    enumerable: true,
    get: function() {
        return _index.yieldExpression;
    }
});
var _index = require("./index");

},{"./index":"1t4GT"}],"9Uv0G":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cloneNode;
var _definitions = require("../definitions");
var _generated = require("../validators/generated");
const has = Function.call.bind(Object.prototype.hasOwnProperty);
function cloneIfNode(obj, deep, withoutLoc) {
    if (obj && typeof obj.type === "string") return cloneNode(obj, deep, withoutLoc);
    return obj;
}
function cloneIfNodeOrArray(obj, deep, withoutLoc) {
    if (Array.isArray(obj)) return obj.map((node)=>cloneIfNode(node, deep, withoutLoc)
    );
    return cloneIfNode(obj, deep, withoutLoc);
}
function cloneNode(node, deep = true, withoutLoc = false) {
    if (!node) return node;
    const { type  } = node;
    const newNode = {
        type: node.type
    };
    if ((0, _generated.isIdentifier)(node)) {
        newNode.name = node.name;
        if (has(node, "optional") && typeof node.optional === "boolean") newNode.optional = node.optional;
        if (has(node, "typeAnnotation")) newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation;
    } else if (!has(_definitions.NODE_FIELDS, type)) throw new Error(`Unknown node type: "${type}"`);
    else {
        for (const field of Object.keys(_definitions.NODE_FIELDS[type]))if (has(node, field)) {
            if (deep) newNode[field] = (0, _generated.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc);
            else newNode[field] = node[field];
        }
    }
    if (has(node, "loc")) {
        if (withoutLoc) newNode.loc = null;
        else newNode.loc = node.loc;
    }
    if (has(node, "leadingComments")) newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc);
    if (has(node, "innerComments")) newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc);
    if (has(node, "trailingComments")) newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc);
    if (has(node, "extra")) newNode.extra = Object.assign({}, node.extra);
    return newNode;
}
function maybeCloneComments(comments, deep, withoutLoc) {
    if (!comments || !deep) return comments;
    return comments.map(({ type , value , loc  })=>{
        if (withoutLoc) return {
            type,
            value,
            loc: null
        };
        return {
            type,
            value,
            loc
        };
    });
}

},{"../definitions":"dzUB7","../validators/generated":"bjDwT"}],"5e1Qq":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = clone;
var _cloneNode = require("./cloneNode");
function clone(node) {
    return (0, _cloneNode.default)(node, false);
}

},{"./cloneNode":"9Uv0G"}],"7a8ZO":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cloneDeep;
var _cloneNode = require("./cloneNode");
function cloneDeep(node) {
    return (0, _cloneNode.default)(node);
}

},{"./cloneNode":"9Uv0G"}],"l7vJf":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cloneDeepWithoutLoc;
var _cloneNode = require("./cloneNode");
function cloneDeepWithoutLoc(node) {
    return (0, _cloneNode.default)(node, true, true);
}

},{"./cloneNode":"9Uv0G"}],"2hNWY":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cloneWithoutLoc;
var _cloneNode = require("./cloneNode");
function cloneWithoutLoc(node) {
    return (0, _cloneNode.default)(node, false, true);
}

},{"./cloneNode":"9Uv0G"}],"kR7Gx":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = addComment;
var _addComments = require("./addComments");
function addComment(node, type, content, line) {
    return (0, _addComments.default)(node, type, [
        {
            type: line ? "CommentLine" : "CommentBlock",
            value: content
        }
    ]);
}

},{"./addComments":"ezUCd"}],"ezUCd":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = addComments;
function addComments(node, type, comments) {
    if (!comments || !node) return node;
    const key = `${type}Comments`;
    if (node[key]) {
        if (type === "leading") node[key] = comments.concat(node[key]);
        else node[key].push(...comments);
    } else node[key] = comments;
    return node;
}

},{}],"9QaTf":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inheritInnerComments;
var _inherit = require("../utils/inherit");
function inheritInnerComments(child, parent) {
    (0, _inherit.default)("innerComments", child, parent);
}

},{"../utils/inherit":"bvnVv"}],"bvnVv":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inherit;
function inherit(key, child, parent) {
    if (child && parent) child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
}

},{}],"9pYNJ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inheritLeadingComments;
var _inherit = require("../utils/inherit");
function inheritLeadingComments(child, parent) {
    (0, _inherit.default)("leadingComments", child, parent);
}

},{"../utils/inherit":"bvnVv"}],"j0S4j":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inheritsComments;
var _inheritTrailingComments = require("./inheritTrailingComments");
var _inheritLeadingComments = require("./inheritLeadingComments");
var _inheritInnerComments = require("./inheritInnerComments");
function inheritsComments(child, parent) {
    (0, _inheritTrailingComments.default)(child, parent);
    (0, _inheritLeadingComments.default)(child, parent);
    (0, _inheritInnerComments.default)(child, parent);
    return child;
}

},{"./inheritTrailingComments":"jm9ZN","./inheritLeadingComments":"9pYNJ","./inheritInnerComments":"9QaTf"}],"jm9ZN":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inheritTrailingComments;
var _inherit = require("../utils/inherit");
function inheritTrailingComments(child, parent) {
    (0, _inherit.default)("trailingComments", child, parent);
}

},{"../utils/inherit":"bvnVv"}],"i6Mcq":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removeComments;
var _constants = require("../constants");
function removeComments(node) {
    _constants.COMMENT_KEYS.forEach((key)=>{
        node[key] = null;
    });
    return node;
}

},{"../constants":"lrpJ7"}],"dcabq":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WHILE_TYPES = exports.USERWHITESPACABLE_TYPES = exports.UNARYLIKE_TYPES = exports.TYPESCRIPT_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.TSENTITYNAME_TYPES = exports.TSBASETYPE_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.STANDARDIZED_TYPES = exports.SCOPABLE_TYPES = exports.PUREISH_TYPES = exports.PROPERTY_TYPES = exports.PRIVATE_TYPES = exports.PATTERN_TYPES = exports.PATTERNLIKE_TYPES = exports.OBJECTMEMBER_TYPES = exports.MODULESPECIFIER_TYPES = exports.MODULEDECLARATION_TYPES = exports.MISCELLANEOUS_TYPES = exports.METHOD_TYPES = exports.LVAL_TYPES = exports.LOOP_TYPES = exports.LITERAL_TYPES = exports.JSX_TYPES = exports.IMMUTABLE_TYPES = exports.FUNCTION_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FOR_TYPES = exports.FORXSTATEMENT_TYPES = exports.FLOW_TYPES = exports.FLOWTYPE_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.EXPRESSION_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.DECLARATION_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.CLASS_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.BINARY_TYPES = void 0;
var _definitions = require("../../definitions");
const STANDARDIZED_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Standardized"];
exports.STANDARDIZED_TYPES = STANDARDIZED_TYPES;
const EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Expression"];
exports.EXPRESSION_TYPES = EXPRESSION_TYPES;
const BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Binary"];
exports.BINARY_TYPES = BINARY_TYPES;
const SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Scopable"];
exports.SCOPABLE_TYPES = SCOPABLE_TYPES;
const BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["BlockParent"];
exports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
const BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Block"];
exports.BLOCK_TYPES = BLOCK_TYPES;
const STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Statement"];
exports.STATEMENT_TYPES = STATEMENT_TYPES;
const TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Terminatorless"];
exports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
const COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["CompletionStatement"];
exports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
const CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Conditional"];
exports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
const LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Loop"];
exports.LOOP_TYPES = LOOP_TYPES;
const WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["While"];
exports.WHILE_TYPES = WHILE_TYPES;
const EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
exports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
const FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["For"];
exports.FOR_TYPES = FOR_TYPES;
const FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ForXStatement"];
exports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
const FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Function"];
exports.FUNCTION_TYPES = FUNCTION_TYPES;
const FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FunctionParent"];
exports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
const PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pureish"];
exports.PUREISH_TYPES = PUREISH_TYPES;
const DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Declaration"];
exports.DECLARATION_TYPES = DECLARATION_TYPES;
const PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["PatternLike"];
exports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
const LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["LVal"];
exports.LVAL_TYPES = LVAL_TYPES;
const TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSEntityName"];
exports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
const LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Literal"];
exports.LITERAL_TYPES = LITERAL_TYPES;
const IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Immutable"];
exports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
const USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
exports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
const METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Method"];
exports.METHOD_TYPES = METHOD_TYPES;
const OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ObjectMember"];
exports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
const PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Property"];
exports.PROPERTY_TYPES = PROPERTY_TYPES;
const UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UnaryLike"];
exports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
const PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pattern"];
exports.PATTERN_TYPES = PATTERN_TYPES;
const CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Class"];
exports.CLASS_TYPES = CLASS_TYPES;
const MODULEDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
exports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
const EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
exports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
const MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
exports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
const PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Private"];
exports.PRIVATE_TYPES = PRIVATE_TYPES;
const FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Flow"];
exports.FLOW_TYPES = FLOW_TYPES;
const FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowType"];
exports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
const FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
exports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
const FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
exports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
const FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowPredicate"];
exports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
const ENUMBODY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumBody"];
exports.ENUMBODY_TYPES = ENUMBODY_TYPES;
const ENUMMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumMember"];
exports.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
const JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS["JSX"];
exports.JSX_TYPES = JSX_TYPES;
const MISCELLANEOUS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Miscellaneous"];
exports.MISCELLANEOUS_TYPES = MISCELLANEOUS_TYPES;
const TYPESCRIPT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TypeScript"];
exports.TYPESCRIPT_TYPES = TYPESCRIPT_TYPES;
const TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSTypeElement"];
exports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
const TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSType"];
exports.TSTYPE_TYPES = TSTYPE_TYPES;
const TSBASETYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSBaseType"];
exports.TSBASETYPE_TYPES = TSBASETYPE_TYPES;

},{"../../definitions":"dzUB7"}],"kRy1K":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = ensureBlock;
var _toBlock = require("./toBlock");
function ensureBlock(node, key = "body") {
    return node[key] = (0, _toBlock.default)(node[key], node);
}

},{"./toBlock":"8XIXS"}],"8XIXS":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toBlock;
var _generated = require("../validators/generated");
var _generated2 = require("../builders/generated");
function toBlock(node, parent) {
    if ((0, _generated.isBlockStatement)(node)) return node;
    let blockNodes = [];
    if ((0, _generated.isEmptyStatement)(node)) blockNodes = [];
    else {
        if (!(0, _generated.isStatement)(node)) {
            if ((0, _generated.isFunction)(parent)) node = (0, _generated2.returnStatement)(node);
            else node = (0, _generated2.expressionStatement)(node);
        }
        blockNodes = [
            node
        ];
    }
    return (0, _generated2.blockStatement)(blockNodes);
}

},{"../validators/generated":"bjDwT","../builders/generated":"1t4GT"}],"1yiSv":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toBindingIdentifierName;
var _toIdentifier = require("./toIdentifier");
function toBindingIdentifierName(name) {
    name = (0, _toIdentifier.default)(name);
    if (name === "eval" || name === "arguments") name = "_" + name;
    return name;
}

},{"./toIdentifier":"10UkJ"}],"10UkJ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toIdentifier;
var _isValidIdentifier = require("../validators/isValidIdentifier");
var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");
function toIdentifier(input) {
    input = input + "";
    let name = "";
    for (const c1 of input)name += (0, _helperValidatorIdentifier.isIdentifierChar)(c1.codePointAt(0)) ? c1 : "-";
    name = name.replace(/^[-0-9]+/, "");
    name = name.replace(/[-\s]+(.)?/g, function(match, c) {
        return c ? c.toUpperCase() : "";
    });
    if (!(0, _isValidIdentifier.default)(name)) name = `_${name}`;
    return name || "_";
}

},{"../validators/isValidIdentifier":"gb2G9","@babel/helper-validator-identifier":"f9R0u"}],"k0odi":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toComputedKey;
var _generated = require("../validators/generated");
var _generated2 = require("../builders/generated");
function toComputedKey(node, key = node.key || node.property) {
    if (!node.computed && (0, _generated.isIdentifier)(key)) key = (0, _generated2.stringLiteral)(key.name);
    return key;
}

},{"../validators/generated":"bjDwT","../builders/generated":"1t4GT"}],"3Qu81":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _generated = require("../validators/generated");
var _default = toExpression;
exports.default = _default;
function toExpression(node) {
    if ((0, _generated.isExpressionStatement)(node)) node = node.expression;
    if ((0, _generated.isExpression)(node)) return node;
    if ((0, _generated.isClass)(node)) node.type = "ClassExpression";
    else if ((0, _generated.isFunction)(node)) node.type = "FunctionExpression";
    if (!(0, _generated.isExpression)(node)) throw new Error(`cannot turn ${node.type} to an expression`);
    return node;
}

},{"../validators/generated":"bjDwT"}],"6fIoF":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toKeyAlias;
var _generated = require("../validators/generated");
var _cloneNode = require("../clone/cloneNode");
var _removePropertiesDeep = require("../modifications/removePropertiesDeep");
function toKeyAlias(node, key = node.key) {
    let alias;
    if (node.kind === "method") return toKeyAlias.increment() + "";
    else if ((0, _generated.isIdentifier)(key)) alias = key.name;
    else if ((0, _generated.isStringLiteral)(key)) alias = JSON.stringify(key.value);
    else alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
    if (node.computed) alias = `[${alias}]`;
    if (node.static) alias = `static:${alias}`;
    return alias;
}
toKeyAlias.uid = 0;
toKeyAlias.increment = function() {
    if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) return toKeyAlias.uid = 0;
    else return toKeyAlias.uid++;
};

},{"../validators/generated":"bjDwT","../clone/cloneNode":"9Uv0G","../modifications/removePropertiesDeep":"2nndW"}],"2nndW":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removePropertiesDeep;
var _traverseFast = require("../traverse/traverseFast");
var _removeProperties = require("./removeProperties");
function removePropertiesDeep(tree, opts) {
    (0, _traverseFast.default)(tree, _removeProperties.default, opts);
    return tree;
}

},{"../traverse/traverseFast":"emIrr","./removeProperties":"eAGoy"}],"emIrr":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = traverseFast;
var _definitions = require("../definitions");
function traverseFast(node, enter, opts) {
    if (!node) return;
    const keys = _definitions.VISITOR_KEYS[node.type];
    if (!keys) return;
    opts = opts || {};
    enter(node, opts);
    for (const key of keys){
        const subNode = node[key];
        if (Array.isArray(subNode)) for (const node1 of subNode)traverseFast(node1, enter, opts);
        else traverseFast(subNode, enter, opts);
    }
}

},{"../definitions":"dzUB7"}],"eAGoy":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removeProperties;
var _constants = require("../constants");
const CLEAR_KEYS = [
    "tokens",
    "start",
    "end",
    "loc",
    "raw",
    "rawValue"
];
const CLEAR_KEYS_PLUS_COMMENTS = _constants.COMMENT_KEYS.concat([
    "comments"
]).concat(CLEAR_KEYS);
function removeProperties(node, opts = {}) {
    const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
    for (const key of map)if (node[key] != null) node[key] = undefined;
    for (const key1 of Object.keys(node))if (key1[0] === "_" && node[key1] != null) node[key1] = undefined;
    const symbols = Object.getOwnPropertySymbols(node);
    for (const sym of symbols)node[sym] = null;
}

},{"../constants":"lrpJ7"}],"7Efdr":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toSequenceExpression;
var _gatherSequenceExpressions = require("./gatherSequenceExpressions");
function toSequenceExpression(nodes, scope) {
    if (!(nodes != null && nodes.length)) return;
    const declars = [];
    const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
    if (!result) return;
    for (const declar of declars)scope.push(declar);
    return result;
}

},{"./gatherSequenceExpressions":"dvxWe"}],"dvxWe":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = gatherSequenceExpressions;
var _getBindingIdentifiers = require("../retrievers/getBindingIdentifiers");
var _generated = require("../validators/generated");
var _generated2 = require("../builders/generated");
var _cloneNode = require("../clone/cloneNode");
function gatherSequenceExpressions(nodes, scope, declars) {
    const exprs = [];
    let ensureLastUndefined = true;
    for (const node of nodes){
        if (!(0, _generated.isEmptyStatement)(node)) ensureLastUndefined = false;
        if ((0, _generated.isExpression)(node)) exprs.push(node);
        else if ((0, _generated.isExpressionStatement)(node)) exprs.push(node.expression);
        else if ((0, _generated.isVariableDeclaration)(node)) {
            if (node.kind !== "var") return;
            for (const declar of node.declarations){
                const bindings = (0, _getBindingIdentifiers.default)(declar);
                for (const key of Object.keys(bindings))declars.push({
                    kind: node.kind,
                    id: (0, _cloneNode.default)(bindings[key])
                });
                if (declar.init) exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));
            }
            ensureLastUndefined = true;
        } else if ((0, _generated.isIfStatement)(node)) {
            const consequent = node.consequent ? gatherSequenceExpressions([
                node.consequent
            ], scope, declars) : scope.buildUndefinedNode();
            const alternate = node.alternate ? gatherSequenceExpressions([
                node.alternate
            ], scope, declars) : scope.buildUndefinedNode();
            if (!consequent || !alternate) return;
            exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));
        } else if ((0, _generated.isBlockStatement)(node)) {
            const body = gatherSequenceExpressions(node.body, scope, declars);
            if (!body) return;
            exprs.push(body);
        } else if ((0, _generated.isEmptyStatement)(node)) {
            if (nodes.indexOf(node) === 0) ensureLastUndefined = true;
        } else return;
    }
    if (ensureLastUndefined) exprs.push(scope.buildUndefinedNode());
    if (exprs.length === 1) return exprs[0];
    else return (0, _generated2.sequenceExpression)(exprs);
}

},{"../retrievers/getBindingIdentifiers":"1guAF","../validators/generated":"bjDwT","../builders/generated":"1t4GT","../clone/cloneNode":"9Uv0G"}],"1guAF":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getBindingIdentifiers;
var _generated = require("../validators/generated");
function getBindingIdentifiers(node, duplicates, outerOnly) {
    let search = [].concat(node);
    const ids = Object.create(null);
    while(search.length){
        const id = search.shift();
        if (!id) continue;
        const keys = getBindingIdentifiers.keys[id.type];
        if ((0, _generated.isIdentifier)(id)) {
            if (duplicates) {
                const _ids = ids[id.name] = ids[id.name] || [];
                _ids.push(id);
            } else ids[id.name] = id;
            continue;
        }
        if ((0, _generated.isExportDeclaration)(id) && !(0, _generated.isExportAllDeclaration)(id)) {
            if ((0, _generated.isDeclaration)(id.declaration)) search.push(id.declaration);
            continue;
        }
        if (outerOnly) {
            if ((0, _generated.isFunctionDeclaration)(id)) {
                search.push(id.id);
                continue;
            }
            if ((0, _generated.isFunctionExpression)(id)) continue;
        }
        if (keys) for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            if (id[key]) search = search.concat(id[key]);
        }
    }
    return ids;
}
getBindingIdentifiers.keys = {
    DeclareClass: [
        "id"
    ],
    DeclareFunction: [
        "id"
    ],
    DeclareModule: [
        "id"
    ],
    DeclareVariable: [
        "id"
    ],
    DeclareInterface: [
        "id"
    ],
    DeclareTypeAlias: [
        "id"
    ],
    DeclareOpaqueType: [
        "id"
    ],
    InterfaceDeclaration: [
        "id"
    ],
    TypeAlias: [
        "id"
    ],
    OpaqueType: [
        "id"
    ],
    CatchClause: [
        "param"
    ],
    LabeledStatement: [
        "label"
    ],
    UnaryExpression: [
        "argument"
    ],
    AssignmentExpression: [
        "left"
    ],
    ImportSpecifier: [
        "local"
    ],
    ImportNamespaceSpecifier: [
        "local"
    ],
    ImportDefaultSpecifier: [
        "local"
    ],
    ImportDeclaration: [
        "specifiers"
    ],
    ExportSpecifier: [
        "exported"
    ],
    ExportNamespaceSpecifier: [
        "exported"
    ],
    ExportDefaultSpecifier: [
        "exported"
    ],
    FunctionDeclaration: [
        "id",
        "params"
    ],
    FunctionExpression: [
        "id",
        "params"
    ],
    ArrowFunctionExpression: [
        "params"
    ],
    ObjectMethod: [
        "params"
    ],
    ClassMethod: [
        "params"
    ],
    ClassPrivateMethod: [
        "params"
    ],
    ForInStatement: [
        "left"
    ],
    ForOfStatement: [
        "left"
    ],
    ClassDeclaration: [
        "id"
    ],
    ClassExpression: [
        "id"
    ],
    RestElement: [
        "argument"
    ],
    UpdateExpression: [
        "argument"
    ],
    ObjectProperty: [
        "value"
    ],
    AssignmentPattern: [
        "left"
    ],
    ArrayPattern: [
        "elements"
    ],
    ObjectPattern: [
        "properties"
    ],
    VariableDeclaration: [
        "declarations"
    ],
    VariableDeclarator: [
        "id"
    ]
};

},{"../validators/generated":"bjDwT"}],"7Z4XE":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _generated = require("../validators/generated");
var _generated2 = require("../builders/generated");
var _default = toStatement;
exports.default = _default;
function toStatement(node, ignore) {
    if ((0, _generated.isStatement)(node)) return node;
    let mustHaveId = false;
    let newType;
    if ((0, _generated.isClass)(node)) {
        mustHaveId = true;
        newType = "ClassDeclaration";
    } else if ((0, _generated.isFunction)(node)) {
        mustHaveId = true;
        newType = "FunctionDeclaration";
    } else if ((0, _generated.isAssignmentExpression)(node)) return (0, _generated2.expressionStatement)(node);
    if (mustHaveId && !node.id) newType = false;
    if (!newType) {
        if (ignore) return false;
        else throw new Error(`cannot turn ${node.type} to a statement`);
    }
    node.type = newType;
    return node;
}

},{"../validators/generated":"bjDwT","../builders/generated":"1t4GT"}],"i2VNJ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _isValidIdentifier = require("../validators/isValidIdentifier");
var _generated = require("../builders/generated");
var _default = valueToNode;
exports.default = _default;
const objectToString = Function.call.bind(Object.prototype.toString);
function isRegExp(value) {
    return objectToString(value) === "[object RegExp]";
}
function isPlainObject(value) {
    if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") return false;
    const proto = Object.getPrototypeOf(value);
    return proto === null || Object.getPrototypeOf(proto) === null;
}
function valueToNode(value) {
    if (value === undefined) return (0, _generated.identifier)("undefined");
    if (value === true || value === false) return (0, _generated.booleanLiteral)(value);
    if (value === null) return (0, _generated.nullLiteral)();
    if (typeof value === "string") return (0, _generated.stringLiteral)(value);
    if (typeof value === "number") {
        let result;
        if (Number.isFinite(value)) result = (0, _generated.numericLiteral)(Math.abs(value));
        else {
            let numerator;
            if (Number.isNaN(value)) numerator = (0, _generated.numericLiteral)(0);
            else numerator = (0, _generated.numericLiteral)(1);
            result = (0, _generated.binaryExpression)("/", numerator, (0, _generated.numericLiteral)(0));
        }
        if (value < 0 || Object.is(value, -0)) result = (0, _generated.unaryExpression)("-", result);
        return result;
    }
    if (isRegExp(value)) {
        const pattern = value.source;
        const flags = value.toString().match(/\/([a-z]+|)$/)[1];
        return (0, _generated.regExpLiteral)(pattern, flags);
    }
    if (Array.isArray(value)) return (0, _generated.arrayExpression)(value.map(valueToNode));
    if (isPlainObject(value)) {
        const props = [];
        for (const key of Object.keys(value)){
            let nodeKey;
            if ((0, _isValidIdentifier.default)(key)) nodeKey = (0, _generated.identifier)(key);
            else nodeKey = (0, _generated.stringLiteral)(key);
            props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));
        }
        return (0, _generated.objectExpression)(props);
    }
    throw new Error("don't know how to turn this value into a node");
}

},{"../validators/isValidIdentifier":"gb2G9","../builders/generated":"1t4GT"}],"eboGQ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = appendToMemberExpression;
var _generated = require("../builders/generated");
function appendToMemberExpression(member, append, computed = false) {
    member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed);
    member.property = append;
    member.computed = !!computed;
    return member;
}

},{"../builders/generated":"1t4GT"}],"7zhDm":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inherits;
var _constants = require("../constants");
var _inheritsComments = require("../comments/inheritsComments");
function inherits(child, parent) {
    if (!child || !parent) return child;
    for (const key of _constants.INHERIT_KEYS.optional)if (child[key] == null) child[key] = parent[key];
    for (const key1 of Object.keys(parent))if (key1[0] === "_" && key1 !== "__clone") child[key1] = parent[key1];
    for (const key2 of _constants.INHERIT_KEYS.force)child[key2] = parent[key2];
    (0, _inheritsComments.default)(child, parent);
    return child;
}

},{"../constants":"lrpJ7","../comments/inheritsComments":"j0S4j"}],"avsQy":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = prependToMemberExpression;
var _generated = require("../builders/generated");
function prependToMemberExpression(member, prepend) {
    member.object = (0, _generated.memberExpression)(prepend, member.object);
    return member;
}

},{"../builders/generated":"1t4GT"}],"9r9fp":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _getBindingIdentifiers = require("./getBindingIdentifiers");
var _default = getOuterBindingIdentifiers;
exports.default = _default;
function getOuterBindingIdentifiers(node, duplicates) {
    return (0, _getBindingIdentifiers.default)(node, duplicates, true);
}

},{"./getBindingIdentifiers":"1guAF"}],"8GP2S":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = traverse;
var _definitions = require("../definitions");
function traverse(node, handlers, state) {
    if (typeof handlers === "function") handlers = {
        enter: handlers
    };
    const { enter , exit  } = handlers;
    traverseSimpleImpl(node, enter, exit, state, []);
}
function traverseSimpleImpl(node, enter, exit, state, ancestors) {
    const keys = _definitions.VISITOR_KEYS[node.type];
    if (!keys) return;
    if (enter) enter(node, ancestors, state);
    for (const key of keys){
        const subNode = node[key];
        if (Array.isArray(subNode)) for(let i = 0; i < subNode.length; i++){
            const child = subNode[i];
            if (!child) continue;
            ancestors.push({
                node,
                key,
                index: i
            });
            traverseSimpleImpl(child, enter, exit, state, ancestors);
            ancestors.pop();
        }
        else if (subNode) {
            ancestors.push({
                node,
                key
            });
            traverseSimpleImpl(subNode, enter, exit, state, ancestors);
            ancestors.pop();
        }
    }
    if (exit) exit(node, ancestors, state);
}

},{"../definitions":"dzUB7"}],"eBXmT":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isBinding;
var _getBindingIdentifiers = require("../retrievers/getBindingIdentifiers");
function isBinding(node, parent, grandparent) {
    if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") return false;
    const keys = _getBindingIdentifiers.default.keys[parent.type];
    if (keys) for(let i = 0; i < keys.length; i++){
        const key = keys[i];
        const val = parent[key];
        if (Array.isArray(val)) {
            if (val.indexOf(node) >= 0) return true;
        } else {
            if (val === node) return true;
        }
    }
    return false;
}

},{"../retrievers/getBindingIdentifiers":"1guAF"}],"7cpnc":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isBlockScoped;
var _generated = require("./generated");
var _isLet = require("./isLet");
function isBlockScoped(node) {
    return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);
}

},{"./generated":"bjDwT","./isLet":"iu6ca"}],"iu6ca":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isLet;
var _generated = require("./generated");
var _constants = require("../constants");
function isLet(node) {
    return (0, _generated.isVariableDeclaration)(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
}

},{"./generated":"bjDwT","../constants":"lrpJ7"}],"15E5c":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isImmutable;
var _isType = require("./isType");
var _generated = require("./generated");
function isImmutable(node) {
    if ((0, _isType.default)(node.type, "Immutable")) return true;
    if ((0, _generated.isIdentifier)(node)) {
        if (node.name === "undefined") return true;
        else return false;
    }
    return false;
}

},{"./isType":"dZEXP","./generated":"bjDwT"}],"e2PUg":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isNodesEquivalent;
var _definitions = require("../definitions");
function isNodesEquivalent(a, b) {
    if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) return a === b;
    if (a.type !== b.type) return false;
    const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);
    const visitorKeys = _definitions.VISITOR_KEYS[a.type];
    for (const field of fields){
        if (typeof a[field] !== typeof b[field]) return false;
        if (a[field] == null && b[field] == null) continue;
        else if (a[field] == null || b[field] == null) return false;
        if (Array.isArray(a[field])) {
            if (!Array.isArray(b[field])) return false;
            if (a[field].length !== b[field].length) return false;
            for(let i = 0; i < a[field].length; i++){
                if (!isNodesEquivalent(a[field][i], b[field][i])) return false;
            }
            continue;
        }
        if (typeof a[field] === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
            for (const key of Object.keys(a[field])){
                if (a[field][key] !== b[field][key]) return false;
            }
            continue;
        }
        if (!isNodesEquivalent(a[field], b[field])) return false;
    }
    return true;
}

},{"../definitions":"dzUB7"}],"9QTMn":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isReferenced;
function isReferenced(node, parent, grandparent) {
    switch(parent.type){
        case "MemberExpression":
        case "OptionalMemberExpression":
            if (parent.property === node) return !!parent.computed;
            return parent.object === node;
        case "JSXMemberExpression":
            return parent.object === node;
        case "VariableDeclarator":
            return parent.init === node;
        case "ArrowFunctionExpression":
            return parent.body === node;
        case "PrivateName":
            return false;
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
            if (parent.key === node) return !!parent.computed;
            return false;
        case "ObjectProperty":
            if (parent.key === node) return !!parent.computed;
            return !grandparent || grandparent.type !== "ObjectPattern";
        case "ClassProperty":
            if (parent.key === node) return !!parent.computed;
            return true;
        case "ClassPrivateProperty":
            return parent.key !== node;
        case "ClassDeclaration":
        case "ClassExpression":
            return parent.superClass === node;
        case "AssignmentExpression":
            return parent.right === node;
        case "AssignmentPattern":
            return parent.right === node;
        case "LabeledStatement":
            return false;
        case "CatchClause":
            return false;
        case "RestElement":
            return false;
        case "BreakStatement":
        case "ContinueStatement":
            return false;
        case "FunctionDeclaration":
        case "FunctionExpression":
            return false;
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
            return false;
        case "ExportSpecifier":
            if (grandparent != null && grandparent.source) return false;
            return parent.local === node;
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
            return false;
        case "ImportAttribute":
            return false;
        case "JSXAttribute":
            return false;
        case "ObjectPattern":
        case "ArrayPattern":
            return false;
        case "MetaProperty":
            return false;
        case "ObjectTypeProperty":
            return parent.key !== node;
        case "TSEnumMember":
            return parent.id !== node;
        case "TSPropertySignature":
            if (parent.key === node) return !!parent.computed;
            return true;
    }
    return true;
}

},{}],"eeDGz":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isScope;
var _generated = require("./generated");
function isScope(node, parent) {
    if ((0, _generated.isBlockStatement)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent))) return false;
    if ((0, _generated.isPattern)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent))) return true;
    return (0, _generated.isScopable)(node);
}

},{"./generated":"bjDwT"}],"e0Br2":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isSpecifierDefault;
var _generated = require("./generated");
function isSpecifierDefault(specifier) {
    return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {
        name: "default"
    });
}

},{"./generated":"bjDwT"}],"gDxdp":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isValidES3Identifier;
var _isValidIdentifier = require("./isValidIdentifier");
const RESERVED_WORDS_ES3_ONLY = new Set([
    "abstract",
    "boolean",
    "byte",
    "char",
    "double",
    "enum",
    "final",
    "float",
    "goto",
    "implements",
    "int",
    "interface",
    "long",
    "native",
    "package",
    "private",
    "protected",
    "public",
    "short",
    "static",
    "synchronized",
    "throws",
    "transient",
    "volatile"
]);
function isValidES3Identifier(name) {
    return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
}

},{"./isValidIdentifier":"gb2G9"}],"b5upV":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isVar;
var _generated = require("./generated");
var _constants = require("../constants");
function isVar(node) {
    return (0, _generated.isVariableDeclaration)(node, {
        kind: "var"
    }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
}

},{"./generated":"bjDwT","../constants":"lrpJ7"}],"jfLwn":[function(require,module,exports) {

},{}],"jj9rJ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ImportInjector", {
    enumerable: true,
    get: function() {
        return _importInjector.default;
    }
});
exports.addDefault = addDefault;
exports.addNamed = addNamed;
exports.addNamespace = addNamespace;
exports.addSideEffect = addSideEffect;
Object.defineProperty(exports, "isModule", {
    enumerable: true,
    get: function() {
        return _isModule.default;
    }
});
var _importInjector = require("./import-injector");
var _isModule = require("./is-module");
function addDefault(path, importedSource, opts) {
    return new _importInjector.default(path).addDefault(importedSource, opts);
}
function addNamed(path, name, importedSource, opts) {
    return new _importInjector.default(path).addNamed(name, importedSource, opts);
}
function addNamespace(path, importedSource, opts) {
    return new _importInjector.default(path).addNamespace(importedSource, opts);
}
function addSideEffect(path, importedSource, opts) {
    return new _importInjector.default(path).addSideEffect(importedSource, opts);
}

},{"./import-injector":"8AVac","./is-module":"eQVXU"}],"8AVac":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _assert = require("assert");
var _t = require("@babel/types");
var _importBuilder = require("./import-builder");
var _isModule = require("./is-module");
const { numericLiteral , sequenceExpression  } = _t;
class ImportInjector {
    constructor(path, importedSource, opts){
        this._defaultOpts = {
            importedSource: null,
            importedType: "commonjs",
            importedInterop: "babel",
            importingInterop: "babel",
            ensureLiveReference: false,
            ensureNoContext: false,
            importPosition: "before"
        };
        const programPath = path.find((p)=>p.isProgram()
        );
        this._programPath = programPath;
        this._programScope = programPath.scope;
        this._hub = programPath.hub;
        this._defaultOpts = this._applyDefaults(importedSource, opts, true);
    }
    addDefault(importedSourceIn, opts) {
        return this.addNamed("default", importedSourceIn, opts);
    }
    addNamed(importName, importedSourceIn, opts) {
        _assert(typeof importName === "string");
        return this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);
    }
    addNamespace(importedSourceIn, opts) {
        return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);
    }
    addSideEffect(importedSourceIn, opts) {
        return this._generateImport(this._applyDefaults(importedSourceIn, opts), false);
    }
    _applyDefaults(importedSource, opts, isInit = false) {
        const optsList = [];
        if (typeof importedSource === "string") {
            optsList.push({
                importedSource
            });
            optsList.push(opts);
        } else {
            _assert(!opts, "Unexpected secondary arguments.");
            optsList.push(importedSource);
        }
        const newOpts = Object.assign({}, this._defaultOpts);
        for (const opts1 of optsList){
            if (!opts1) continue;
            Object.keys(newOpts).forEach((key)=>{
                if (opts1[key] !== undefined) newOpts[key] = opts1[key];
            });
            if (!isInit) {
                if (opts1.nameHint !== undefined) newOpts.nameHint = opts1.nameHint;
                if (opts1.blockHoist !== undefined) newOpts.blockHoist = opts1.blockHoist;
            }
        }
        return newOpts;
    }
    _generateImport(opts, importName) {
        const isDefault = importName === "default";
        const isNamed = !!importName && !isDefault;
        const isNamespace = importName === null;
        const { importedSource , importedType , importedInterop , importingInterop , ensureLiveReference , ensureNoContext , nameHint , importPosition , blockHoist  } = opts;
        let name = nameHint || importName;
        const isMod = (0, _isModule.default)(this._programPath);
        const isModuleForNode = isMod && importingInterop === "node";
        const isModuleForBabel = isMod && importingInterop === "babel";
        if (importPosition === "after" && !isMod) throw new Error(`"importPosition": "after" is only supported in modules`);
        const builder = new _importBuilder.default(importedSource, this._programScope, this._hub);
        if (importedType === "es6") {
            if (!isModuleForNode && !isModuleForBabel) throw new Error("Cannot import an ES6 module from CommonJS");
            builder.import();
            if (isNamespace) builder.namespace(nameHint || importedSource);
            else if (isDefault || isNamed) builder.named(name, importName);
        } else if (importedType !== "commonjs") throw new Error(`Unexpected interopType "${importedType}"`);
        else if (importedInterop === "babel") {
            if (isModuleForNode) {
                name = name !== "default" ? name : importedSource;
                const es6Default = `${importedSource}$es6Default`;
                builder.import();
                if (isNamespace) builder.default(es6Default).var(name || importedSource).wildcardInterop();
                else if (isDefault) {
                    if (ensureLiveReference) builder.default(es6Default).var(name || importedSource).defaultInterop().read("default");
                    else builder.default(es6Default).var(name).defaultInterop().prop(importName);
                } else if (isNamed) builder.default(es6Default).read(importName);
            } else if (isModuleForBabel) {
                builder.import();
                if (isNamespace) builder.namespace(name || importedSource);
                else if (isDefault || isNamed) builder.named(name, importName);
            } else {
                builder.require();
                if (isNamespace) builder.var(name || importedSource).wildcardInterop();
                else if ((isDefault || isNamed) && ensureLiveReference) {
                    if (isDefault) {
                        name = name !== "default" ? name : importedSource;
                        builder.var(name).read(importName);
                        builder.defaultInterop();
                    } else builder.var(importedSource).read(importName);
                } else if (isDefault) builder.var(name).defaultInterop().prop(importName);
                else if (isNamed) builder.var(name).prop(importName);
            }
        } else if (importedInterop === "compiled") {
            if (isModuleForNode) {
                builder.import();
                if (isNamespace) builder.default(name || importedSource);
                else if (isDefault || isNamed) builder.default(importedSource).read(name);
            } else if (isModuleForBabel) {
                builder.import();
                if (isNamespace) builder.namespace(name || importedSource);
                else if (isDefault || isNamed) builder.named(name, importName);
            } else {
                builder.require();
                if (isNamespace) builder.var(name || importedSource);
                else if (isDefault || isNamed) {
                    if (ensureLiveReference) builder.var(importedSource).read(name);
                    else builder.prop(importName).var(name);
                }
            }
        } else if (importedInterop === "uncompiled") {
            if (isDefault && ensureLiveReference) throw new Error("No live reference for commonjs default");
            if (isModuleForNode) {
                builder.import();
                if (isNamespace) builder.default(name || importedSource);
                else if (isDefault) builder.default(name);
                else if (isNamed) builder.default(importedSource).read(name);
            } else if (isModuleForBabel) {
                builder.import();
                if (isNamespace) builder.default(name || importedSource);
                else if (isDefault) builder.default(name);
                else if (isNamed) builder.named(name, importName);
            } else {
                builder.require();
                if (isNamespace) builder.var(name || importedSource);
                else if (isDefault) builder.var(name);
                else if (isNamed) {
                    if (ensureLiveReference) builder.var(importedSource).read(name);
                    else builder.var(name).prop(importName);
                }
            }
        } else throw new Error(`Unknown importedInterop "${importedInterop}".`);
        const { statements , resultName  } = builder.done();
        this._insertStatements(statements, importPosition, blockHoist);
        if ((isDefault || isNamed) && ensureNoContext && resultName.type !== "Identifier") return sequenceExpression([
            numericLiteral(0),
            resultName
        ]);
        return resultName;
    }
    _insertStatements(statements, importPosition = "before", blockHoist = 3) {
        const body = this._programPath.get("body");
        if (importPosition === "after") {
            for(let i = body.length - 1; i >= 0; i--)if (body[i].isImportDeclaration()) {
                body[i].insertAfter(statements);
                return;
            }
        } else {
            statements.forEach((node)=>{
                node._blockHoist = blockHoist;
            });
            const targetPath = body.find((p)=>{
                const val = p.node._blockHoist;
                return Number.isFinite(val) && val < 4;
            });
            if (targetPath) {
                targetPath.insertBefore(statements);
                return;
            }
        }
        this._programPath.unshiftContainer("body", statements);
    }
}
exports.default = ImportInjector;

},{"assert":"bNzhs","@babel/types":"dsWVF","./import-builder":"bzBEl","./is-module":"eQVXU"}],"bNzhs":[function(require,module,exports) {
// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';
var process = require("process");
function _typeof(obj1) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj1);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
var _require = require('./internal/errors'), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
var AssertionError = require('./internal/assert/assertion_error');
var _require2 = require('util/'), inspect = _require2.inspect;
var _require$types = require('util/').types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
var objectAssign = Object.assign ? Object.assign : require('es6-object-assign').assign;
var objectIs = Object.is ? Object.is : require('object-is');
var errorCache = new Map();
var isDeepEqual;
var isDeepStrictEqual;
var parseExpressionAt;
var findNodeAround;
var decoder;
function lazyLoadComparison() {
    var comparison = require('./internal/util/comparisons');
    isDeepEqual = comparison.isDeepEqual;
    isDeepStrictEqual = comparison.isDeepStrictEqual;
} // Escape control characters but not \n and \t to keep the line breaks and
// indentation intact.
// eslint-disable-next-line no-control-regex
var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
var meta = [
    "\\u0000",
    "\\u0001",
    "\\u0002",
    "\\u0003",
    "\\u0004",
    "\\u0005",
    "\\u0006",
    "\\u0007",
    '\\b',
    '',
    '',
    "\\u000b",
    '\\f',
    '',
    "\\u000e",
    "\\u000f",
    "\\u0010",
    "\\u0011",
    "\\u0012",
    "\\u0013",
    "\\u0014",
    "\\u0015",
    "\\u0016",
    "\\u0017",
    "\\u0018",
    "\\u0019",
    "\\u001a",
    "\\u001b",
    "\\u001c",
    "\\u001d",
    "\\u001e",
    "\\u001f"
];
var escapeFn = function escapeFn(str) {
    return meta[str.charCodeAt(0)];
};
var warned = false; // The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.
var assert = module.exports = ok;
var NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided. All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.
function innerFail(obj) {
    if (obj.message instanceof Error) throw obj.message;
    throw new AssertionError(obj);
}
function fail(actual, expected, message, operator, stackStartFn) {
    var argsLen = arguments.length;
    var internalMessage;
    if (argsLen === 0) internalMessage = 'Failed';
    else if (argsLen === 1) {
        message = actual;
        actual = undefined;
    } else {
        if (warned === false) {
            warned = true;
            var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
            warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", 'DeprecationWarning', 'DEP0094');
        }
        if (argsLen === 2) operator = '!=';
    }
    if (message instanceof Error) throw message;
    var errArgs = {
        actual: actual,
        expected: expected,
        operator: operator === undefined ? 'fail' : operator,
        stackStartFn: stackStartFn || fail
    };
    if (message !== undefined) errArgs.message = message;
    var err = new AssertionError(errArgs);
    if (internalMessage) {
        err.message = internalMessage;
        err.generatedMessage = true;
    }
    throw err;
}
assert.fail = fail; // The AssertionError is defined in internal/error.
assert.AssertionError = AssertionError;
function innerOk(fn, argLen, value, message) {
    if (!value) {
        var generatedMessage = false;
        if (argLen === 0) {
            generatedMessage = true;
            message = 'No value argument passed to `assert.ok()`';
        } else if (message instanceof Error) throw message;
        var err = new AssertionError({
            actual: value,
            expected: true,
            message: message,
            operator: '==',
            stackStartFn: fn
        });
        err.generatedMessage = generatedMessage;
        throw err;
    }
} // Pure assertion tests whether a value is truthy, as determined
// by !!value.
function ok() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
    innerOk.apply(void 0, [
        ok,
        args.length
    ].concat(args));
}
assert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.
/* eslint-disable no-restricted-properties */ assert.equal = function equal(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS('actual', 'expected');
     // eslint-disable-next-line eqeqeq
    if (actual != expected) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: '==',
        stackStartFn: equal
    });
}; // The non-equality assertion tests for whether two objects are not
// equal with !=.
assert.notEqual = function notEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS('actual', 'expected');
     // eslint-disable-next-line eqeqeq
    if (actual == expected) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: '!=',
        stackStartFn: notEqual
    });
}; // The equivalence assertion tests a deep equality relation.
assert.deepEqual = function deepEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS('actual', 'expected');
    if (isDeepEqual === undefined) lazyLoadComparison();
    if (!isDeepEqual(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: 'deepEqual',
        stackStartFn: deepEqual
    });
}; // The non-equivalence assertion tests for any deep inequality.
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS('actual', 'expected');
    if (isDeepEqual === undefined) lazyLoadComparison();
    if (isDeepEqual(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: 'notDeepEqual',
        stackStartFn: notDeepEqual
    });
};
/* eslint-enable */ assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS('actual', 'expected');
    if (isDeepEqual === undefined) lazyLoadComparison();
    if (!isDeepStrictEqual(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: 'deepStrictEqual',
        stackStartFn: deepStrictEqual
    });
};
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS('actual', 'expected');
    if (isDeepEqual === undefined) lazyLoadComparison();
    if (isDeepStrictEqual(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: 'notDeepStrictEqual',
        stackStartFn: notDeepStrictEqual
    });
}
assert.strictEqual = function strictEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS('actual', 'expected');
    if (!objectIs(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: 'strictEqual',
        stackStartFn: strictEqual
    });
};
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
    if (arguments.length < 2) throw new ERR_MISSING_ARGS('actual', 'expected');
    if (objectIs(actual, expected)) innerFail({
        actual: actual,
        expected: expected,
        message: message,
        operator: 'notStrictEqual',
        stackStartFn: notStrictEqual
    });
};
var Comparison = function Comparison1(obj, keys, actual) {
    var _this = this;
    _classCallCheck(this, Comparison1);
    keys.forEach(function(key) {
        if (key in obj) {
            if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) _this[key] = actual[key];
            else _this[key] = obj[key];
        }
    });
};
function compareExceptionKey(actual, expected, key, message, keys, fn) {
    if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
        if (!message) {
            // Create placeholder objects to create a nice output.
            var a = new Comparison(actual, keys);
            var b = new Comparison(expected, keys, actual);
            var err = new AssertionError({
                actual: a,
                expected: b,
                operator: 'deepStrictEqual',
                stackStartFn: fn
            });
            err.actual = actual;
            err.expected = expected;
            err.operator = fn.name;
            throw err;
        }
        innerFail({
            actual: actual,
            expected: expected,
            message: message,
            operator: fn.name,
            stackStartFn: fn
        });
    }
}
function expectedException(actual, expected, msg, fn) {
    if (typeof expected !== 'function') {
        if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.
        if (arguments.length === 2) throw new ERR_INVALID_ARG_TYPE('expected', [
            'Function',
            'RegExp'
        ], expected);
         // Handle primitives properly.
        if (_typeof(actual) !== 'object' || actual === null) {
            var err = new AssertionError({
                actual: actual,
                expected: expected,
                message: msg,
                operator: 'deepStrictEqual',
                stackStartFn: fn
            });
            err.operator = fn.name;
            throw err;
        }
        var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
        // as well.
        if (expected instanceof Error) keys.push('name', 'message');
        else if (keys.length === 0) throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
        if (isDeepEqual === undefined) lazyLoadComparison();
        keys.forEach(function(key) {
            if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) return;
            compareExceptionKey(actual, expected, key, msg, keys, fn);
        });
        return true;
    } // Guard instanceof against arrow functions as they don't have a prototype.
    if (expected.prototype !== undefined && actual instanceof expected) return true;
    if (Error.isPrototypeOf(expected)) return false;
    return expected.call({}, actual) === true;
}
function getActual(fn) {
    if (typeof fn !== 'function') throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
    try {
        fn();
    } catch (e) {
        return e;
    }
    return NO_EXCEPTION_SENTINEL;
}
function checkIsPromise(obj) {
    // Accept native ES6 promises and promises that are implemented in a similar
    // way. Do not accept thenables that use a function as `obj` and that have no
    // `catch` handler.
    // TODO: thenables are checked up until they have the correct methods,
    // but according to documentation, the `then` method should receive
    // the `fulfill` and `reject` arguments as well or it may be never resolved.
    return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
}
function waitForActual(promiseFn) {
    return Promise.resolve().then(function() {
        var resultPromise;
        if (typeof promiseFn === 'function') {
            // Return a rejected promise if `promiseFn` throws synchronously.
            resultPromise = promiseFn(); // Fail in case no promise is returned.
            if (!checkIsPromise(resultPromise)) throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
        } else if (checkIsPromise(promiseFn)) resultPromise = promiseFn;
        else throw new ERR_INVALID_ARG_TYPE('promiseFn', [
            'Function',
            'Promise'
        ], promiseFn);
        return Promise.resolve().then(function() {
            return resultPromise;
        }).then(function() {
            return NO_EXCEPTION_SENTINEL;
        }).catch(function(e) {
            return e;
        });
    });
}
function expectsError(stackStartFn, actual, error, message) {
    if (typeof error === 'string') {
        if (arguments.length === 4) throw new ERR_INVALID_ARG_TYPE('error', [
            'Object',
            'Error',
            'Function',
            'RegExp'
        ], error);
        if (_typeof(actual) === 'object' && actual !== null) {
            if (actual.message === error) throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
        } else if (actual === error) throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
        message = error;
        error = undefined;
    } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') throw new ERR_INVALID_ARG_TYPE('error', [
        'Object',
        'Error',
        'Function',
        'RegExp'
    ], error);
    if (actual === NO_EXCEPTION_SENTINEL) {
        var details = '';
        if (error && error.name) details += " (".concat(error.name, ")");
        details += message ? ": ".concat(message) : '.';
        var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
        innerFail({
            actual: undefined,
            expected: error,
            operator: stackStartFn.name,
            message: "Missing expected ".concat(fnType).concat(details),
            stackStartFn: stackStartFn
        });
    }
    if (error && !expectedException(actual, error, message, stackStartFn)) throw actual;
}
function expectsNoError(stackStartFn, actual, error, message) {
    if (actual === NO_EXCEPTION_SENTINEL) return;
    if (typeof error === 'string') {
        message = error;
        error = undefined;
    }
    if (!error || expectedException(actual, error)) {
        var details = message ? ": ".concat(message) : '.';
        var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
        innerFail({
            actual: actual,
            expected: error,
            operator: stackStartFn.name,
            message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
            stackStartFn: stackStartFn
        });
    }
    throw actual;
}
assert.throws = function throws(promiseFn) {
    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)args[_key2 - 1] = arguments[_key2];
    expectsError.apply(void 0, [
        throws,
        getActual(promiseFn)
    ].concat(args));
};
assert.rejects = function rejects(promiseFn) {
    for(var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++)args[_key3 - 1] = arguments[_key3];
    return waitForActual(promiseFn).then(function(result) {
        return expectsError.apply(void 0, [
            rejects,
            result
        ].concat(args));
    });
};
assert.doesNotThrow = function doesNotThrow(fn) {
    for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++)args[_key4 - 1] = arguments[_key4];
    expectsNoError.apply(void 0, [
        doesNotThrow,
        getActual(fn)
    ].concat(args));
};
assert.doesNotReject = function doesNotReject(fn) {
    for(var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++)args[_key5 - 1] = arguments[_key5];
    return waitForActual(fn).then(function(result) {
        return expectsNoError.apply(void 0, [
            doesNotReject,
            result
        ].concat(args));
    });
};
assert.ifError = function ifError(err) {
    if (err !== null && err !== undefined) {
        var message = 'ifError got unwanted exception: ';
        if (_typeof(err) === 'object' && typeof err.message === 'string') {
            if (err.message.length === 0 && err.constructor) message += err.constructor.name;
            else message += err.message;
        } else message += inspect(err);
        var newErr = new AssertionError({
            actual: err,
            expected: null,
            operator: 'ifError',
            message: message,
            stackStartFn: ifError
        }); // Make sure we actually have a stack trace!
        var origStack = err.stack;
        if (typeof origStack === 'string') {
            // This will remove any duplicated frames from the error frames taken
            // from within `ifError` and add the original error frames to the newly
            // created ones.
            var tmp2 = origStack.split('\n');
            tmp2.shift(); // Filter all frames existing in err.stack.
            var tmp1 = newErr.stack.split('\n');
            for(var i = 0; i < tmp2.length; i++){
                // Find the first occurrence of the frame.
                var pos = tmp1.indexOf(tmp2[i]);
                if (pos !== -1) {
                    // Only keep new frames.
                    tmp1 = tmp1.slice(0, pos);
                    break;
                }
            }
            newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
        }
        throw newErr;
    }
}; // Expose a strict only variant of assert
function strict() {
    for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++)args[_key6] = arguments[_key6];
    innerOk.apply(void 0, [
        strict,
        args.length
    ].concat(args));
}
assert.strict = objectAssign(strict, assert, {
    equal: assert.strictEqual,
    deepEqual: assert.deepStrictEqual,
    notEqual: assert.notStrictEqual,
    notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

},{"process":"kKEHw","./internal/errors":"cQb4R","./internal/assert/assertion_error":"buLhQ","util/":"h4AnS","es6-object-assign":"lzBrv","object-is":"8lNUw","./internal/util/comparisons":"6yCqR"}],"kKEHw":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function() {
    try {
        if (typeof setTimeout === 'function') cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e1) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error('process.binding is not supported');
};
process.cwd = function() {
    return '/';
};
process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() {
    return 0;
};

},{}],"cQb4R":[function(require,module,exports) {
// Currently in sync with Node.js lib/internal/errors.js
// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f
/* eslint node-core/documented-errors: "error" */ /* eslint node-core/alphabetize-errors: "error" */ /* eslint node-core/prefer-util-format-errors: "error" */ 'use strict'; // The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.
function _typeof(obj1) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj1);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _getPrototypeOf(o1) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o1);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o2, p1) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o2, p1);
}
var codes = {}; // Lazy loaded
var assert;
var util;
function createErrorType(code, message, Base) {
    if (!Base) Base = Error;
    function getMessage(arg1, arg2, arg3) {
        if (typeof message === 'string') return message;
        else return message(arg1, arg2, arg3);
    }
    var NodeError1 = /*#__PURE__*/ function(_Base) {
        _inherits(NodeError, _Base);
        function NodeError(arg1, arg2, arg3) {
            var _this;
            _classCallCheck(this, NodeError);
            _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
            _this.code = code;
            return _this;
        }
        return NodeError;
    }(Base);
    codes[code] = NodeError1;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
            return String(i);
        });
        if (len > 2) return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
        else if (len === 2) return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        else return "of ".concat(thing, " ").concat(expected[0]);
    } else return "of ".concat(thing, " ").concat(String(expected));
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) this_len = str.length;
    return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
    if (typeof start !== 'number') start = 0;
    if (start + search.length > str.length) return false;
    else return str.indexOf(search, start) !== -1;
}
createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function(name, expected, actual) {
    if (assert === undefined) assert = require('../assert');
    assert(typeof name === 'string', "'name' must be a string"); // determiner: 'must be' or 'must not be'
    var determiner;
    if (typeof expected === 'string' && startsWith(expected, 'not ')) {
        determiner = 'must not be';
        expected = expected.replace(/^not /, '');
    } else determiner = 'must be';
    var msg;
    if (endsWith(name, ' argument')) // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
    else {
        var type = includes(name, '.') ? 'property' : 'argument';
        msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
    } // TODO(BridgeAR): Improve the output by showing `null` and similar.
    msg += ". Received type ".concat(_typeof(actual));
    return msg;
}, TypeError);
createErrorType('ERR_INVALID_ARG_VALUE', function(name, value) {
    var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
    if (util === undefined) util = require('util/');
    var inspected = util.inspect(value);
    if (inspected.length > 128) inspected = "".concat(inspected.slice(0, 128), "...");
    return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError, RangeError);
createErrorType('ERR_INVALID_RETURN_VALUE', function(input, name, value) {
    var type;
    if (value && value.constructor && value.constructor.name) type = "instance of ".concat(value.constructor.name);
    else type = "type ".concat(_typeof(value));
    return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
}, TypeError);
createErrorType('ERR_MISSING_ARGS', function() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
    if (assert === undefined) assert = require('../assert');
    assert(args.length > 0, 'At least one arg needs to be specified');
    var msg = 'The ';
    var len = args.length;
    args = args.map(function(a) {
        return "\"".concat(a, "\"");
    });
    switch(len){
        case 1:
            msg += "".concat(args[0], " argument");
            break;
        case 2:
            msg += "".concat(args[0], " and ").concat(args[1], " arguments");
            break;
        default:
            msg += args.slice(0, len - 1).join(', ');
            msg += ", and ".concat(args[len - 1], " arguments");
            break;
    }
    return "".concat(msg, " must be specified");
}, TypeError);
module.exports.codes = codes;

},{"../assert":"bNzhs","util/":"h4AnS"}],"h4AnS":[function(require,module,exports) {
var process = require("process");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for(var i = 0; i < keys.length; i++)descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    return descriptors;
};
var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
    if (!isString(f)) {
        var objects = [];
        for(var i = 0; i < arguments.length; i++)objects.push(inspect(arguments[i]));
        return objects.join(' ');
    }
    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%') return '%';
        if (i >= len) return x;
        switch(x){
            case '%s':
                return String(args[i++]);
            case '%d':
                return Number(args[i++]);
            case '%j':
                try {
                    return JSON.stringify(args[i++]);
                } catch (_) {
                    return '[Circular]';
                }
            default:
                return x;
        }
    });
    for(var x1 = args[i]; i < len; x1 = args[++i])if (isNull(x1) || !isObject(x1)) str += ' ' + x1;
    else str += ' ' + inspect(x1);
    return str;
};
// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
    if (typeof process !== 'undefined' && process.noDeprecation === true) return fn;
    // Allow for deprecating things in the process of starting up.
    if (typeof process === 'undefined') return function() {
        return exports.deprecate(fn, msg).apply(this, arguments);
    };
    var warned = false;
    function deprecated() {
        if (!warned) {
            if (process.throwDeprecation) throw new Error(msg);
            else if (process.traceDeprecation) console.trace(msg);
            else console.error(msg);
            warned = true;
        }
        return fn.apply(this, arguments);
    }
    return deprecated;
};
var debugs = {};
var debugEnvRegex = /^$/;
var debugEnv;
exports.debuglog = function(set) {
    set = set.toUpperCase();
    if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
            var pid = process.pid;
            debugs[set] = function() {
                var msg = exports.format.apply(exports, arguments);
                console.error('%s %d: %s', set, pid, msg);
            };
        } else debugs[set] = function() {};
    }
    return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */ /* legacy: obj, showHidden, depth, colors*/ function inspect(obj, opts) {
    // default options
    var ctx = {
        seen: [],
        stylize: stylizeNoColor
    };
    // legacy...
    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];
    if (isBoolean(opts)) // legacy...
    ctx.showHidden = opts;
    else if (opts) // got an "options" object
    exports._extend(ctx, opts);
    // set default options
    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;
// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
    'bold': [
        1,
        22
    ],
    'italic': [
        3,
        23
    ],
    'underline': [
        4,
        24
    ],
    'inverse': [
        7,
        27
    ],
    'white': [
        37,
        39
    ],
    'grey': [
        90,
        39
    ],
    'black': [
        30,
        39
    ],
    'blue': [
        34,
        39
    ],
    'cyan': [
        36,
        39
    ],
    'green': [
        32,
        39
    ],
    'magenta': [
        35,
        39
    ],
    'red': [
        31,
        39
    ],
    'yellow': [
        33,
        39
    ]
};
// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
    'special': 'cyan',
    'number': 'yellow',
    'boolean': 'yellow',
    'undefined': 'grey',
    'null': 'bold',
    'string': 'green',
    'date': 'magenta',
    // "name": intentionally not styling
    'regexp': 'red'
};
function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];
    if (style) return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
    else return str;
}
function stylizeNoColor(str, styleType) {
    return str;
}
function arrayToHash(array) {
    var hash = {};
    array.forEach(function(val, idx) {
        hash[val] = true;
    });
    return hash;
}
function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) ret = formatValue(ctx, ret, recurseTimes);
        return ret;
    }
    // Primitive types cannot have properties
    var primitive = formatPrimitive(ctx, value);
    if (primitive) return primitive;
    // Look up the keys of the object.
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);
    if (ctx.showHidden) keys = Object.getOwnPropertyNames(value);
    // IE doesn't make error fields non-enumerable
    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) return formatError(value);
    // Some type of object without properties can be shortcutted.
    if (keys.length === 0) {
        if (isFunction(value)) {
            var name = value.name ? ': ' + value.name : '';
            return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        if (isDate(value)) return ctx.stylize(Date.prototype.toString.call(value), 'date');
        if (isError(value)) return formatError(value);
    }
    var base = '', array = false, braces = [
        '{',
        '}'
    ];
    // Make Array say that they are Array
    if (isArray(value)) {
        array = true;
        braces = [
            '[',
            ']'
        ];
    }
    // Make functions say that they are functions
    if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
    }
    // Make RegExps say that they are RegExps
    if (isRegExp(value)) base = ' ' + RegExp.prototype.toString.call(value);
    // Make dates with properties first say the date
    if (isDate(value)) base = ' ' + Date.prototype.toUTCString.call(value);
    // Make error with message first say the error
    if (isError(value)) base = ' ' + formatError(value);
    if (keys.length === 0 && (!array || value.length == 0)) return braces[0] + base + braces[1];
    if (recurseTimes < 0) {
        if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        else return ctx.stylize('[Object]', 'special');
    }
    ctx.seen.push(value);
    var output;
    if (array) output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    else output = keys.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
    if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
    }
    if (isNumber(value)) return ctx.stylize('' + value, 'number');
    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
    // For some reason typeof null is "object", so special case here.
    if (isNull(value)) return ctx.stylize('null', 'null');
}
function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for(var i = 0, l = value.length; i < l; ++i)if (hasOwnProperty(value, String(i))) output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    else output.push('');
    keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    });
    return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
    };
    if (desc.get) {
        if (desc.set) str = ctx.stylize('[Getter/Setter]', 'special');
        else str = ctx.stylize('[Getter]', 'special');
    } else if (desc.set) str = ctx.stylize('[Setter]', 'special');
    if (!hasOwnProperty(visibleKeys, key)) name = '[' + key + ']';
    if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) str = formatValue(ctx, desc.value, null);
            else str = formatValue(ctx, desc.value, recurseTimes - 1);
            if (str.indexOf('\n') > -1) {
                if (array) str = str.split('\n').map(function(line) {
                    return '  ' + line;
                }).join('\n').substr(2);
                else str = '\n' + str.split('\n').map(function(line) {
                    return '   ' + line;
                }).join('\n');
            }
        } else str = ctx.stylize('[Circular]', 'special');
    }
    if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) return str;
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = ctx.stylize(name, 'name');
        } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, 'string');
        }
    }
    return name + ': ' + str;
}
function reduceToSingleString(output, base, braces) {
    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    }, 0);
    if (length > 60) return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}
// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = require('./support/types');
function isArray(ar) {
    return Array.isArray(ar);
}
exports.isArray = isArray;
function isBoolean(arg) {
    return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;
function isNull(arg) {
    return arg === null;
}
exports.isNull = isNull;
function isNullOrUndefined(arg) {
    return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {
    return typeof arg === 'number';
}
exports.isNumber = isNumber;
function isString(arg) {
    return typeof arg === 'string';
}
exports.isString = isString;
function isSymbol(arg) {
    return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;
function isUndefined(arg) {
    return arg === void 0;
}
exports.isUndefined = isUndefined;
function isRegExp(re) {
    return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;
function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;
function isDate(d) {
    return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;
function isError(e) {
    return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;
function isFunction(arg) {
    return typeof arg === 'function';
}
exports.isFunction = isFunction;
function isPrimitive(arg) {
    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;
exports.isBuffer = require('./support/isBuffer');
function objectToString(o) {
    return Object.prototype.toString.call(o);
}
function pad(n) {
    return n < 10 ? '0' + n.toString(10) : n.toString(10);
}
var months = [
    'Jan',
    'Feb',
    'Mar',
    'Apr',
    'May',
    'Jun',
    'Jul',
    'Aug',
    'Sep',
    'Oct',
    'Nov',
    'Dec'
];
// 26 Feb 16:19:34
function timestamp() {
    var d = new Date();
    var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
    ].join(':');
    return [
        d.getDate(),
        months[d.getMonth()],
        time
    ].join(' ');
}
// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
    console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */ exports.inherits = require('inherits');
exports._extend = function(origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !isObject(add)) return origin;
    var keys = Object.keys(add);
    var i = keys.length;
    while(i--)origin[keys[i]] = add[keys[i]];
    return origin;
};
function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;
exports.promisify = function promisify(original) {
    if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');
    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== 'function') throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
        return fn;
    }
    function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
        });
        var args = [];
        for(var i = 0; i < arguments.length; i++)args.push(arguments[i]);
        args.push(function(err, value) {
            if (err) promiseReject(err);
            else promiseResolve(value);
        });
        try {
            original.apply(this, args);
        } catch (err) {
            promiseReject(err);
        }
        return promise;
    }
    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};
exports.promisify.custom = kCustomPromisifiedSymbol;
function callbackifyOnRejected(reason, cb) {
    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
    // Because `null` is a special error value in callbacks which means "no error
    // occurred", we error-wrap so the callback consumer can distinguish between
    // "the promise rejected with null" or "the promise fulfilled with undefined".
    if (!reason) {
        var newReason = new Error('Promise was rejected with a falsy value');
        newReason.reason = reason;
        reason = newReason;
    }
    return cb(reason);
}
function callbackify(original) {
    if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');
    // We DO NOT return the promise as it gives the user a false sense that
    // the promise is actually somehow related to the callback's execution
    // and that the callback throwing will reject the promise.
    function callbackified() {
        var args = [];
        for(var i = 0; i < arguments.length; i++)args.push(arguments[i]);
        var maybeCb = args.pop();
        if (typeof maybeCb !== 'function') throw new TypeError('The last argument must be of type Function');
        var self = this;
        var cb = function() {
            return maybeCb.apply(self, arguments);
        };
        // In true node style we process the callback on `nextTick` with all the
        // implications (stack, `uncaughtException`, `async_hooks`)
        original.apply(this, args).then(function(ret) {
            process.nextTick(cb.bind(null, null, ret));
        }, function(rej) {
            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
        });
    }
    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
    return callbackified;
}
exports.callbackify = callbackify;

},{"process":"kKEHw","./support/types":"5WMGx","./support/isBuffer":"8CRCz","inherits":"8TdOm"}],"5WMGx":[function(require,module,exports) {
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
'use strict';
var isArgumentsObject = require('is-arguments');
var isGeneratorFunction = require('is-generator-function');
var whichTypedArray = require('which-typed-array');
var isTypedArray = require('is-typed-array');
function uncurryThis(f) {
    return f.call.bind(f);
}
var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';
var ObjectToString = uncurryThis(Object.prototype.toString);
var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);
if (BigIntSupported) var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
if (SymbolSupported) var symbolValue = uncurryThis(Symbol.prototype.valueOf);
function checkBoxedPrimitive(value, prototypeValueOf) {
    if (typeof value !== 'object') return false;
    try {
        prototypeValueOf(value);
        return true;
    } catch (e) {
        return false;
    }
}
exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;
// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
    return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && typeof input === 'object' && typeof input.then === 'function' && typeof input.catch === 'function';
}
exports.isPromise = isPromise;
function isArrayBufferView(value) {
    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) return ArrayBuffer.isView(value);
    return isTypedArray(value) || isDataView(value);
}
exports.isArrayBufferView = isArrayBufferView;
function isUint8Array(value) {
    return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;
function isUint8ClampedArray(value) {
    return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;
function isUint16Array(value) {
    return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;
function isUint32Array(value) {
    return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;
function isInt8Array(value) {
    return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;
function isInt16Array(value) {
    return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;
function isInt32Array(value) {
    return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;
function isFloat32Array(value) {
    return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;
function isFloat64Array(value) {
    return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;
function isBigInt64Array(value) {
    return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;
function isBigUint64Array(value) {
    return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;
function isMapToString(value) {
    return ObjectToString(value) === '[object Map]';
}
isMapToString.working = typeof Map !== 'undefined' && isMapToString(new Map());
function isMap(value) {
    if (typeof Map === 'undefined') return false;
    return isMapToString.working ? isMapToString(value) : value instanceof Map;
}
exports.isMap = isMap;
function isSetToString(value) {
    return ObjectToString(value) === '[object Set]';
}
isSetToString.working = typeof Set !== 'undefined' && isSetToString(new Set());
function isSet(value) {
    if (typeof Set === 'undefined') return false;
    return isSetToString.working ? isSetToString(value) : value instanceof Set;
}
exports.isSet = isSet;
function isWeakMapToString(value) {
    return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap());
function isWeakMap(value) {
    if (typeof WeakMap === 'undefined') return false;
    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;
function isWeakSetToString(value) {
    return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet());
function isWeakSet(value) {
    return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;
function isArrayBufferToString(value) {
    return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && isArrayBufferToString(new ArrayBuffer());
function isArrayBuffer(value) {
    if (typeof ArrayBuffer === 'undefined') return false;
    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;
function isDataViewToString(value) {
    return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
function isDataView(value) {
    if (typeof DataView === 'undefined') return false;
    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
}
exports.isDataView = isDataView;
// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
    return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
    if (typeof SharedArrayBufferCopy === 'undefined') return false;
    if (typeof isSharedArrayBufferToString.working === 'undefined') isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;
function isAsyncFunction(value) {
    return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;
function isMapIterator(value) {
    return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;
function isSetIterator(value) {
    return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;
function isGeneratorObject(value) {
    return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;
function isWebAssemblyCompiledModule(value) {
    return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
function isNumberObject(value) {
    return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;
function isStringObject(value) {
    return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;
function isBooleanObject(value) {
    return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;
function isBigIntObject(value) {
    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;
function isSymbolObject(value) {
    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;
function isBoxedPrimitive(value) {
    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
}
exports.isBoxedPrimitive = isBoxedPrimitive;
function isAnyArrayBuffer(value) {
    return typeof Uint8Array !== 'undefined' && (isArrayBuffer(value) || isSharedArrayBuffer(value));
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;
[
    'isProxy',
    'isExternal',
    'isModuleNamespaceObject'
].forEach(function(method) {
    Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
            throw new Error(method + ' is not supported in userland');
        }
    });
});

},{"is-arguments":"kG9o4","is-generator-function":"fFywx","which-typed-array":"76zk9","is-typed-array":"dPPDl"}],"kG9o4":[function(require,module,exports) {
'use strict';
var hasToStringTag = require('has-tostringtag/shams')();
var callBound = require('call-bind/callBound');
var $toString = callBound('Object.prototype.toString');
var isStandardArguments = function isArguments(value) {
    if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) return false;
    return $toString(value) === '[object Arguments]';
};
var isLegacyArguments = function isArguments(value) {
    if (isStandardArguments(value)) return true;
    return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && $toString(value) !== '[object Array]' && $toString(value.callee) === '[object Function]';
};
var supportsStandardArguments = function() {
    return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests
module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{"has-tostringtag/shams":"93Ahn","call-bind/callBound":"3u0uq"}],"93Ahn":[function(require,module,exports) {
'use strict';
var hasSymbols = require('has-symbols/shams');
module.exports = function hasToStringTagShams() {
    return hasSymbols() && !!Symbol.toStringTag;
};

},{"has-symbols/shams":"5UNSS"}],"5UNSS":[function(require,module,exports) {
'use strict';
/* eslint complexity: [2, 18], max-statements: [2, 33] */ module.exports = function hasSymbols() {
    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') return false;
    if (typeof Symbol.iterator === 'symbol') return true;
    var obj = {};
    var sym = Symbol('test');
    var symObj = Object(sym);
    if (typeof sym === 'string') return false;
    if (Object.prototype.toString.call(sym) !== '[object Symbol]') return false;
    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') return false;
    // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }
    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
    var symVal = 42;
    obj[sym] = symVal;
    for(sym in obj)return false;
     // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) return false;
    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) return false;
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) return false;
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) return false;
    if (typeof Object.getOwnPropertyDescriptor === 'function') {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) return false;
    }
    return true;
};

},{}],"3u0uq":[function(require,module,exports) {
'use strict';
var GetIntrinsic = require('get-intrinsic');
var callBind = require('./');
var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));
module.exports = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) return callBind(intrinsic);
    return intrinsic;
};

},{"get-intrinsic":"ipdBX","./":"dr8J5"}],"ipdBX":[function(require,module,exports) {
'use strict';
var undefined;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;
// eslint-disable-next-line consistent-return
var getEvalledConstructor = function(expressionSyntax) {
    try {
        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
    } catch (e) {}
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) try {
    $gOPD({}, '');
} catch (e) {
    $gOPD = null; // this is IE 8, which has a broken gOPD
}
var throwTypeError = function() {
    throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function() {
    try {
        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
        arguments.callee; // IE 8 does not throw here
        return throwTypeError;
    } catch (calleeThrows) {
        try {
            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
            return $gOPD(arguments, 'callee').get;
        } catch (gOPDthrows) {
            return throwTypeError;
        }
    }
}() : throwTypeError;
var hasSymbols = require('has-symbols')();
var getProto = Object.getPrototypeOf || function(x) {
    return x.__proto__;
}; // eslint-disable-line no-proto
var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);
var INTRINSICS = {
    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
    '%Array%': Array,
    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
    '%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
    '%AsyncFromSyncIteratorPrototype%': undefined,
    '%AsyncFunction%': needsEval,
    '%AsyncGenerator%': needsEval,
    '%AsyncGeneratorFunction%': needsEval,
    '%AsyncIteratorPrototype%': needsEval,
    '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
    '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
    '%Boolean%': Boolean,
    '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
    '%Date%': Date,
    '%decodeURI%': decodeURI,
    '%decodeURIComponent%': decodeURIComponent,
    '%encodeURI%': encodeURI,
    '%encodeURIComponent%': encodeURIComponent,
    '%Error%': Error,
    '%eval%': eval,
    '%EvalError%': EvalError,
    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
    '%Function%': $Function,
    '%GeneratorFunction%': needsEval,
    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
    '%isFinite%': isFinite,
    '%isNaN%': isNaN,
    '%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
    '%JSON%': typeof JSON === 'object' ? JSON : undefined,
    '%Map%': typeof Map === 'undefined' ? undefined : Map,
    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
    '%Math%': Math,
    '%Number%': Number,
    '%Object%': Object,
    '%parseFloat%': parseFloat,
    '%parseInt%': parseInt,
    '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
    '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
    '%RangeError%': RangeError,
    '%ReferenceError%': ReferenceError,
    '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
    '%RegExp%': RegExp,
    '%Set%': typeof Set === 'undefined' ? undefined : Set,
    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
    '%String%': String,
    '%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
    '%Symbol%': hasSymbols ? Symbol : undefined,
    '%SyntaxError%': $SyntaxError,
    '%ThrowTypeError%': ThrowTypeError,
    '%TypedArray%': TypedArray,
    '%TypeError%': $TypeError,
    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
    '%URIError%': URIError,
    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};
var doEval = function doEval1(name) {
    var value;
    if (name === '%AsyncFunction%') value = getEvalledConstructor('async function () {}');
    else if (name === '%GeneratorFunction%') value = getEvalledConstructor('function* () {}');
    else if (name === '%AsyncGeneratorFunction%') value = getEvalledConstructor('async function* () {}');
    else if (name === '%AsyncGenerator%') {
        var fn = doEval1('%AsyncGeneratorFunction%');
        if (fn) value = fn.prototype;
    } else if (name === '%AsyncIteratorPrototype%') {
        var gen = doEval1('%AsyncGenerator%');
        if (gen) value = getProto(gen.prototype);
    }
    INTRINSICS[name] = value;
    return value;
};
var LEGACY_ALIASES = {
    '%ArrayBufferPrototype%': [
        'ArrayBuffer',
        'prototype'
    ],
    '%ArrayPrototype%': [
        'Array',
        'prototype'
    ],
    '%ArrayProto_entries%': [
        'Array',
        'prototype',
        'entries'
    ],
    '%ArrayProto_forEach%': [
        'Array',
        'prototype',
        'forEach'
    ],
    '%ArrayProto_keys%': [
        'Array',
        'prototype',
        'keys'
    ],
    '%ArrayProto_values%': [
        'Array',
        'prototype',
        'values'
    ],
    '%AsyncFunctionPrototype%': [
        'AsyncFunction',
        'prototype'
    ],
    '%AsyncGenerator%': [
        'AsyncGeneratorFunction',
        'prototype'
    ],
    '%AsyncGeneratorPrototype%': [
        'AsyncGeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%BooleanPrototype%': [
        'Boolean',
        'prototype'
    ],
    '%DataViewPrototype%': [
        'DataView',
        'prototype'
    ],
    '%DatePrototype%': [
        'Date',
        'prototype'
    ],
    '%ErrorPrototype%': [
        'Error',
        'prototype'
    ],
    '%EvalErrorPrototype%': [
        'EvalError',
        'prototype'
    ],
    '%Float32ArrayPrototype%': [
        'Float32Array',
        'prototype'
    ],
    '%Float64ArrayPrototype%': [
        'Float64Array',
        'prototype'
    ],
    '%FunctionPrototype%': [
        'Function',
        'prototype'
    ],
    '%Generator%': [
        'GeneratorFunction',
        'prototype'
    ],
    '%GeneratorPrototype%': [
        'GeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%Int8ArrayPrototype%': [
        'Int8Array',
        'prototype'
    ],
    '%Int16ArrayPrototype%': [
        'Int16Array',
        'prototype'
    ],
    '%Int32ArrayPrototype%': [
        'Int32Array',
        'prototype'
    ],
    '%JSONParse%': [
        'JSON',
        'parse'
    ],
    '%JSONStringify%': [
        'JSON',
        'stringify'
    ],
    '%MapPrototype%': [
        'Map',
        'prototype'
    ],
    '%NumberPrototype%': [
        'Number',
        'prototype'
    ],
    '%ObjectPrototype%': [
        'Object',
        'prototype'
    ],
    '%ObjProto_toString%': [
        'Object',
        'prototype',
        'toString'
    ],
    '%ObjProto_valueOf%': [
        'Object',
        'prototype',
        'valueOf'
    ],
    '%PromisePrototype%': [
        'Promise',
        'prototype'
    ],
    '%PromiseProto_then%': [
        'Promise',
        'prototype',
        'then'
    ],
    '%Promise_all%': [
        'Promise',
        'all'
    ],
    '%Promise_reject%': [
        'Promise',
        'reject'
    ],
    '%Promise_resolve%': [
        'Promise',
        'resolve'
    ],
    '%RangeErrorPrototype%': [
        'RangeError',
        'prototype'
    ],
    '%ReferenceErrorPrototype%': [
        'ReferenceError',
        'prototype'
    ],
    '%RegExpPrototype%': [
        'RegExp',
        'prototype'
    ],
    '%SetPrototype%': [
        'Set',
        'prototype'
    ],
    '%SharedArrayBufferPrototype%': [
        'SharedArrayBuffer',
        'prototype'
    ],
    '%StringPrototype%': [
        'String',
        'prototype'
    ],
    '%SymbolPrototype%': [
        'Symbol',
        'prototype'
    ],
    '%SyntaxErrorPrototype%': [
        'SyntaxError',
        'prototype'
    ],
    '%TypedArrayPrototype%': [
        'TypedArray',
        'prototype'
    ],
    '%TypeErrorPrototype%': [
        'TypeError',
        'prototype'
    ],
    '%Uint8ArrayPrototype%': [
        'Uint8Array',
        'prototype'
    ],
    '%Uint8ClampedArrayPrototype%': [
        'Uint8ClampedArray',
        'prototype'
    ],
    '%Uint16ArrayPrototype%': [
        'Uint16Array',
        'prototype'
    ],
    '%Uint32ArrayPrototype%': [
        'Uint32Array',
        'prototype'
    ],
    '%URIErrorPrototype%': [
        'URIError',
        'prototype'
    ],
    '%WeakMapPrototype%': [
        'WeakMap',
        'prototype'
    ],
    '%WeakSetPrototype%': [
        'WeakSet',
        'prototype'
    ]
};
var bind = require('function-bind');
var hasOwn = require('has');
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === '%' && last !== '%') throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
    else if (last === '%' && first !== '%') throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
    });
    return result;
};
/* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = '%' + alias[0] + '%';
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) value = doEval(intrinsicName);
        if (typeof value === 'undefined' && !allowMissing) throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
        return {
            alias: alias,
            name: intrinsicName,
            value: value
        };
    }
    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};
module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== 'string' || name.length === 0) throw new $TypeError('intrinsic name must be a non-empty string');
    if (arguments.length > 1 && typeof allowMissing !== 'boolean') throw new $TypeError('"allowMissing" argument must be a boolean');
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([
            0,
            1
        ], alias));
    }
    for(var i = 1, isOwn = true; i < parts.length; i += 1){
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) throw new $SyntaxError('property names with quotes must have matching quotes');
        if (part === 'constructor' || !isOwn) skipFurtherCaching = true;
        intrinsicBaseName += '.' + part;
        intrinsicRealName = '%' + intrinsicBaseName + '%';
        if (hasOwn(INTRINSICS, intrinsicRealName)) value = INTRINSICS[intrinsicRealName];
        else if (value != null) {
            if (!(part in value)) {
                if (!allowMissing) throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
                var desc = $gOPD(value, part);
                isOwn = !!desc;
                // By convention, when a data property is converted to an accessor
                // property to emulate a data property that does not suffer from
                // the override mistake, that accessor's getter is marked with
                // an `originalValue` property. Here, when we detect this, we
                // uphold the illusion by pretending to see that original data
                // property, i.e., returning the value rather than the getter
                // itself.
                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) value = desc.get;
                else value = value[part];
            } else {
                isOwn = hasOwn(value, part);
                value = value[part];
            }
            if (isOwn && !skipFurtherCaching) INTRINSICS[intrinsicRealName] = value;
        }
    }
    return value;
};

},{"has-symbols":"f9pWe","function-bind":"3mjrB","has":"7vuH3"}],"f9pWe":[function(require,module,exports) {
'use strict';
var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');
module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== 'function') return false;
    if (typeof Symbol !== 'function') return false;
    if (typeof origSymbol('foo') !== 'symbol') return false;
    if (typeof Symbol('bar') !== 'symbol') return false;
    return hasSymbolSham();
};

},{"./shams":"2ly6m"}],"2ly6m":[function(require,module,exports) {
'use strict';
/* eslint complexity: [2, 18], max-statements: [2, 33] */ module.exports = function hasSymbols() {
    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') return false;
    if (typeof Symbol.iterator === 'symbol') return true;
    var obj = {};
    var sym = Symbol('test');
    var symObj = Object(sym);
    if (typeof sym === 'string') return false;
    if (Object.prototype.toString.call(sym) !== '[object Symbol]') return false;
    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') return false;
    // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }
    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
    var symVal = 42;
    obj[sym] = symVal;
    for(sym in obj)return false;
     // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) return false;
    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) return false;
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) return false;
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) return false;
    if (typeof Object.getOwnPropertyDescriptor === 'function') {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) return false;
    }
    return true;
};

},{}],"3mjrB":[function(require,module,exports) {
'use strict';
var implementation = require('./implementation');
module.exports = Function.prototype.bind || implementation;

},{"./implementation":"itj1A"}],"itj1A":[function(require,module,exports) {
'use strict';
/* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';
module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) throw new TypeError(ERROR_MESSAGE + target);
    var args = slice.call(arguments, 1);
    var bound;
    var binder = function() {
        if (this instanceof bound) {
            var result = target.apply(this, args.concat(slice.call(arguments)));
            if (Object(result) === result) return result;
            return this;
        } else return target.apply(that, args.concat(slice.call(arguments)));
    };
    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for(var i = 0; i < boundLength; i++)boundArgs.push('$' + i);
    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);
    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }
    return bound;
};

},{}],"7vuH3":[function(require,module,exports) {
'use strict';
var bind = require('function-bind');
module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":"3mjrB"}],"dr8J5":[function(require,module,exports) {
'use strict';
var bind = require('function-bind');
var GetIntrinsic = require('get-intrinsic');
var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');
if ($defineProperty) try {
    $defineProperty({}, 'a', {
        value: 1
    });
} catch (e) {
    // IE 8 has a broken defineProperty
    $defineProperty = null;
}
module.exports = function callBind(originalFunction) {
    var func = $reflectApply(bind, $call, arguments);
    if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, 'length');
        if (desc.configurable) // original length, plus the receiver, minus any additional arguments (after the receiver)
        $defineProperty(func, 'length', {
            value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
        });
    }
    return func;
};
var applyBind = function applyBind() {
    return $reflectApply(bind, $apply, arguments);
};
if ($defineProperty) $defineProperty(module.exports, 'apply', {
    value: applyBind
});
else module.exports.apply = applyBind;

},{"function-bind":"3mjrB","get-intrinsic":"ipdBX"}],"fFywx":[function(require,module,exports) {
'use strict';
var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = require('has-tostringtag/shams')();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function() {
    if (!hasToStringTag) return false;
    try {
        return Function('return function*() {}')();
    } catch (e) {}
};
var GeneratorFunction;
module.exports = function isGeneratorFunction(fn) {
    if (typeof fn !== 'function') return false;
    if (isFnRegex.test(fnToStr.call(fn))) return true;
    if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === '[object GeneratorFunction]';
    }
    if (!getProto) return false;
    if (typeof GeneratorFunction === 'undefined') {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
    }
    return getProto(fn) === GeneratorFunction;
};

},{"has-tostringtag/shams":"93Ahn"}],"76zk9":[function(require,module,exports) {
'use strict';
var global = arguments[3];
var forEach = require('foreach');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');
var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();
var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) forEach(typedArrays, function(typedArray) {
    if (typeof g[typedArray] === 'function') {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
                var superProto = getPrototypeOf(proto);
                descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
        }
    }
});
var tryTypedArrays = function tryAllTypedArrays(value) {
    var foundName = false;
    forEach(toStrTags, function(getter, typedArray) {
        if (!foundName) try {
            var name = getter.call(value);
            if (name === typedArray) foundName = name;
        } catch (e) {}
    });
    return foundName;
};
var isTypedArray = require('is-typed-array');
module.exports = function whichTypedArray(value) {
    if (!isTypedArray(value)) return false;
    if (!hasToStringTag || !(Symbol.toStringTag in value)) return $slice($toString(value), 8, -1);
    return tryTypedArrays(value);
};

},{"foreach":"2TXtI","available-typed-arrays":"64b6i","call-bind/callBound":"3u0uq","has-tostringtag/shams":"93Ahn","es-abstract/helpers/getOwnPropertyDescriptor":"jiU8g","is-typed-array":"dPPDl"}],"2TXtI":[function(require,module,exports) {
var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;
module.exports = function forEach(obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') throw new TypeError('iterator must be a function');
    var l = obj.length;
    if (l === +l) for(var i = 0; i < l; i++)fn.call(ctx, obj[i], i, obj);
    else {
        for(var k in obj)if (hasOwn.call(obj, k)) fn.call(ctx, obj[k], k, obj);
    }
};

},{}],"64b6i":[function(require,module,exports) {
'use strict';
var global = arguments[3];
var possibleNames = [
    'BigInt64Array',
    'BigUint64Array',
    'Float32Array',
    'Float64Array',
    'Int16Array',
    'Int32Array',
    'Int8Array',
    'Uint16Array',
    'Uint32Array',
    'Uint8Array',
    'Uint8ClampedArray'
];
var g = typeof globalThis === 'undefined' ? global : globalThis;
module.exports = function availableTypedArrays() {
    var out = [];
    for(var i = 0; i < possibleNames.length; i++)if (typeof g[possibleNames[i]] === 'function') out[out.length] = possibleNames[i];
    return out;
};

},{}],"jiU8g":[function(require,module,exports) {
'use strict';
var GetIntrinsic = require('get-intrinsic');
var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
if ($gOPD) try {
    $gOPD([], 'length');
} catch (e) {
    // IE 8 has a broken gOPD
    $gOPD = null;
}
module.exports = $gOPD;

},{"get-intrinsic":"ipdBX"}],"dPPDl":[function(require,module,exports) {
'use strict';
var global = arguments[3];
var forEach = require('foreach');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');
var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();
var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();
var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
    for(var i = 0; i < array.length; i += 1){
        if (array[i] === value) return i;
    }
    return -1;
};
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) forEach(typedArrays, function(typedArray) {
    var arr = new g[typedArray]();
    if (Symbol.toStringTag in arr) {
        var proto = getPrototypeOf(arr);
        var descriptor = gOPD(proto, Symbol.toStringTag);
        if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
        }
        toStrTags[typedArray] = descriptor.get;
    }
});
var tryTypedArrays = function tryAllTypedArrays(value) {
    var anyTrue = false;
    forEach(toStrTags, function(getter, typedArray) {
        if (!anyTrue) try {
            anyTrue = getter.call(value) === typedArray;
        } catch (e) {}
    });
    return anyTrue;
};
module.exports = function isTypedArray(value) {
    if (!value || typeof value !== 'object') return false;
    if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        var tag = $slice($toString(value), 8, -1);
        return $indexOf(typedArrays, tag) > -1;
    }
    if (!gOPD) return false;
    return tryTypedArrays(value);
};

},{"foreach":"2TXtI","available-typed-arrays":"64b6i","call-bind/callBound":"3u0uq","has-tostringtag/shams":"93Ahn","es-abstract/helpers/getOwnPropertyDescriptor":"jiU8g"}],"8CRCz":[function(require,module,exports) {
module.exports = function isBuffer(arg) {
    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};

},{}],"8TdOm":[function(require,module,exports) {
if (typeof Object.create === 'function') // implementation from standard node.js 'util' module
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    }
};
else // old school shim for old browsers
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
};

},{}],"buLhQ":[function(require,module,exports) {
// Currently in sync with Node.js lib/internal/assert/assertion_error.js
// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c
'use strict';
var process = require("process");
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _wrapNativeSuper(Class1) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction(Class)) return Class;
        if (typeof Class !== "function") throw new TypeError("Super expression must either be null or a function");
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _setPrototypeOf(Wrapper, Class);
    };
    return _wrapNativeSuper(Class1);
}
function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _construct(Parent1, args1, Class2) {
    if (isNativeReflectConstruct()) _construct = Reflect.construct;
    else _construct = function _construct(Parent, args, Class) {
        var a = [
            null
        ];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
    };
    return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _setPrototypeOf(o1, p1) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o1, p1);
}
function _getPrototypeOf(o2) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o2);
}
function _typeof(obj1) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj1);
}
var _require = require('util/'), inspect = _require.inspect;
var _require2 = require('../errors'), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) this_len = str.length;
    return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
function repeat(str, count) {
    count = Math.floor(count);
    if (str.length == 0 || count == 0) return '';
    var maxCount = str.length * count;
    count = Math.floor(Math.log(count) / Math.log(2));
    while(count){
        str += str;
        count--;
    }
    str += str.substring(0, maxCount - str.length);
    return str;
}
var blue = '';
var green = '';
var red = '';
var white = '';
var kReadableOperator = {
    deepStrictEqual: 'Expected values to be strictly deep-equal:',
    strictEqual: 'Expected values to be strictly equal:',
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: 'Expected values to be loosely deep-equal:',
    equal: 'Expected values to be loosely equal:',
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notEqual: 'Expected "actual" to be loosely unequal to:',
    notIdentical: 'Values identical but not reference-equal:'
}; // Comparing short primitives should just show === / !== instead of using the
// diff.
var kMaxShortLength = 10;
function copyError(source) {
    var keys = Object.keys(source);
    var target = Object.create(Object.getPrototypeOf(source));
    keys.forEach(function(key) {
        target[key] = source[key];
    });
    Object.defineProperty(target, 'message', {
        value: source.message
    });
    return target;
}
function inspectValue(val) {
    // The util.inspect default values could be changed. This makes sure the
    // error messages contain the necessary information nevertheless.
    return inspect(val, {
        compact: false,
        customInspect: false,
        depth: 1000,
        maxArrayLength: Infinity,
        // Assert compares only enumerable properties (with a few exceptions).
        showHidden: false,
        // Having a long line as error is better than wrapping the line for
        // comparison for now.
        // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
        // have meta information about the inspected properties (i.e., know where
        // in what line the property starts and ends).
        breakLength: Infinity,
        // Assert does not detect proxies currently.
        showProxy: false,
        sorted: true,
        // Inspect getters as we also check them when comparing entries.
        getters: true
    });
}
function createErrDiff(actual, expected, operator) {
    var other = '';
    var res = '';
    var lastPos = 0;
    var end = '';
    var skipped = false;
    var actualInspected = inspectValue(actual);
    var actualLines = actualInspected.split('\n');
    var expectedLines = inspectValue(expected).split('\n');
    var i = 0;
    var indicator = ''; // In case both values are objects explicitly mark them as not reference equal
    // for the `strictEqual` operator.
    if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) operator = 'strictEqualObject';
     // If "actual" and "expected" fit on a single line and they are not strictly
    // equal, check further special handling.
    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
        var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
        // kMaxShortLength and if neither is an object and at least one of them is
        // not `zero`, use the strict equal comparison to visualize the output.
        if (inputLength <= kMaxShortLength) {
            if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) // -0 === +0
            return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
        } else if (operator !== 'strictEqualObject') {
            // If the stderr is a tty and the input length is lower than the current
            // columns per line, add a mismatch indicator below the output. If it is
            // not a tty, use a default value of 80 characters.
            var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
            if (inputLength < maxLength) {
                while(actualLines[0][i] === expectedLines[0][i])i++;
                 // Ignore the first characters.
                if (i > 2) {
                    // Add position indicator for the first mismatch in case it is a
                    // single line and the input length is less than the column length.
                    indicator = "\n  ".concat(repeat(' ', i), "^");
                    i = 0;
                }
            }
        }
    } // Remove all ending lines that match (this optimizes the output for
    // readability by reducing the number of total changed lines).
    var a = actualLines[actualLines.length - 1];
    var b = expectedLines[expectedLines.length - 1];
    while(a === b){
        if (i++ < 2) end = "\n  ".concat(a).concat(end);
        else other = a;
        actualLines.pop();
        expectedLines.pop();
        if (actualLines.length === 0 || expectedLines.length === 0) break;
        a = actualLines[actualLines.length - 1];
        b = expectedLines[expectedLines.length - 1];
    }
    var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
    // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
    if (maxLines === 0) {
        // We have to get the result again. The lines were all removed before.
        var _actualLines = actualInspected.split('\n'); // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.
        if (_actualLines.length > 30) {
            _actualLines[26] = "".concat(blue, "...").concat(white);
            while(_actualLines.length > 27)_actualLines.pop();
        }
        return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
    }
    if (i > 3) {
        end = "\n".concat(blue, "...").concat(white).concat(end);
        skipped = true;
    }
    if (other !== '') {
        end = "\n  ".concat(other).concat(end);
        other = '';
    }
    var printedLines = 0;
    var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
    var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
    for(i = 0; i < maxLines; i++){
        // Only extra expected lines exist
        var cur = i - lastPos;
        if (actualLines.length < i + 1) {
            // If the last diverging line is more than one line above and the
            // current line is at least line three, add some of the former lines and
            // also add dots to indicate skipped entries.
            if (cur > 1 && i > 2) {
                if (cur > 4) {
                    res += "\n".concat(blue, "...").concat(white);
                    skipped = true;
                } else if (cur > 3) {
                    res += "\n  ".concat(expectedLines[i - 2]);
                    printedLines++;
                }
                res += "\n  ".concat(expectedLines[i - 1]);
                printedLines++;
            } // Mark the current line as the last diverging one.
            lastPos = i; // Add the expected line to the cache.
            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
            printedLines++; // Only extra actual lines exist
        } else if (expectedLines.length < i + 1) {
            // If the last diverging line is more than one line above and the
            // current line is at least line three, add some of the former lines and
            // also add dots to indicate skipped entries.
            if (cur > 1 && i > 2) {
                if (cur > 4) {
                    res += "\n".concat(blue, "...").concat(white);
                    skipped = true;
                } else if (cur > 3) {
                    res += "\n  ".concat(actualLines[i - 2]);
                    printedLines++;
                }
                res += "\n  ".concat(actualLines[i - 1]);
                printedLines++;
            } // Mark the current line as the last diverging one.
            lastPos = i; // Add the actual line to the result.
            res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
            printedLines++; // Lines diverge
        } else {
            var expectedLine = expectedLines[i];
            var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
            // a trailing comma. In that case it is actually identical and we should
            // mark it as such.
            var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
            // add a comma at the end of the actual line. Otherwise the output could
            // look weird as in:
            //
            //   [
            //     1         // No comma at the end!
            // +   2
            //   ]
            //
            if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
                divergingLines = false;
                actualLine += ',';
            }
            if (divergingLines) {
                // If the last diverging line is more than one line above and the
                // current line is at least line three, add some of the former lines and
                // also add dots to indicate skipped entries.
                if (cur > 1 && i > 2) {
                    if (cur > 4) {
                        res += "\n".concat(blue, "...").concat(white);
                        skipped = true;
                    } else if (cur > 3) {
                        res += "\n  ".concat(actualLines[i - 2]);
                        printedLines++;
                    }
                    res += "\n  ".concat(actualLines[i - 1]);
                    printedLines++;
                } // Mark the current line as the last diverging one.
                lastPos = i; // Add the actual line to the result and cache the expected diverging
                // line so consecutive diverging lines show up as +++--- and not +-+-+-.
                res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
                other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
                printedLines += 2; // Lines are identical
            } else {
                // Add all cached information to the result before adding other things
                // and reset the cache.
                res += other;
                other = ''; // If the last diverging line is exactly one line above or if it is the
                // very first line, add the line to the result.
                if (cur === 1 || i === 0) {
                    res += "\n  ".concat(actualLine);
                    printedLines++;
                }
            }
        } // Inspected object to big (Show ~20 rows max)
        if (printedLines > 20 && i < maxLines - 2) return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
    }
    return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
}
var AssertionError = /*#__PURE__*/ function(_Error) {
    _inherits(AssertionError1, _Error);
    function AssertionError1(options) {
        var _this;
        _classCallCheck(this, AssertionError1);
        if (_typeof(options) !== 'object' || options === null) throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
        var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
        var actual = options.actual, expected = options.expected;
        var limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 0;
        if (message != null) _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError1).call(this, String(message)));
        else {
            if (process.stderr && process.stderr.isTTY) {
                // Reset on each call to make sure we handle dynamically set environment
                // variables correct.
                if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
                    blue = "\x1B[34m";
                    green = "\x1B[32m";
                    white = "\x1B[39m";
                    red = "\x1B[31m";
                } else {
                    blue = '';
                    green = '';
                    white = '';
                    red = '';
                }
            } // Prevent the error stack from being visible by duplicating the error
            // in a very close way to the original in case both sides are actually
            // instances of Error.
            if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
                actual = copyError(actual);
                expected = copyError(expected);
            }
            if (operator === 'deepStrictEqual' || operator === 'strictEqual') _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError1).call(this, createErrDiff(actual, expected, operator)));
            else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
                // In case the objects are equal but the operator requires unequal, show
                // the first object and say A equals B
                var base = kReadableOperator[operator];
                var res = inspectValue(actual).split('\n'); // In case "actual" is an object, it should not be reference equal.
                if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) base = kReadableOperator.notStrictEqualObject;
                 // Only remove lines in case it makes sense to collapse those.
                // TODO: Accept env to always show the full error.
                if (res.length > 30) {
                    res[26] = "".concat(blue, "...").concat(white);
                    while(res.length > 27)res.pop();
                } // Only print a single input.
                if (res.length === 1) _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError1).call(this, "".concat(base, " ").concat(res[0])));
                else _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError1).call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n")));
            } else {
                var _res = inspectValue(actual);
                var other = '';
                var knownOperators = kReadableOperator[operator];
                if (operator === 'notDeepEqual' || operator === 'notEqual') {
                    _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                    if (_res.length > 1024) _res = "".concat(_res.slice(0, 1021), "...");
                } else {
                    other = "".concat(inspectValue(expected));
                    if (_res.length > 512) _res = "".concat(_res.slice(0, 509), "...");
                    if (other.length > 512) other = "".concat(other.slice(0, 509), "...");
                    if (operator === 'deepEqual' || operator === 'equal') _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                    else other = " ".concat(operator, " ").concat(other);
                }
                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError1).call(this, "".concat(_res).concat(other)));
            }
        }
        Error.stackTraceLimit = limit;
        _this.generatedMessage = !message;
        Object.defineProperty(_assertThisInitialized(_this), 'name', {
            value: 'AssertionError [ERR_ASSERTION]',
            enumerable: false,
            writable: true,
            configurable: true
        });
        _this.code = 'ERR_ASSERTION';
        _this.actual = actual;
        _this.expected = expected;
        _this.operator = operator;
        if (Error.captureStackTrace) // eslint-disable-next-line no-restricted-syntax
        Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
         // Create error message including the error code in the name.
        _this.stack; // Reset the name.
        _this.name = 'AssertionError';
        return _possibleConstructorReturn(_this);
    }
    _createClass(AssertionError1, [
        {
            key: "toString",
            value: function toString() {
                return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
            }
        },
        {
            key: inspect.custom,
            value: function value(recurseTimes, ctx) {
                // This limits the `actual` and `expected` property default inspection to
                // the minimum depth. Otherwise those values would be too verbose compared
                // to the actual error message which contains a combined view of these two
                // input values.
                return inspect(this, _objectSpread({}, ctx, {
                    customInspect: false,
                    depth: 0
                }));
            }
        }
    ]);
    return AssertionError1;
}(_wrapNativeSuper(Error));
module.exports = AssertionError;

},{"process":"kKEHw","util/":"h4AnS","../errors":"cQb4R"}],"lzBrv":[function(require,module,exports) {
/**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */ 'use strict';
function assign(target, firstSource) {
    if (target === undefined || target === null) throw new TypeError('Cannot convert first argument to object');
    var to = Object(target);
    for(var i = 1; i < arguments.length; i++){
        var nextSource = arguments[i];
        if (nextSource === undefined || nextSource === null) continue;
        var keysArray = Object.keys(Object(nextSource));
        for(var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++){
            var nextKey = keysArray[nextIndex];
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
            if (desc !== undefined && desc.enumerable) to[nextKey] = nextSource[nextKey];
        }
    }
    return to;
}
function polyfill() {
    if (!Object.assign) Object.defineProperty(Object, 'assign', {
        enumerable: false,
        configurable: true,
        writable: true,
        value: assign
    });
}
module.exports = {
    assign: assign,
    polyfill: polyfill
};

},{}],"8lNUw":[function(require,module,exports) {
'use strict';
var define = require('define-properties');
var callBind = require('call-bind');
var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');
var polyfill = callBind(getPolyfill(), Object);
define(polyfill, {
    getPolyfill: getPolyfill,
    implementation: implementation,
    shim: shim
});
module.exports = polyfill;

},{"define-properties":"XVQ2G","call-bind":"dr8J5","./implementation":"2IB6c","./polyfill":"bhCju","./shim":"bHd3G"}],"XVQ2G":[function(require,module,exports) {
'use strict';
var keys = require('object-keys');
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;
var isFunction = function(fn) {
    return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};
var arePropertyDescriptorsSupported = function() {
    var obj = {};
    try {
        origDefineProperty(obj, 'x', {
            enumerable: false,
            value: obj
        });
        // eslint-disable-next-line no-unused-vars, no-restricted-syntax
        for(var _ in obj)return false;
        return obj.x === obj;
    } catch (e) {
        return false;
    }
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();
var defineProperty = function(object, name, value, predicate) {
    if (name in object && (!isFunction(predicate) || !predicate())) return;
    if (supportsDescriptors) origDefineProperty(object, name, {
        configurable: true,
        enumerable: false,
        value: value,
        writable: true
    });
    else object[name] = value;
};
var defineProperties = function(object, map) {
    var predicates = arguments.length > 2 ? arguments[2] : {};
    var props = keys(map);
    if (hasSymbols) props = concat.call(props, Object.getOwnPropertySymbols(map));
    for(var i = 0; i < props.length; i += 1)defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
};
defineProperties.supportsDescriptors = !!supportsDescriptors;
module.exports = defineProperties;

},{"object-keys":"67gsy"}],"67gsy":[function(require,module,exports) {
'use strict';
var slice = Array.prototype.slice;
var isArgs = require('./isArguments');
var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
    return origKeys(o);
} : require('./implementation');
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
    if (Object.keys) {
        var keysWorksWithArguments = function() {
            // Safari 5.0 bug
            var args = Object.keys(arguments);
            return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) Object.keys = function keys(object) {
            if (isArgs(object)) return originalKeys(slice.call(object));
            return originalKeys(object);
        };
    } else Object.keys = keysShim;
    return Object.keys || keysShim;
};
module.exports = keysShim;

},{"./isArguments":"iaQUP","./implementation":"5qKds"}],"iaQUP":[function(require,module,exports) {
'use strict';
var toStr = Object.prototype.toString;
module.exports = function isArguments(value) {
    var str = toStr.call(value);
    var isArgs = str === '[object Arguments]';
    if (!isArgs) isArgs = str !== '[object Array]' && value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
    return isArgs;
};

},{}],"5qKds":[function(require,module,exports) {
'use strict';
var keysShim;
if (!Object.keys) {
    // modified from https://github.com/es-shims/es5-shim
    var has = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var isArgs = require('./isArguments'); // eslint-disable-line global-require
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable.call({
        toString: null
    }, 'toString');
    var hasProtoEnumBug = isEnumerable.call(function() {}, 'prototype');
    var dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor'
    ];
    var equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
    };
    var excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
    };
    var hasAutomationEqualityBug = function() {
        /* global window */ if (typeof window === 'undefined') return false;
        for(var k in window)try {
            if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') try {
                equalsConstructorPrototype(window[k]);
            } catch (e) {
                return true;
            }
        } catch (e) {
            return true;
        }
        return false;
    }();
    var equalsConstructorPrototypeIfNotBuggy = function(o) {
        /* global window */ if (typeof window === 'undefined' || !hasAutomationEqualityBug) return equalsConstructorPrototype(o);
        try {
            return equalsConstructorPrototype(o);
        } catch (e) {
            return false;
        }
    };
    keysShim = function keys(object) {
        var isObject = object !== null && typeof object === 'object';
        var isFunction = toStr.call(object) === '[object Function]';
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === '[object String]';
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) throw new TypeError('Object.keys called on a non-object');
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) for(var i = 0; i < object.length; ++i)theKeys.push(String(i));
        if (isArguments && object.length > 0) for(var j = 0; j < object.length; ++j)theKeys.push(String(j));
        else {
            for(var name in object)if (!(skipProto && name === 'prototype') && has.call(object, name)) theKeys.push(String(name));
        }
        if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
            for(var k = 0; k < dontEnums.length; ++k)if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) theKeys.push(dontEnums[k]);
        }
        return theKeys;
    };
}
module.exports = keysShim;

},{"./isArguments":"iaQUP"}],"2IB6c":[function(require,module,exports) {
'use strict';
var numberIsNaN = function(value) {
    return value !== value;
};
module.exports = function is(a, b) {
    if (a === 0 && b === 0) return 1 / a === 1 / b;
    if (a === b) return true;
    if (numberIsNaN(a) && numberIsNaN(b)) return true;
    return false;
};

},{}],"bhCju":[function(require,module,exports) {
'use strict';
var implementation = require('./implementation');
module.exports = function getPolyfill() {
    return typeof Object.is === 'function' ? Object.is : implementation;
};

},{"./implementation":"2IB6c"}],"bHd3G":[function(require,module,exports) {
'use strict';
var getPolyfill = require('./polyfill');
var define = require('define-properties');
module.exports = function shimObjectIs() {
    var polyfill = getPolyfill();
    define(Object, {
        is: polyfill
    }, {
        is: function testObjectIs() {
            return Object.is !== polyfill;
        }
    });
    return polyfill;
};

},{"./polyfill":"bhCju","define-properties":"XVQ2G"}],"6yCqR":[function(require,module,exports) {
// Currently in sync with Node.js lib/internal/util/comparisons.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
'use strict';
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;
    try {
        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
function _typeof(obj1) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof(obj) {
        return typeof obj;
    };
    else _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return _typeof(obj1);
}
var regexFlagsSupported = /a/g.flags !== undefined;
var arrayFromSet = function arrayFromSet(set) {
    var array = [];
    set.forEach(function(value) {
        return array.push(value);
    });
    return array;
};
var arrayFromMap = function arrayFromMap(map) {
    var array = [];
    map.forEach(function(value, key) {
        return array.push([
            key,
            value
        ]);
    });
    return array;
};
var objectIs = Object.is ? Object.is : require('object-is');
var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
};
var numberIsNaN = Number.isNaN ? Number.isNaN : require('is-nan');
function uncurryThis(f) {
    return f.call.bind(f);
}
var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
var objectToString = uncurryThis(Object.prototype.toString);
var _require$types = require('util/').types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
function isNonIndex(key) {
    if (key.length === 0 || key.length > 10) return true;
    for(var i = 0; i < key.length; i++){
        var code = key.charCodeAt(i);
        if (code < 48 || code > 57) return true;
    } // The maximum size for an array is 2 ** 32 -1.
    return key.length === 10 && key >= Math.pow(2, 32);
}
function getOwnNonIndexProperties(value) {
    return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
} // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */ function compare(a, b) {
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
}
var ONLY_ENUMERABLE = undefined;
var kStrict = true;
var kLoose = false;
var kNoIterator = 0;
var kIsArray = 1;
var kIsSet = 2;
var kIsMap = 3; // Check if they have the same source and flags
function areSimilarRegExps(a, b) {
    return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
}
function areSimilarFloatArrays(a, b) {
    if (a.byteLength !== b.byteLength) return false;
    for(var offset = 0; offset < a.byteLength; offset++){
        if (a[offset] !== b[offset]) return false;
    }
    return true;
}
function areSimilarTypedArrays(a, b) {
    if (a.byteLength !== b.byteLength) return false;
    return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
    return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(val1, val2) {
    if (isNumberObject(val1)) return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
    if (isStringObject(val1)) return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
    if (isBooleanObject(val1)) return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
    if (isBigIntObject(val1)) return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
    return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
} // Notes: Type tags are historical [[Class]] properties that can be set by
// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
// and retrieved using Object.prototype.toString.call(obj) in JS
// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
// for a list of tags pre-defined in the spec.
// There are some unspecified tags in the wild too (e.g. typed array tags).
// Since tags can be altered, they only serve fast failures
//
// Typed arrays and buffers are checked by comparing the content in their
// underlying ArrayBuffer. This optimization requires that it's
// reasonable to interpret their underlying memory in the same way,
// which is checked by comparing their type tags.
// (e.g. a Uint8Array and a Uint16Array with the same memory content
// could still be different because they will be interpreted differently).
//
// For strict comparison, objects should have
// a) The same built-in type tags
// b) The same prototypes.
function innerDeepEqual(val1, val2, strict, memos) {
    // All identical values are equivalent, as determined by ===.
    if (val1 === val2) {
        if (val1 !== 0) return true;
        return strict ? objectIs(val1, val2) : true;
    } // Check more closely if val1 and val2 are equal.
    if (strict) {
        if (_typeof(val1) !== 'object') return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
        if (_typeof(val2) !== 'object' || val1 === null || val2 === null) return false;
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) return false;
    } else {
        if (val1 === null || _typeof(val1) !== 'object') {
            if (val2 === null || _typeof(val2) !== 'object') // eslint-disable-next-line eqeqeq
            return val1 == val2;
            return false;
        }
        if (val2 === null || _typeof(val2) !== 'object') return false;
    }
    var val1Tag = objectToString(val1);
    var val2Tag = objectToString(val2);
    if (val1Tag !== val2Tag) return false;
    if (Array.isArray(val1)) {
        // Check for sparse arrays and general fast path
        if (val1.length !== val2.length) return false;
        var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
        var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
        if (keys1.length !== keys2.length) return false;
        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
    } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
    // wan't to early return out of the rest of the checks. However we can check
    // if the second value is one of these values and the first isn't.
    if (val1Tag === '[object Object]') {
        // return keyCheck(val1, val2, strict, memos, kNoIterator);
        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) return false;
    }
    if (isDate(val1)) {
        if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) return false;
    } else if (isRegExp(val1)) {
        if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) return false;
    } else if (isNativeError(val1) || val1 instanceof Error) {
        // Do not compare the stack as it might differ even though the error itself
        // is otherwise identical.
        if (val1.message !== val2.message || val1.name !== val2.name) return false;
    } else if (isArrayBufferView(val1)) {
        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
            if (!areSimilarFloatArrays(val1, val2)) return false;
        } else if (!areSimilarTypedArrays(val1, val2)) return false;
         // Buffer.compare returns true, so val1.length === val2.length. If they both
        // only contain numeric keys, we don't need to exam further than checking
        // the symbols.
        var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
        var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
        if (_keys.length !== _keys2.length) return false;
        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
    } else if (isSet(val1)) {
        if (!isSet(val2) || val1.size !== val2.size) return false;
        return keyCheck(val1, val2, strict, memos, kIsSet);
    } else if (isMap(val1)) {
        if (!isMap(val2) || val1.size !== val2.size) return false;
        return keyCheck(val1, val2, strict, memos, kIsMap);
    } else if (isAnyArrayBuffer(val1)) {
        if (!areEqualArrayBuffers(val1, val2)) return false;
    } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) return false;
    return keyCheck(val1, val2, strict, memos, kNoIterator);
}
function getEnumerables(val, keys) {
    return keys.filter(function(k) {
        return propertyIsEnumerable(val, k);
    });
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
    // For all remaining Object pairs, including Array, objects and Maps,
    // equivalence is determined by having:
    // a) The same number of owned enumerable properties
    // b) The same set of keys/indexes (although not necessarily the same order)
    // c) Equivalent values for every corresponding key/index
    // d) For Sets and Maps, equal contents
    // Note: this accounts for both named and indexed properties on Arrays.
    if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.
        if (aKeys.length !== bKeys.length) return false;
    } // Cheap key test
    var i = 0;
    for(; i < aKeys.length; i++){
        if (!hasOwnProperty(val2, aKeys[i])) return false;
    }
    if (strict && arguments.length === 5) {
        var symbolKeysA = objectGetOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
            var count = 0;
            for(i = 0; i < symbolKeysA.length; i++){
                var key = symbolKeysA[i];
                if (propertyIsEnumerable(val1, key)) {
                    if (!propertyIsEnumerable(val2, key)) return false;
                    aKeys.push(key);
                    count++;
                } else if (propertyIsEnumerable(val2, key)) return false;
            }
            var symbolKeysB = objectGetOwnPropertySymbols(val2);
            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) return false;
        } else {
            var _symbolKeysB = objectGetOwnPropertySymbols(val2);
            if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) return false;
        }
    }
    if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) return true;
     // Use memos to handle cycles.
    if (memos === undefined) memos = {
        val1: new Map(),
        val2: new Map(),
        position: 0
    };
    else {
        // We prevent up to two map.has(x) calls by directly retrieving the value
        // and checking for undefined. The map can only contain numbers, so it is
        // safe to check for undefined only.
        var val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== undefined) {
            var val2MemoB = memos.val2.get(val2);
            if (val2MemoB !== undefined) return val2MemoA === val2MemoB;
        }
        memos.position++;
    }
    memos.val1.set(val1, memos.position);
    memos.val2.set(val2, memos.position);
    var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
    memos.val1.delete(val1);
    memos.val2.delete(val2);
    return areEq;
}
function setHasEqualElement(set, val1, strict, memo) {
    // Go looking.
    var setValues = arrayFromSet(set);
    for(var i = 0; i < setValues.length; i++){
        var val2 = setValues[i];
        if (innerDeepEqual(val1, val2, strict, memo)) {
            // Remove the matching element to make sure we do not check that again.
            set.delete(val2);
            return true;
        }
    }
    return false;
} // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
// Sadly it is not possible to detect corresponding values properly in case the
// type is a string, number, bigint or boolean. The reason is that those values
// can match lots of different string values (e.g., 1n == '+00001').
function findLooseMatchingPrimitives(prim) {
    switch(_typeof(prim)){
        case 'undefined':
            return null;
        case 'object':
            // Only pass in null as object!
            return undefined;
        case 'symbol':
            return false;
        case 'string':
            prim = +prim;
        // Loose equal entries exist only if the string is possible to convert to
        // a regular number and not NaN.
        // Fall through
        case 'number':
            if (numberIsNaN(prim)) return false;
    }
    return true;
}
function setMightHaveLoosePrim(a, b, prim) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null) return altValue;
    return b.has(altValue) && !a.has(altValue);
}
function mapMightHaveLoosePrim(a, b, prim, item, memo) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null) return altValue;
    var curB = b.get(altValue);
    if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) return false;
    return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
}
function setEquiv(a, b, strict, memo) {
    // This is a lazily initiated Set of entries which have to be compared
    // pairwise.
    var set = null;
    var aValues = arrayFromSet(a);
    for(var i = 0; i < aValues.length; i++){
        var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
        // heavy sets but it is a minor slow down for primitives. As they are fast
        // to check this improves the worst case scenario instead.
        if (_typeof(val) === 'object' && val !== null) {
            if (set === null) set = new Set();
             // If the specified value doesn't exist in the second set its an not null
            // object (or non strict only: a not matching primitive) we'll need to go
            // hunting for something thats deep-(strict-)equal to it. To make this
            // O(n log n) complexity we have to copy these values in a new set first.
            set.add(val);
        } else if (!b.has(val)) {
            if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.
            if (!setMightHaveLoosePrim(a, b, val)) return false;
            if (set === null) set = new Set();
            set.add(val);
        }
    }
    if (set !== null) {
        var bValues = arrayFromSet(b);
        for(var _i = 0; _i < bValues.length; _i++){
            var _val = bValues[_i]; // We have to check if a primitive value is already
            // matching and only if it's not, go hunting for it.
            if (_typeof(_val) === 'object' && _val !== null) {
                if (!setHasEqualElement(set, _val, strict, memo)) return false;
            } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) return false;
        }
        return set.size === 0;
    }
    return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
    // To be able to handle cases like:
    //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
    // ... we need to consider *all* matching keys, not just the first we find.
    var setValues = arrayFromSet(set);
    for(var i = 0; i < setValues.length; i++){
        var key2 = setValues[i];
        if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
            set.delete(key2);
            return true;
        }
    }
    return false;
}
function mapEquiv(a, b, strict, memo) {
    var set = null;
    var aEntries = arrayFromMap(a);
    for(var i = 0; i < aEntries.length; i++){
        var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
        if (_typeof(key) === 'object' && key !== null) {
            if (set === null) set = new Set();
            set.add(key);
        } else {
            // By directly retrieving the value we prevent another b.has(key) check in
            // almost all possible cases.
            var item2 = b.get(key);
            if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
                if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
                // keys.
                if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
                if (set === null) set = new Set();
                set.add(key);
            }
        }
    }
    if (set !== null) {
        var bEntries = arrayFromMap(b);
        for(var _i2 = 0; _i2 < bEntries.length; _i2++){
            var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
            if (_typeof(key) === 'object' && key !== null) {
                if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
            } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) return false;
        }
        return set.size === 0;
    }
    return true;
}
function objEquiv(a, b, strict, keys, memos, iterationType) {
    // Sets and maps don't have their entries accessible via normal object
    // properties.
    var i = 0;
    if (iterationType === kIsSet) {
        if (!setEquiv(a, b, strict, memos)) return false;
    } else if (iterationType === kIsMap) {
        if (!mapEquiv(a, b, strict, memos)) return false;
    } else if (iterationType === kIsArray) for(; i < a.length; i++){
        if (hasOwnProperty(a, i)) {
            if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) return false;
        } else if (hasOwnProperty(b, i)) return false;
        else {
            // Array is sparse.
            var keysA = Object.keys(a);
            for(; i < keysA.length; i++){
                var key = keysA[i];
                if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) return false;
            }
            if (keysA.length !== Object.keys(b).length) return false;
            return true;
        }
    }
     // The pair must have equivalent values for every corresponding key.
    // Possibly expensive deep test:
    for(i = 0; i < keys.length; i++){
        var _key = keys[i];
        if (!innerDeepEqual(a[_key], b[_key], strict, memos)) return false;
    }
    return true;
}
function isDeepEqual(val1, val2) {
    return innerDeepEqual(val1, val2, kLoose);
}
function isDeepStrictEqual(val1, val2) {
    return innerDeepEqual(val1, val2, kStrict);
}
module.exports = {
    isDeepEqual: isDeepEqual,
    isDeepStrictEqual: isDeepStrictEqual
};

},{"object-is":"8lNUw","is-nan":"eFAV3","util/":"h4AnS"}],"eFAV3":[function(require,module,exports) {
'use strict';
var callBind = require('call-bind');
var define = require('define-properties');
var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');
var polyfill = callBind(getPolyfill(), Number);
/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ define(polyfill, {
    getPolyfill: getPolyfill,
    implementation: implementation,
    shim: shim
});
module.exports = polyfill;

},{"call-bind":"dr8J5","define-properties":"XVQ2G","./implementation":"8Ug11","./polyfill":"cDoH9","./shim":"2KeFc"}],"8Ug11":[function(require,module,exports) {
'use strict';
/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module.exports = function isNaN(value) {
    return value !== value;
};

},{}],"cDoH9":[function(require,module,exports) {
'use strict';
var implementation = require('./implementation');
module.exports = function getPolyfill() {
    if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) return Number.isNaN;
    return implementation;
};

},{"./implementation":"8Ug11"}],"2KeFc":[function(require,module,exports) {
'use strict';
var define = require('define-properties');
var getPolyfill = require('./polyfill');
/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module.exports = function shimNumberIsNaN() {
    var polyfill = getPolyfill();
    define(Number, {
        isNaN: polyfill
    }, {
        isNaN: function testIsNaN() {
            return Number.isNaN !== polyfill;
        }
    });
    return polyfill;
};

},{"define-properties":"XVQ2G","./polyfill":"cDoH9"}],"dsWVF":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _exportNames = {
    react: true,
    assertNode: true,
    createTypeAnnotationBasedOnTypeof: true,
    createUnionTypeAnnotation: true,
    createFlowUnionType: true,
    createTSUnionType: true,
    cloneNode: true,
    clone: true,
    cloneDeep: true,
    cloneDeepWithoutLoc: true,
    cloneWithoutLoc: true,
    addComment: true,
    addComments: true,
    inheritInnerComments: true,
    inheritLeadingComments: true,
    inheritsComments: true,
    inheritTrailingComments: true,
    removeComments: true,
    ensureBlock: true,
    toBindingIdentifierName: true,
    toBlock: true,
    toComputedKey: true,
    toExpression: true,
    toIdentifier: true,
    toKeyAlias: true,
    toSequenceExpression: true,
    toStatement: true,
    valueToNode: true,
    appendToMemberExpression: true,
    inherits: true,
    prependToMemberExpression: true,
    removeProperties: true,
    removePropertiesDeep: true,
    removeTypeDuplicates: true,
    getBindingIdentifiers: true,
    getOuterBindingIdentifiers: true,
    traverse: true,
    traverseFast: true,
    shallowEqual: true,
    is: true,
    isBinding: true,
    isBlockScoped: true,
    isImmutable: true,
    isLet: true,
    isNode: true,
    isNodesEquivalent: true,
    isPlaceholderType: true,
    isReferenced: true,
    isScope: true,
    isSpecifierDefault: true,
    isType: true,
    isValidES3Identifier: true,
    isValidIdentifier: true,
    isVar: true,
    matchesPattern: true,
    validate: true,
    buildMatchMemberExpression: true
};
Object.defineProperty(exports, "addComment", {
    enumerable: true,
    get: function() {
        return _addComment.default;
    }
});
Object.defineProperty(exports, "addComments", {
    enumerable: true,
    get: function() {
        return _addComments.default;
    }
});
Object.defineProperty(exports, "appendToMemberExpression", {
    enumerable: true,
    get: function() {
        return _appendToMemberExpression.default;
    }
});
Object.defineProperty(exports, "assertNode", {
    enumerable: true,
    get: function() {
        return _assertNode.default;
    }
});
Object.defineProperty(exports, "buildMatchMemberExpression", {
    enumerable: true,
    get: function() {
        return _buildMatchMemberExpression.default;
    }
});
Object.defineProperty(exports, "clone", {
    enumerable: true,
    get: function() {
        return _clone.default;
    }
});
Object.defineProperty(exports, "cloneDeep", {
    enumerable: true,
    get: function() {
        return _cloneDeep.default;
    }
});
Object.defineProperty(exports, "cloneDeepWithoutLoc", {
    enumerable: true,
    get: function() {
        return _cloneDeepWithoutLoc.default;
    }
});
Object.defineProperty(exports, "cloneNode", {
    enumerable: true,
    get: function() {
        return _cloneNode.default;
    }
});
Object.defineProperty(exports, "cloneWithoutLoc", {
    enumerable: true,
    get: function() {
        return _cloneWithoutLoc.default;
    }
});
Object.defineProperty(exports, "createFlowUnionType", {
    enumerable: true,
    get: function() {
        return _createFlowUnionType.default;
    }
});
Object.defineProperty(exports, "createTSUnionType", {
    enumerable: true,
    get: function() {
        return _createTSUnionType.default;
    }
});
Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
    enumerable: true,
    get: function() {
        return _createTypeAnnotationBasedOnTypeof.default;
    }
});
Object.defineProperty(exports, "createUnionTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _createFlowUnionType.default;
    }
});
Object.defineProperty(exports, "ensureBlock", {
    enumerable: true,
    get: function() {
        return _ensureBlock.default;
    }
});
Object.defineProperty(exports, "getBindingIdentifiers", {
    enumerable: true,
    get: function() {
        return _getBindingIdentifiers.default;
    }
});
Object.defineProperty(exports, "getOuterBindingIdentifiers", {
    enumerable: true,
    get: function() {
        return _getOuterBindingIdentifiers.default;
    }
});
Object.defineProperty(exports, "inheritInnerComments", {
    enumerable: true,
    get: function() {
        return _inheritInnerComments.default;
    }
});
Object.defineProperty(exports, "inheritLeadingComments", {
    enumerable: true,
    get: function() {
        return _inheritLeadingComments.default;
    }
});
Object.defineProperty(exports, "inheritTrailingComments", {
    enumerable: true,
    get: function() {
        return _inheritTrailingComments.default;
    }
});
Object.defineProperty(exports, "inherits", {
    enumerable: true,
    get: function() {
        return _inherits.default;
    }
});
Object.defineProperty(exports, "inheritsComments", {
    enumerable: true,
    get: function() {
        return _inheritsComments.default;
    }
});
Object.defineProperty(exports, "is", {
    enumerable: true,
    get: function() {
        return _is.default;
    }
});
Object.defineProperty(exports, "isBinding", {
    enumerable: true,
    get: function() {
        return _isBinding.default;
    }
});
Object.defineProperty(exports, "isBlockScoped", {
    enumerable: true,
    get: function() {
        return _isBlockScoped.default;
    }
});
Object.defineProperty(exports, "isImmutable", {
    enumerable: true,
    get: function() {
        return _isImmutable.default;
    }
});
Object.defineProperty(exports, "isLet", {
    enumerable: true,
    get: function() {
        return _isLet.default;
    }
});
Object.defineProperty(exports, "isNode", {
    enumerable: true,
    get: function() {
        return _isNode.default;
    }
});
Object.defineProperty(exports, "isNodesEquivalent", {
    enumerable: true,
    get: function() {
        return _isNodesEquivalent.default;
    }
});
Object.defineProperty(exports, "isPlaceholderType", {
    enumerable: true,
    get: function() {
        return _isPlaceholderType.default;
    }
});
Object.defineProperty(exports, "isReferenced", {
    enumerable: true,
    get: function() {
        return _isReferenced.default;
    }
});
Object.defineProperty(exports, "isScope", {
    enumerable: true,
    get: function() {
        return _isScope.default;
    }
});
Object.defineProperty(exports, "isSpecifierDefault", {
    enumerable: true,
    get: function() {
        return _isSpecifierDefault.default;
    }
});
Object.defineProperty(exports, "isType", {
    enumerable: true,
    get: function() {
        return _isType.default;
    }
});
Object.defineProperty(exports, "isValidES3Identifier", {
    enumerable: true,
    get: function() {
        return _isValidES3Identifier.default;
    }
});
Object.defineProperty(exports, "isValidIdentifier", {
    enumerable: true,
    get: function() {
        return _isValidIdentifier.default;
    }
});
Object.defineProperty(exports, "isVar", {
    enumerable: true,
    get: function() {
        return _isVar.default;
    }
});
Object.defineProperty(exports, "matchesPattern", {
    enumerable: true,
    get: function() {
        return _matchesPattern.default;
    }
});
Object.defineProperty(exports, "prependToMemberExpression", {
    enumerable: true,
    get: function() {
        return _prependToMemberExpression.default;
    }
});
exports.react = void 0;
Object.defineProperty(exports, "removeComments", {
    enumerable: true,
    get: function() {
        return _removeComments.default;
    }
});
Object.defineProperty(exports, "removeProperties", {
    enumerable: true,
    get: function() {
        return _removeProperties.default;
    }
});
Object.defineProperty(exports, "removePropertiesDeep", {
    enumerable: true,
    get: function() {
        return _removePropertiesDeep.default;
    }
});
Object.defineProperty(exports, "removeTypeDuplicates", {
    enumerable: true,
    get: function() {
        return _removeTypeDuplicates.default;
    }
});
Object.defineProperty(exports, "shallowEqual", {
    enumerable: true,
    get: function() {
        return _shallowEqual.default;
    }
});
Object.defineProperty(exports, "toBindingIdentifierName", {
    enumerable: true,
    get: function() {
        return _toBindingIdentifierName.default;
    }
});
Object.defineProperty(exports, "toBlock", {
    enumerable: true,
    get: function() {
        return _toBlock.default;
    }
});
Object.defineProperty(exports, "toComputedKey", {
    enumerable: true,
    get: function() {
        return _toComputedKey.default;
    }
});
Object.defineProperty(exports, "toExpression", {
    enumerable: true,
    get: function() {
        return _toExpression.default;
    }
});
Object.defineProperty(exports, "toIdentifier", {
    enumerable: true,
    get: function() {
        return _toIdentifier.default;
    }
});
Object.defineProperty(exports, "toKeyAlias", {
    enumerable: true,
    get: function() {
        return _toKeyAlias.default;
    }
});
Object.defineProperty(exports, "toSequenceExpression", {
    enumerable: true,
    get: function() {
        return _toSequenceExpression.default;
    }
});
Object.defineProperty(exports, "toStatement", {
    enumerable: true,
    get: function() {
        return _toStatement.default;
    }
});
Object.defineProperty(exports, "traverse", {
    enumerable: true,
    get: function() {
        return _traverse.default;
    }
});
Object.defineProperty(exports, "traverseFast", {
    enumerable: true,
    get: function() {
        return _traverseFast.default;
    }
});
Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
        return _validate.default;
    }
});
Object.defineProperty(exports, "valueToNode", {
    enumerable: true,
    get: function() {
        return _valueToNode.default;
    }
});
var _isReactComponent = require("./validators/react/isReactComponent");
var _isCompatTag = require("./validators/react/isCompatTag");
var _buildChildren = require("./builders/react/buildChildren");
var _assertNode = require("./asserts/assertNode");
var _generated = require("./asserts/generated");
Object.keys(_generated).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _generated[key];
        }
    });
});
var _createTypeAnnotationBasedOnTypeof = require("./builders/flow/createTypeAnnotationBasedOnTypeof");
var _createFlowUnionType = require("./builders/flow/createFlowUnionType");
var _createTSUnionType = require("./builders/typescript/createTSUnionType");
var _generated2 = require("./builders/generated");
Object.keys(_generated2).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated2[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _generated2[key];
        }
    });
});
var _uppercase = require("./builders/generated/uppercase");
Object.keys(_uppercase).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _uppercase[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _uppercase[key];
        }
    });
});
var _cloneNode = require("./clone/cloneNode");
var _clone = require("./clone/clone");
var _cloneDeep = require("./clone/cloneDeep");
var _cloneDeepWithoutLoc = require("./clone/cloneDeepWithoutLoc");
var _cloneWithoutLoc = require("./clone/cloneWithoutLoc");
var _addComment = require("./comments/addComment");
var _addComments = require("./comments/addComments");
var _inheritInnerComments = require("./comments/inheritInnerComments");
var _inheritLeadingComments = require("./comments/inheritLeadingComments");
var _inheritsComments = require("./comments/inheritsComments");
var _inheritTrailingComments = require("./comments/inheritTrailingComments");
var _removeComments = require("./comments/removeComments");
var _generated3 = require("./constants/generated");
Object.keys(_generated3).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated3[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _generated3[key];
        }
    });
});
var _constants = require("./constants");
Object.keys(_constants).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _constants[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _constants[key];
        }
    });
});
var _ensureBlock = require("./converters/ensureBlock");
var _toBindingIdentifierName = require("./converters/toBindingIdentifierName");
var _toBlock = require("./converters/toBlock");
var _toComputedKey = require("./converters/toComputedKey");
var _toExpression = require("./converters/toExpression");
var _toIdentifier = require("./converters/toIdentifier");
var _toKeyAlias = require("./converters/toKeyAlias");
var _toSequenceExpression = require("./converters/toSequenceExpression");
var _toStatement = require("./converters/toStatement");
var _valueToNode = require("./converters/valueToNode");
var _definitions = require("./definitions");
Object.keys(_definitions).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _definitions[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _definitions[key];
        }
    });
});
var _appendToMemberExpression = require("./modifications/appendToMemberExpression");
var _inherits = require("./modifications/inherits");
var _prependToMemberExpression = require("./modifications/prependToMemberExpression");
var _removeProperties = require("./modifications/removeProperties");
var _removePropertiesDeep = require("./modifications/removePropertiesDeep");
var _removeTypeDuplicates = require("./modifications/flow/removeTypeDuplicates");
var _getBindingIdentifiers = require("./retrievers/getBindingIdentifiers");
var _getOuterBindingIdentifiers = require("./retrievers/getOuterBindingIdentifiers");
var _traverse = require("./traverse/traverse");
Object.keys(_traverse).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _traverse[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _traverse[key];
        }
    });
});
var _traverseFast = require("./traverse/traverseFast");
var _shallowEqual = require("./utils/shallowEqual");
var _is = require("./validators/is");
var _isBinding = require("./validators/isBinding");
var _isBlockScoped = require("./validators/isBlockScoped");
var _isImmutable = require("./validators/isImmutable");
var _isLet = require("./validators/isLet");
var _isNode = require("./validators/isNode");
var _isNodesEquivalent = require("./validators/isNodesEquivalent");
var _isPlaceholderType = require("./validators/isPlaceholderType");
var _isReferenced = require("./validators/isReferenced");
var _isScope = require("./validators/isScope");
var _isSpecifierDefault = require("./validators/isSpecifierDefault");
var _isType = require("./validators/isType");
var _isValidES3Identifier = require("./validators/isValidES3Identifier");
var _isValidIdentifier = require("./validators/isValidIdentifier");
var _isVar = require("./validators/isVar");
var _matchesPattern = require("./validators/matchesPattern");
var _validate = require("./validators/validate");
var _buildMatchMemberExpression = require("./validators/buildMatchMemberExpression");
var _generated4 = require("./validators/generated");
Object.keys(_generated4).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated4[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _generated4[key];
        }
    });
});
var _generated5 = require("./ast-types/generated");
Object.keys(_generated5).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated5[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _generated5[key];
        }
    });
});
const react = {
    isReactComponent: _isReactComponent.default,
    isCompatTag: _isCompatTag.default,
    buildChildren: _buildChildren.default
};
exports.react = react;

},{"./validators/react/isReactComponent":"2wyTE","./validators/react/isCompatTag":"fU9fG","./builders/react/buildChildren":"7TOIu","./asserts/assertNode":"ckMRa","./asserts/generated":"b3BFn","./builders/flow/createTypeAnnotationBasedOnTypeof":"c7Cgb","./builders/flow/createFlowUnionType":"jseCf","./builders/typescript/createTSUnionType":"4SK0U","./builders/generated":"1bIPZ","./builders/generated/uppercase":"c1H7g","./clone/cloneNode":"5AE4Z","./clone/clone":"5LE1s","./clone/cloneDeep":"cMpx0","./clone/cloneDeepWithoutLoc":"9AJQI","./clone/cloneWithoutLoc":"hp1FS","./comments/addComment":"Xa1Mx","./comments/addComments":"5ysA1","./comments/inheritInnerComments":"nwPzA","./comments/inheritLeadingComments":"bdDai","./comments/inheritsComments":"jiPy2","./comments/inheritTrailingComments":"4Yyv2","./comments/removeComments":"5aNYQ","./constants/generated":"dgplI","./constants":"7tigb","./converters/ensureBlock":"6Cvs0","./converters/toBindingIdentifierName":"3RmFD","./converters/toBlock":"l0ogU","./converters/toComputedKey":"izZg2","./converters/toExpression":"2vzK3","./converters/toIdentifier":"afK5o","./converters/toKeyAlias":"7HJGS","./converters/toSequenceExpression":"koQe8","./converters/toStatement":"4yzX8","./converters/valueToNode":"aUXlu","./definitions":"lTnnW","./modifications/appendToMemberExpression":"4mHiV","./modifications/inherits":"i6c9H","./modifications/prependToMemberExpression":"lAt2b","./modifications/removeProperties":"hcFyb","./modifications/removePropertiesDeep":"2Tf8G","./modifications/flow/removeTypeDuplicates":"7ENKW","./retrievers/getBindingIdentifiers":"12FR9","./retrievers/getOuterBindingIdentifiers":"1kpUk","./traverse/traverse":"3xLxF","./traverse/traverseFast":"9wJiS","./utils/shallowEqual":"hnhdB","./validators/is":"hT8C8","./validators/isBinding":"lWoMG","./validators/isBlockScoped":"es1iD","./validators/isImmutable":"dlQAn","./validators/isLet":"hvGBh","./validators/isNode":"k3KRs","./validators/isNodesEquivalent":"9L0hZ","./validators/isPlaceholderType":"9J4JA","./validators/isReferenced":"1YvUB","./validators/isScope":"jixT8","./validators/isSpecifierDefault":"i49IN","./validators/isType":"bhmzl","./validators/isValidES3Identifier":"iZmST","./validators/isValidIdentifier":"gHSEO","./validators/isVar":"7xyV0","./validators/matchesPattern":"5uThx","./validators/validate":"dAbSc","./validators/buildMatchMemberExpression":"f7iUo","./validators/generated":"cfCci","./ast-types/generated":"46KAc"}],"2wyTE":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _buildMatchMemberExpression = require("../buildMatchMemberExpression");
const isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
var _default = isReactComponent;
exports.default = _default;

},{"../buildMatchMemberExpression":"f7iUo"}],"f7iUo":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = buildMatchMemberExpression;
var _matchesPattern = require("./matchesPattern");
function buildMatchMemberExpression(match, allowPartial) {
    const parts = match.split(".");
    return (member)=>(0, _matchesPattern.default)(member, parts, allowPartial)
    ;
}

},{"./matchesPattern":"5uThx"}],"5uThx":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = matchesPattern;
var _generated = require("./generated");
function matchesPattern(member, match, allowPartial) {
    if (!(0, _generated.isMemberExpression)(member)) return false;
    const parts = Array.isArray(match) ? match : match.split(".");
    const nodes = [];
    let node;
    for(node = member; (0, _generated.isMemberExpression)(node); node = node.object)nodes.push(node.property);
    nodes.push(node);
    if (nodes.length < parts.length) return false;
    if (!allowPartial && nodes.length > parts.length) return false;
    for(let i = 0, j = nodes.length - 1; i < parts.length; i++, j--){
        const node = nodes[j];
        let value;
        if ((0, _generated.isIdentifier)(node)) value = node.name;
        else if ((0, _generated.isStringLiteral)(node)) value = node.value;
        else if ((0, _generated.isThisExpression)(node)) value = "this";
        else return false;
        if (parts[i] !== value) return false;
    }
    return true;
}

},{"./generated":"cfCci"}],"cfCci":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
exports.isArgumentPlaceholder = isArgumentPlaceholder;
exports.isArrayExpression = isArrayExpression;
exports.isArrayPattern = isArrayPattern;
exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
exports.isArrowFunctionExpression = isArrowFunctionExpression;
exports.isAssignmentExpression = isAssignmentExpression;
exports.isAssignmentPattern = isAssignmentPattern;
exports.isAwaitExpression = isAwaitExpression;
exports.isBigIntLiteral = isBigIntLiteral;
exports.isBinary = isBinary;
exports.isBinaryExpression = isBinaryExpression;
exports.isBindExpression = isBindExpression;
exports.isBlock = isBlock;
exports.isBlockParent = isBlockParent;
exports.isBlockStatement = isBlockStatement;
exports.isBooleanLiteral = isBooleanLiteral;
exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
exports.isBreakStatement = isBreakStatement;
exports.isCallExpression = isCallExpression;
exports.isCatchClause = isCatchClause;
exports.isClass = isClass;
exports.isClassBody = isClassBody;
exports.isClassDeclaration = isClassDeclaration;
exports.isClassExpression = isClassExpression;
exports.isClassImplements = isClassImplements;
exports.isClassMethod = isClassMethod;
exports.isClassPrivateMethod = isClassPrivateMethod;
exports.isClassPrivateProperty = isClassPrivateProperty;
exports.isClassProperty = isClassProperty;
exports.isCompletionStatement = isCompletionStatement;
exports.isConditional = isConditional;
exports.isConditionalExpression = isConditionalExpression;
exports.isContinueStatement = isContinueStatement;
exports.isDebuggerStatement = isDebuggerStatement;
exports.isDecimalLiteral = isDecimalLiteral;
exports.isDeclaration = isDeclaration;
exports.isDeclareClass = isDeclareClass;
exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
exports.isDeclareFunction = isDeclareFunction;
exports.isDeclareInterface = isDeclareInterface;
exports.isDeclareModule = isDeclareModule;
exports.isDeclareModuleExports = isDeclareModuleExports;
exports.isDeclareOpaqueType = isDeclareOpaqueType;
exports.isDeclareTypeAlias = isDeclareTypeAlias;
exports.isDeclareVariable = isDeclareVariable;
exports.isDeclaredPredicate = isDeclaredPredicate;
exports.isDecorator = isDecorator;
exports.isDirective = isDirective;
exports.isDirectiveLiteral = isDirectiveLiteral;
exports.isDoExpression = isDoExpression;
exports.isDoWhileStatement = isDoWhileStatement;
exports.isEmptyStatement = isEmptyStatement;
exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
exports.isEnumBody = isEnumBody;
exports.isEnumBooleanBody = isEnumBooleanBody;
exports.isEnumBooleanMember = isEnumBooleanMember;
exports.isEnumDeclaration = isEnumDeclaration;
exports.isEnumDefaultedMember = isEnumDefaultedMember;
exports.isEnumMember = isEnumMember;
exports.isEnumNumberBody = isEnumNumberBody;
exports.isEnumNumberMember = isEnumNumberMember;
exports.isEnumStringBody = isEnumStringBody;
exports.isEnumStringMember = isEnumStringMember;
exports.isEnumSymbolBody = isEnumSymbolBody;
exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
exports.isExportAllDeclaration = isExportAllDeclaration;
exports.isExportDeclaration = isExportDeclaration;
exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
exports.isExportNamedDeclaration = isExportNamedDeclaration;
exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
exports.isExportSpecifier = isExportSpecifier;
exports.isExpression = isExpression;
exports.isExpressionStatement = isExpressionStatement;
exports.isExpressionWrapper = isExpressionWrapper;
exports.isFile = isFile;
exports.isFlow = isFlow;
exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
exports.isFlowDeclaration = isFlowDeclaration;
exports.isFlowPredicate = isFlowPredicate;
exports.isFlowType = isFlowType;
exports.isFor = isFor;
exports.isForInStatement = isForInStatement;
exports.isForOfStatement = isForOfStatement;
exports.isForStatement = isForStatement;
exports.isForXStatement = isForXStatement;
exports.isFunction = isFunction;
exports.isFunctionDeclaration = isFunctionDeclaration;
exports.isFunctionExpression = isFunctionExpression;
exports.isFunctionParent = isFunctionParent;
exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
exports.isFunctionTypeParam = isFunctionTypeParam;
exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
exports.isIdentifier = isIdentifier;
exports.isIfStatement = isIfStatement;
exports.isImmutable = isImmutable;
exports.isImport = isImport;
exports.isImportAttribute = isImportAttribute;
exports.isImportDeclaration = isImportDeclaration;
exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
exports.isImportSpecifier = isImportSpecifier;
exports.isIndexedAccessType = isIndexedAccessType;
exports.isInferredPredicate = isInferredPredicate;
exports.isInterfaceDeclaration = isInterfaceDeclaration;
exports.isInterfaceExtends = isInterfaceExtends;
exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
exports.isInterpreterDirective = isInterpreterDirective;
exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
exports.isJSX = isJSX;
exports.isJSXAttribute = isJSXAttribute;
exports.isJSXClosingElement = isJSXClosingElement;
exports.isJSXClosingFragment = isJSXClosingFragment;
exports.isJSXElement = isJSXElement;
exports.isJSXEmptyExpression = isJSXEmptyExpression;
exports.isJSXExpressionContainer = isJSXExpressionContainer;
exports.isJSXFragment = isJSXFragment;
exports.isJSXIdentifier = isJSXIdentifier;
exports.isJSXMemberExpression = isJSXMemberExpression;
exports.isJSXNamespacedName = isJSXNamespacedName;
exports.isJSXOpeningElement = isJSXOpeningElement;
exports.isJSXOpeningFragment = isJSXOpeningFragment;
exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
exports.isJSXSpreadChild = isJSXSpreadChild;
exports.isJSXText = isJSXText;
exports.isLVal = isLVal;
exports.isLabeledStatement = isLabeledStatement;
exports.isLiteral = isLiteral;
exports.isLogicalExpression = isLogicalExpression;
exports.isLoop = isLoop;
exports.isMemberExpression = isMemberExpression;
exports.isMetaProperty = isMetaProperty;
exports.isMethod = isMethod;
exports.isMiscellaneous = isMiscellaneous;
exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
exports.isModuleDeclaration = isModuleDeclaration;
exports.isModuleExpression = isModuleExpression;
exports.isModuleSpecifier = isModuleSpecifier;
exports.isNewExpression = isNewExpression;
exports.isNoop = isNoop;
exports.isNullLiteral = isNullLiteral;
exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
exports.isNumberLiteral = isNumberLiteral;
exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
exports.isNumericLiteral = isNumericLiteral;
exports.isObjectExpression = isObjectExpression;
exports.isObjectMember = isObjectMember;
exports.isObjectMethod = isObjectMethod;
exports.isObjectPattern = isObjectPattern;
exports.isObjectProperty = isObjectProperty;
exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
exports.isObjectTypeIndexer = isObjectTypeIndexer;
exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
exports.isObjectTypeProperty = isObjectTypeProperty;
exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
exports.isOpaqueType = isOpaqueType;
exports.isOptionalCallExpression = isOptionalCallExpression;
exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
exports.isOptionalMemberExpression = isOptionalMemberExpression;
exports.isParenthesizedExpression = isParenthesizedExpression;
exports.isPattern = isPattern;
exports.isPatternLike = isPatternLike;
exports.isPipelineBareFunction = isPipelineBareFunction;
exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
exports.isPipelineTopicExpression = isPipelineTopicExpression;
exports.isPlaceholder = isPlaceholder;
exports.isPrivate = isPrivate;
exports.isPrivateName = isPrivateName;
exports.isProgram = isProgram;
exports.isProperty = isProperty;
exports.isPureish = isPureish;
exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
exports.isRecordExpression = isRecordExpression;
exports.isRegExpLiteral = isRegExpLiteral;
exports.isRegexLiteral = isRegexLiteral;
exports.isRestElement = isRestElement;
exports.isRestProperty = isRestProperty;
exports.isReturnStatement = isReturnStatement;
exports.isScopable = isScopable;
exports.isSequenceExpression = isSequenceExpression;
exports.isSpreadElement = isSpreadElement;
exports.isSpreadProperty = isSpreadProperty;
exports.isStandardized = isStandardized;
exports.isStatement = isStatement;
exports.isStaticBlock = isStaticBlock;
exports.isStringLiteral = isStringLiteral;
exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
exports.isStringTypeAnnotation = isStringTypeAnnotation;
exports.isSuper = isSuper;
exports.isSwitchCase = isSwitchCase;
exports.isSwitchStatement = isSwitchStatement;
exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
exports.isTSAnyKeyword = isTSAnyKeyword;
exports.isTSArrayType = isTSArrayType;
exports.isTSAsExpression = isTSAsExpression;
exports.isTSBaseType = isTSBaseType;
exports.isTSBigIntKeyword = isTSBigIntKeyword;
exports.isTSBooleanKeyword = isTSBooleanKeyword;
exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
exports.isTSConditionalType = isTSConditionalType;
exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
exports.isTSConstructorType = isTSConstructorType;
exports.isTSDeclareFunction = isTSDeclareFunction;
exports.isTSDeclareMethod = isTSDeclareMethod;
exports.isTSEntityName = isTSEntityName;
exports.isTSEnumDeclaration = isTSEnumDeclaration;
exports.isTSEnumMember = isTSEnumMember;
exports.isTSExportAssignment = isTSExportAssignment;
exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
exports.isTSExternalModuleReference = isTSExternalModuleReference;
exports.isTSFunctionType = isTSFunctionType;
exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
exports.isTSImportType = isTSImportType;
exports.isTSIndexSignature = isTSIndexSignature;
exports.isTSIndexedAccessType = isTSIndexedAccessType;
exports.isTSInferType = isTSInferType;
exports.isTSInterfaceBody = isTSInterfaceBody;
exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
exports.isTSIntersectionType = isTSIntersectionType;
exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
exports.isTSLiteralType = isTSLiteralType;
exports.isTSMappedType = isTSMappedType;
exports.isTSMethodSignature = isTSMethodSignature;
exports.isTSModuleBlock = isTSModuleBlock;
exports.isTSModuleDeclaration = isTSModuleDeclaration;
exports.isTSNamedTupleMember = isTSNamedTupleMember;
exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
exports.isTSNeverKeyword = isTSNeverKeyword;
exports.isTSNonNullExpression = isTSNonNullExpression;
exports.isTSNullKeyword = isTSNullKeyword;
exports.isTSNumberKeyword = isTSNumberKeyword;
exports.isTSObjectKeyword = isTSObjectKeyword;
exports.isTSOptionalType = isTSOptionalType;
exports.isTSParameterProperty = isTSParameterProperty;
exports.isTSParenthesizedType = isTSParenthesizedType;
exports.isTSPropertySignature = isTSPropertySignature;
exports.isTSQualifiedName = isTSQualifiedName;
exports.isTSRestType = isTSRestType;
exports.isTSStringKeyword = isTSStringKeyword;
exports.isTSSymbolKeyword = isTSSymbolKeyword;
exports.isTSThisType = isTSThisType;
exports.isTSTupleType = isTSTupleType;
exports.isTSType = isTSType;
exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
exports.isTSTypeAnnotation = isTSTypeAnnotation;
exports.isTSTypeAssertion = isTSTypeAssertion;
exports.isTSTypeElement = isTSTypeElement;
exports.isTSTypeLiteral = isTSTypeLiteral;
exports.isTSTypeOperator = isTSTypeOperator;
exports.isTSTypeParameter = isTSTypeParameter;
exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
exports.isTSTypePredicate = isTSTypePredicate;
exports.isTSTypeQuery = isTSTypeQuery;
exports.isTSTypeReference = isTSTypeReference;
exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
exports.isTSUnionType = isTSUnionType;
exports.isTSUnknownKeyword = isTSUnknownKeyword;
exports.isTSVoidKeyword = isTSVoidKeyword;
exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
exports.isTemplateElement = isTemplateElement;
exports.isTemplateLiteral = isTemplateLiteral;
exports.isTerminatorless = isTerminatorless;
exports.isThisExpression = isThisExpression;
exports.isThisTypeAnnotation = isThisTypeAnnotation;
exports.isThrowStatement = isThrowStatement;
exports.isTopicReference = isTopicReference;
exports.isTryStatement = isTryStatement;
exports.isTupleExpression = isTupleExpression;
exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
exports.isTypeAlias = isTypeAlias;
exports.isTypeAnnotation = isTypeAnnotation;
exports.isTypeCastExpression = isTypeCastExpression;
exports.isTypeParameter = isTypeParameter;
exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
exports.isTypeScript = isTypeScript;
exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
exports.isUnaryExpression = isUnaryExpression;
exports.isUnaryLike = isUnaryLike;
exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
exports.isUpdateExpression = isUpdateExpression;
exports.isUserWhitespacable = isUserWhitespacable;
exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
exports.isVariableDeclaration = isVariableDeclaration;
exports.isVariableDeclarator = isVariableDeclarator;
exports.isVariance = isVariance;
exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
exports.isWhile = isWhile;
exports.isWhileStatement = isWhileStatement;
exports.isWithStatement = isWithStatement;
exports.isYieldExpression = isYieldExpression;
var _shallowEqual = require("../../utils/shallowEqual");
function isArrayExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ArrayExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isAssignmentExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "AssignmentExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBinaryExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BinaryExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isInterpreterDirective(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "InterpreterDirective") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDirective(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Directive") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDirectiveLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DirectiveLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBlockStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BlockStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBreakStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BreakStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isCallExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "CallExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isCatchClause(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "CatchClause") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isConditionalExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ConditionalExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isContinueStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ContinueStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDebuggerStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DebuggerStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDoWhileStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DoWhileStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEmptyStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EmptyStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExpressionStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExpressionStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFile(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "File") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isForInStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ForInStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isForStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ForStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFunctionDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "FunctionDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFunctionExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "FunctionExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Identifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isIfStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "IfStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isLabeledStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "LabeledStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isStringLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "StringLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNumericLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NumericLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNullLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NullLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBooleanLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BooleanLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isRegExpLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "RegExpLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isLogicalExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "LogicalExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isMemberExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "MemberExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNewExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NewExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isProgram(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Program") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectMethod") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isRestElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "RestElement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isReturnStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ReturnStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSequenceExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SequenceExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isParenthesizedExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ParenthesizedExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSwitchCase(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SwitchCase") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSwitchStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SwitchStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isThisExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ThisExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isThrowStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ThrowStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTryStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TryStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isUnaryExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "UnaryExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isUpdateExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "UpdateExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isVariableDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "VariableDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isVariableDeclarator(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "VariableDeclarator") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isWhileStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "WhileStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isWithStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "WithStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isAssignmentPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "AssignmentPattern") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isArrayPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ArrayPattern") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isArrowFunctionExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ArrowFunctionExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassBody") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportAllDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportAllDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportDefaultDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportDefaultDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportNamedDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportNamedDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportSpecifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isForOfStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ForOfStatement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ImportDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImportDefaultSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ImportDefaultSpecifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ImportNamespaceSpecifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImportSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ImportSpecifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isMetaProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "MetaProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassMethod") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectPattern") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSpreadElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SpreadElement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSuper(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Super") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTaggedTemplateExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TaggedTemplateExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTemplateElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TemplateElement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTemplateLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TemplateLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isYieldExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "YieldExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isAwaitExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "AwaitExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImport(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Import") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBigIntLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BigIntLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportNamespaceSpecifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isOptionalMemberExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "OptionalMemberExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isOptionalCallExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "OptionalCallExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassPrivateProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassPrivateProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassPrivateMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassPrivateMethod") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPrivateName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "PrivateName") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isStaticBlock(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "StaticBlock") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isAnyTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "AnyTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isArrayTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ArrayTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBooleanTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BooleanTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBooleanLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BooleanLiteralTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNullLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NullLiteralTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClassImplements(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ClassImplements") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareClass(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareClass") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareFunction") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareInterface(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareInterface") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareModule(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareModule") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareModuleExports(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareModuleExports") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareTypeAlias(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareTypeAlias") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareOpaqueType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareOpaqueType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareVariable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareVariable") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareExportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareExportDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclareExportAllDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclareExportAllDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclaredPredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DeclaredPredicate") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExistsTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExistsTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFunctionTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "FunctionTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFunctionTypeParam(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "FunctionTypeParam") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isGenericTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "GenericTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isInferredPredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "InferredPredicate") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isInterfaceExtends(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "InterfaceExtends") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isInterfaceDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "InterfaceDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isInterfaceTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "InterfaceTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isIntersectionTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "IntersectionTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isMixedTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "MixedTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEmptyTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EmptyTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNullableTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NullableTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNumberLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NumberLiteralTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNumberTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NumberTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectTypeInternalSlot(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeInternalSlot") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectTypeCallProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeCallProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectTypeIndexer(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeIndexer") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectTypeProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectTypeSpreadProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ObjectTypeSpreadProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isOpaqueType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "OpaqueType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isQualifiedTypeIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "QualifiedTypeIdentifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isStringLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "StringLiteralTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isStringTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "StringTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSymbolTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SymbolTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isThisTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ThisTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTupleTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TupleTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeofTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeofTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeAlias(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeAlias") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeCastExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeCastExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeParameter(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeParameter") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeParameterDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TypeParameterInstantiation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isUnionTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "UnionTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isVariance(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Variance") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isVoidTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "VoidTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumBooleanBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumBooleanBody") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumNumberBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumNumberBody") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumStringBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumStringBody") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumSymbolBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumSymbolBody") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumBooleanMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumBooleanMember") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumNumberMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumNumberMember") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumStringMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumStringMember") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumDefaultedMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "EnumDefaultedMember") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isIndexedAccessType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "IndexedAccessType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isOptionalIndexedAccessType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "OptionalIndexedAccessType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXAttribute(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXAttribute") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXClosingElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXClosingElement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXElement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXEmptyExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXEmptyExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXExpressionContainer(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXExpressionContainer") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXSpreadChild(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXSpreadChild") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXIdentifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXMemberExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXMemberExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXNamespacedName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXNamespacedName") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXOpeningElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXOpeningElement") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXSpreadAttribute(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXSpreadAttribute") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXText(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXText") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXFragment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXFragment") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXOpeningFragment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXOpeningFragment") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSXClosingFragment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "JSXClosingFragment") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNoop(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Noop") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPlaceholder(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Placeholder") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isV8IntrinsicIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "V8IntrinsicIdentifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isArgumentPlaceholder(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ArgumentPlaceholder") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBindExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "BindExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImportAttribute(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ImportAttribute") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDecorator(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "Decorator") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDoExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DoExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportDefaultSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ExportDefaultSpecifier") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isRecordExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "RecordExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTupleExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TupleExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDecimalLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "DecimalLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isModuleExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "ModuleExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTopicReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TopicReference") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPipelineTopicExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "PipelineTopicExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPipelineBareFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "PipelineBareFunction") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPipelinePrimaryTopicReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "PipelinePrimaryTopicReference") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSParameterProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSParameterProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSDeclareFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSDeclareFunction") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSDeclareMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSDeclareMethod") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSQualifiedName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSQualifiedName") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSCallSignatureDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSCallSignatureDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSConstructSignatureDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSConstructSignatureDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSPropertySignature(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSPropertySignature") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSMethodSignature(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSMethodSignature") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSIndexSignature(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSIndexSignature") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSAnyKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSAnyKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSBooleanKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSBooleanKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSBigIntKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSBigIntKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSIntrinsicKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSIntrinsicKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSNeverKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNeverKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSNullKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNullKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSNumberKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNumberKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSObjectKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSObjectKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSStringKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSStringKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSSymbolKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSSymbolKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSUndefinedKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSUndefinedKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSUnknownKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSUnknownKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSVoidKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSVoidKeyword") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSThisType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSThisType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSFunctionType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSFunctionType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSConstructorType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSConstructorType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeReference") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypePredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypePredicate") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeQuery(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeQuery") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSArrayType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSArrayType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTupleType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTupleType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSOptionalType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSOptionalType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSRestType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSRestType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSNamedTupleMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNamedTupleMember") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSUnionType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSUnionType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSIntersectionType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSIntersectionType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSConditionalType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSConditionalType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSInferType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSInferType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSParenthesizedType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSParenthesizedType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeOperator(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeOperator") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSIndexedAccessType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSIndexedAccessType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSMappedType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSMappedType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSLiteralType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSLiteralType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSExpressionWithTypeArguments(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSExpressionWithTypeArguments") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSInterfaceDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSInterfaceDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSInterfaceBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSInterfaceBody") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeAliasDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeAliasDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSAsExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSAsExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeAssertion(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeAssertion") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSEnumDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSEnumDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSEnumMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSEnumMember") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSModuleDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSModuleDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSModuleBlock(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSModuleBlock") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSImportType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSImportType") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSImportEqualsDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSImportEqualsDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSExternalModuleReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSExternalModuleReference") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSNonNullExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNonNullExpression") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSExportAssignment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSExportAssignment") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSNamespaceExportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSNamespaceExportDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeAnnotation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeParameterInstantiation") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeParameterDeclaration") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeParameter(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "TSTypeParameter") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isStandardized(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "InterpreterDirective" === nodeType || "Directive" === nodeType || "DirectiveLiteral" === nodeType || "BlockStatement" === nodeType || "BreakStatement" === nodeType || "CallExpression" === nodeType || "CatchClause" === nodeType || "ConditionalExpression" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "File" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "Program" === nodeType || "ObjectExpression" === nodeType || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "RestElement" === nodeType || "ReturnStatement" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "SwitchCase" === nodeType || "SwitchStatement" === nodeType || "ThisExpression" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "VariableDeclaration" === nodeType || "VariableDeclarator" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassBody" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ExportSpecifier" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "MetaProperty" === nodeType || "ClassMethod" === nodeType || "ObjectPattern" === nodeType || "SpreadElement" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateElement" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "ExportNamespaceSpecifier" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType || "StaticBlock" === nodeType || nodeType === "Placeholder" && ("Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode || "BlockStatement" === node.expectedNode || "ClassBody" === node.expectedNode)) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "BindExpression" === nodeType || "DoExpression" === nodeType || "RecordExpression" === nodeType || "TupleExpression" === nodeType || "DecimalLiteral" === nodeType || "ModuleExpression" === nodeType || "TopicReference" === nodeType || "PipelineTopicExpression" === nodeType || "PipelineBareFunction" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Expression" === node.expectedNode || "Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode)) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBinary(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isScopable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBlockParent(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isBlock(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BlockStatement" === nodeType || "Program" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || nodeType === "Placeholder" && ("Statement" === node.expectedNode || "Declaration" === node.expectedNode || "BlockStatement" === node.expectedNode)) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTerminatorless(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isCompletionStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isConditional(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ConditionalExpression" === nodeType || "IfStatement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isLoop(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isWhile(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExpressionWrapper(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ExpressionStatement" === nodeType || "ParenthesizedExpression" === nodeType || "TypeCastExpression" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFor(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isForXStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ForInStatement" === nodeType || "ForOfStatement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFunctionParent(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPureish(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || nodeType === "Placeholder" && "Declaration" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPatternLike(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isLVal(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSEntityName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("Identifier" === nodeType || "TSQualifiedName" === nodeType || nodeType === "Placeholder" && "Identifier" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isImmutable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "BigIntLiteral" === nodeType || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXOpeningElement" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isUserWhitespacable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isObjectMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isUnaryLike(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("UnaryExpression" === nodeType || "SpreadElement" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && "Pattern" === node.expectedNode) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isClass(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ClassExpression" === nodeType || "ClassDeclaration" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isModuleDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isExportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isModuleSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isPrivate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFlow(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType || "EnumDeclaration" === nodeType || "EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType || "EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFlowType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFlowBaseAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFlowDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isFlowPredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isEnumMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isJSX(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isMiscellaneous(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("Noop" === nodeType || "Placeholder" === nodeType || "V8IntrinsicIdentifier" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTypeScript(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("TSParameterProperty" === nodeType || "TSDeclareFunction" === nodeType || "TSDeclareMethod" === nodeType || "TSQualifiedName" === nodeType || "TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSNamedTupleMember" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSInterfaceBody" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSEnumDeclaration" === nodeType || "TSEnumMember" === nodeType || "TSModuleDeclaration" === nodeType || "TSModuleBlock" === nodeType || "TSImportType" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExternalModuleReference" === nodeType || "TSNonNullExpression" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || "TSTypeAnnotation" === nodeType || "TSTypeParameterInstantiation" === nodeType || "TSTypeParameterDeclaration" === nodeType || "TSTypeParameter" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSTypeElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isTSBaseType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;
    if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSLiteralType" === nodeType) {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isNumberLiteral(node, opts) {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "NumberLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isRegexLiteral(node, opts) {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "RegexLiteral") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isRestProperty(node, opts) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "RestProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}
function isSpreadProperty(node, opts) {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");
    if (!node) return false;
    const nodeType = node.type;
    if (nodeType === "SpreadProperty") {
        if (typeof opts === "undefined") return true;
        else return (0, _shallowEqual.default)(node, opts);
    }
    return false;
}

},{"../../utils/shallowEqual":"hnhdB"}],"hnhdB":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = shallowEqual;
function shallowEqual(actual, expected) {
    const keys = Object.keys(expected);
    for (const key of keys){
        if (actual[key] !== expected[key]) return false;
    }
    return true;
}

},{}],"fU9fG":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isCompatTag;
function isCompatTag(tagName) {
    return !!tagName && /^[a-z]/.test(tagName);
}

},{}],"7TOIu":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = buildChildren;
var _generated = require("../../validators/generated");
var _cleanJSXElementLiteralChild = require("../../utils/react/cleanJSXElementLiteralChild");
function buildChildren(node) {
    const elements = [];
    for(let i = 0; i < node.children.length; i++){
        let child = node.children[i];
        if ((0, _generated.isJSXText)(child)) {
            (0, _cleanJSXElementLiteralChild.default)(child, elements);
            continue;
        }
        if ((0, _generated.isJSXExpressionContainer)(child)) child = child.expression;
        if ((0, _generated.isJSXEmptyExpression)(child)) continue;
        elements.push(child);
    }
    return elements;
}

},{"../../validators/generated":"cfCci","../../utils/react/cleanJSXElementLiteralChild":"kgGQJ"}],"kgGQJ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cleanJSXElementLiteralChild;
var _generated = require("../../builders/generated");
function cleanJSXElementLiteralChild(child, args) {
    const lines = child.value.split(/\r\n|\n|\r/);
    let lastNonEmptyLine = 0;
    for(let i = 0; i < lines.length; i++)if (lines[i].match(/[^ \t]/)) lastNonEmptyLine = i;
    let str = "";
    for(let i1 = 0; i1 < lines.length; i1++){
        const line = lines[i1];
        const isFirstLine = i1 === 0;
        const isLastLine = i1 === lines.length - 1;
        const isLastNonEmptyLine = i1 === lastNonEmptyLine;
        let trimmedLine = line.replace(/\t/g, " ");
        if (!isFirstLine) trimmedLine = trimmedLine.replace(/^[ ]+/, "");
        if (!isLastLine) trimmedLine = trimmedLine.replace(/[ ]+$/, "");
        if (trimmedLine) {
            if (!isLastNonEmptyLine) trimmedLine += " ";
            str += trimmedLine;
        }
    }
    if (str) args.push((0, _generated.stringLiteral)(str));
}

},{"../../builders/generated":"1bIPZ"}],"1bIPZ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.anyTypeAnnotation = anyTypeAnnotation;
exports.argumentPlaceholder = argumentPlaceholder;
exports.arrayExpression = arrayExpression;
exports.arrayPattern = arrayPattern;
exports.arrayTypeAnnotation = arrayTypeAnnotation;
exports.arrowFunctionExpression = arrowFunctionExpression;
exports.assignmentExpression = assignmentExpression;
exports.assignmentPattern = assignmentPattern;
exports.awaitExpression = awaitExpression;
exports.bigIntLiteral = bigIntLiteral;
exports.binaryExpression = binaryExpression;
exports.bindExpression = bindExpression;
exports.blockStatement = blockStatement;
exports.booleanLiteral = booleanLiteral;
exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
exports.booleanTypeAnnotation = booleanTypeAnnotation;
exports.breakStatement = breakStatement;
exports.callExpression = callExpression;
exports.catchClause = catchClause;
exports.classBody = classBody;
exports.classDeclaration = classDeclaration;
exports.classExpression = classExpression;
exports.classImplements = classImplements;
exports.classMethod = classMethod;
exports.classPrivateMethod = classPrivateMethod;
exports.classPrivateProperty = classPrivateProperty;
exports.classProperty = classProperty;
exports.conditionalExpression = conditionalExpression;
exports.continueStatement = continueStatement;
exports.debuggerStatement = debuggerStatement;
exports.decimalLiteral = decimalLiteral;
exports.declareClass = declareClass;
exports.declareExportAllDeclaration = declareExportAllDeclaration;
exports.declareExportDeclaration = declareExportDeclaration;
exports.declareFunction = declareFunction;
exports.declareInterface = declareInterface;
exports.declareModule = declareModule;
exports.declareModuleExports = declareModuleExports;
exports.declareOpaqueType = declareOpaqueType;
exports.declareTypeAlias = declareTypeAlias;
exports.declareVariable = declareVariable;
exports.declaredPredicate = declaredPredicate;
exports.decorator = decorator;
exports.directive = directive;
exports.directiveLiteral = directiveLiteral;
exports.doExpression = doExpression;
exports.doWhileStatement = doWhileStatement;
exports.emptyStatement = emptyStatement;
exports.emptyTypeAnnotation = emptyTypeAnnotation;
exports.enumBooleanBody = enumBooleanBody;
exports.enumBooleanMember = enumBooleanMember;
exports.enumDeclaration = enumDeclaration;
exports.enumDefaultedMember = enumDefaultedMember;
exports.enumNumberBody = enumNumberBody;
exports.enumNumberMember = enumNumberMember;
exports.enumStringBody = enumStringBody;
exports.enumStringMember = enumStringMember;
exports.enumSymbolBody = enumSymbolBody;
exports.existsTypeAnnotation = existsTypeAnnotation;
exports.exportAllDeclaration = exportAllDeclaration;
exports.exportDefaultDeclaration = exportDefaultDeclaration;
exports.exportDefaultSpecifier = exportDefaultSpecifier;
exports.exportNamedDeclaration = exportNamedDeclaration;
exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
exports.exportSpecifier = exportSpecifier;
exports.expressionStatement = expressionStatement;
exports.file = file;
exports.forInStatement = forInStatement;
exports.forOfStatement = forOfStatement;
exports.forStatement = forStatement;
exports.functionDeclaration = functionDeclaration;
exports.functionExpression = functionExpression;
exports.functionTypeAnnotation = functionTypeAnnotation;
exports.functionTypeParam = functionTypeParam;
exports.genericTypeAnnotation = genericTypeAnnotation;
exports.identifier = identifier;
exports.ifStatement = ifStatement;
exports.import = _import;
exports.importAttribute = importAttribute;
exports.importDeclaration = importDeclaration;
exports.importDefaultSpecifier = importDefaultSpecifier;
exports.importNamespaceSpecifier = importNamespaceSpecifier;
exports.importSpecifier = importSpecifier;
exports.indexedAccessType = indexedAccessType;
exports.inferredPredicate = inferredPredicate;
exports.interfaceDeclaration = interfaceDeclaration;
exports.interfaceExtends = interfaceExtends;
exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
exports.interpreterDirective = interpreterDirective;
exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
exports.jSXAttribute = exports.jsxAttribute = jsxAttribute;
exports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
exports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
exports.jSXElement = exports.jsxElement = jsxElement;
exports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
exports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
exports.jSXFragment = exports.jsxFragment = jsxFragment;
exports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
exports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
exports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
exports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
exports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
exports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
exports.jSXText = exports.jsxText = jsxText;
exports.labeledStatement = labeledStatement;
exports.logicalExpression = logicalExpression;
exports.memberExpression = memberExpression;
exports.metaProperty = metaProperty;
exports.mixedTypeAnnotation = mixedTypeAnnotation;
exports.moduleExpression = moduleExpression;
exports.newExpression = newExpression;
exports.noop = noop;
exports.nullLiteral = nullLiteral;
exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
exports.nullableTypeAnnotation = nullableTypeAnnotation;
exports.numberLiteral = NumberLiteral;
exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
exports.numberTypeAnnotation = numberTypeAnnotation;
exports.numericLiteral = numericLiteral;
exports.objectExpression = objectExpression;
exports.objectMethod = objectMethod;
exports.objectPattern = objectPattern;
exports.objectProperty = objectProperty;
exports.objectTypeAnnotation = objectTypeAnnotation;
exports.objectTypeCallProperty = objectTypeCallProperty;
exports.objectTypeIndexer = objectTypeIndexer;
exports.objectTypeInternalSlot = objectTypeInternalSlot;
exports.objectTypeProperty = objectTypeProperty;
exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
exports.opaqueType = opaqueType;
exports.optionalCallExpression = optionalCallExpression;
exports.optionalIndexedAccessType = optionalIndexedAccessType;
exports.optionalMemberExpression = optionalMemberExpression;
exports.parenthesizedExpression = parenthesizedExpression;
exports.pipelineBareFunction = pipelineBareFunction;
exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
exports.pipelineTopicExpression = pipelineTopicExpression;
exports.placeholder = placeholder;
exports.privateName = privateName;
exports.program = program;
exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
exports.recordExpression = recordExpression;
exports.regExpLiteral = regExpLiteral;
exports.regexLiteral = RegexLiteral;
exports.restElement = restElement;
exports.restProperty = RestProperty;
exports.returnStatement = returnStatement;
exports.sequenceExpression = sequenceExpression;
exports.spreadElement = spreadElement;
exports.spreadProperty = SpreadProperty;
exports.staticBlock = staticBlock;
exports.stringLiteral = stringLiteral;
exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
exports.stringTypeAnnotation = stringTypeAnnotation;
exports.super = _super;
exports.switchCase = switchCase;
exports.switchStatement = switchStatement;
exports.symbolTypeAnnotation = symbolTypeAnnotation;
exports.taggedTemplateExpression = taggedTemplateExpression;
exports.templateElement = templateElement;
exports.templateLiteral = templateLiteral;
exports.thisExpression = thisExpression;
exports.thisTypeAnnotation = thisTypeAnnotation;
exports.throwStatement = throwStatement;
exports.topicReference = topicReference;
exports.tryStatement = tryStatement;
exports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
exports.tSArrayType = exports.tsArrayType = tsArrayType;
exports.tSAsExpression = exports.tsAsExpression = tsAsExpression;
exports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
exports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
exports.tSConditionalType = exports.tsConditionalType = tsConditionalType;
exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
exports.tSConstructorType = exports.tsConstructorType = tsConstructorType;
exports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
exports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
exports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
exports.tSEnumMember = exports.tsEnumMember = tsEnumMember;
exports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
exports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
exports.tSFunctionType = exports.tsFunctionType = tsFunctionType;
exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
exports.tSImportType = exports.tsImportType = tsImportType;
exports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
exports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
exports.tSInferType = exports.tsInferType = tsInferType;
exports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
exports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;
exports.tSLiteralType = exports.tsLiteralType = tsLiteralType;
exports.tSMappedType = exports.tsMappedType = tsMappedType;
exports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
exports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
exports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
exports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
exports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
exports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
exports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
exports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
exports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
exports.tSOptionalType = exports.tsOptionalType = tsOptionalType;
exports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
exports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
exports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
exports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
exports.tSRestType = exports.tsRestType = tsRestType;
exports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
exports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
exports.tSThisType = exports.tsThisType = tsThisType;
exports.tSTupleType = exports.tsTupleType = tsTupleType;
exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
exports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
exports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
exports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
exports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
exports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
exports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
exports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
exports.tSTypeReference = exports.tsTypeReference = tsTypeReference;
exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
exports.tSUnionType = exports.tsUnionType = tsUnionType;
exports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
exports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
exports.tupleExpression = tupleExpression;
exports.tupleTypeAnnotation = tupleTypeAnnotation;
exports.typeAlias = typeAlias;
exports.typeAnnotation = typeAnnotation;
exports.typeCastExpression = typeCastExpression;
exports.typeParameter = typeParameter;
exports.typeParameterDeclaration = typeParameterDeclaration;
exports.typeParameterInstantiation = typeParameterInstantiation;
exports.typeofTypeAnnotation = typeofTypeAnnotation;
exports.unaryExpression = unaryExpression;
exports.unionTypeAnnotation = unionTypeAnnotation;
exports.updateExpression = updateExpression;
exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
exports.variableDeclaration = variableDeclaration;
exports.variableDeclarator = variableDeclarator;
exports.variance = variance;
exports.voidTypeAnnotation = voidTypeAnnotation;
exports.whileStatement = whileStatement;
exports.withStatement = withStatement;
exports.yieldExpression = yieldExpression;
var _builder = require("../builder");
function arrayExpression(elements) {
    return _builder.default.apply("ArrayExpression", arguments);
}
function assignmentExpression(operator, left, right) {
    return _builder.default.apply("AssignmentExpression", arguments);
}
function binaryExpression(operator, left, right) {
    return _builder.default.apply("BinaryExpression", arguments);
}
function interpreterDirective(value) {
    return _builder.default.apply("InterpreterDirective", arguments);
}
function directive(value) {
    return _builder.default.apply("Directive", arguments);
}
function directiveLiteral(value) {
    return _builder.default.apply("DirectiveLiteral", arguments);
}
function blockStatement(body, directives) {
    return _builder.default.apply("BlockStatement", arguments);
}
function breakStatement(label) {
    return _builder.default.apply("BreakStatement", arguments);
}
function callExpression(callee, _arguments) {
    return _builder.default.apply("CallExpression", arguments);
}
function catchClause(param, body) {
    return _builder.default.apply("CatchClause", arguments);
}
function conditionalExpression(test, consequent, alternate) {
    return _builder.default.apply("ConditionalExpression", arguments);
}
function continueStatement(label) {
    return _builder.default.apply("ContinueStatement", arguments);
}
function debuggerStatement() {
    return _builder.default.apply("DebuggerStatement", arguments);
}
function doWhileStatement(test, body) {
    return _builder.default.apply("DoWhileStatement", arguments);
}
function emptyStatement() {
    return _builder.default.apply("EmptyStatement", arguments);
}
function expressionStatement(expression) {
    return _builder.default.apply("ExpressionStatement", arguments);
}
function file(program, comments, tokens) {
    return _builder.default.apply("File", arguments);
}
function forInStatement(left, right, body) {
    return _builder.default.apply("ForInStatement", arguments);
}
function forStatement(init, test, update, body) {
    return _builder.default.apply("ForStatement", arguments);
}
function functionDeclaration(id, params, body, generator, async) {
    return _builder.default.apply("FunctionDeclaration", arguments);
}
function functionExpression(id, params, body, generator, async) {
    return _builder.default.apply("FunctionExpression", arguments);
}
function identifier(name) {
    return _builder.default.apply("Identifier", arguments);
}
function ifStatement(test, consequent, alternate) {
    return _builder.default.apply("IfStatement", arguments);
}
function labeledStatement(label, body) {
    return _builder.default.apply("LabeledStatement", arguments);
}
function stringLiteral(value) {
    return _builder.default.apply("StringLiteral", arguments);
}
function numericLiteral(value) {
    return _builder.default.apply("NumericLiteral", arguments);
}
function nullLiteral() {
    return _builder.default.apply("NullLiteral", arguments);
}
function booleanLiteral(value) {
    return _builder.default.apply("BooleanLiteral", arguments);
}
function regExpLiteral(pattern, flags) {
    return _builder.default.apply("RegExpLiteral", arguments);
}
function logicalExpression(operator, left, right) {
    return _builder.default.apply("LogicalExpression", arguments);
}
function memberExpression(object, property, computed, optional) {
    return _builder.default.apply("MemberExpression", arguments);
}
function newExpression(callee, _arguments) {
    return _builder.default.apply("NewExpression", arguments);
}
function program(body, directives, sourceType, interpreter) {
    return _builder.default.apply("Program", arguments);
}
function objectExpression(properties) {
    return _builder.default.apply("ObjectExpression", arguments);
}
function objectMethod(kind, key, params, body, computed, generator, async) {
    return _builder.default.apply("ObjectMethod", arguments);
}
function objectProperty(key, value, computed, shorthand, decorators) {
    return _builder.default.apply("ObjectProperty", arguments);
}
function restElement(argument) {
    return _builder.default.apply("RestElement", arguments);
}
function returnStatement(argument) {
    return _builder.default.apply("ReturnStatement", arguments);
}
function sequenceExpression(expressions) {
    return _builder.default.apply("SequenceExpression", arguments);
}
function parenthesizedExpression(expression) {
    return _builder.default.apply("ParenthesizedExpression", arguments);
}
function switchCase(test, consequent) {
    return _builder.default.apply("SwitchCase", arguments);
}
function switchStatement(discriminant, cases) {
    return _builder.default.apply("SwitchStatement", arguments);
}
function thisExpression() {
    return _builder.default.apply("ThisExpression", arguments);
}
function throwStatement(argument) {
    return _builder.default.apply("ThrowStatement", arguments);
}
function tryStatement(block, handler, finalizer) {
    return _builder.default.apply("TryStatement", arguments);
}
function unaryExpression(operator, argument, prefix) {
    return _builder.default.apply("UnaryExpression", arguments);
}
function updateExpression(operator, argument, prefix) {
    return _builder.default.apply("UpdateExpression", arguments);
}
function variableDeclaration(kind, declarations) {
    return _builder.default.apply("VariableDeclaration", arguments);
}
function variableDeclarator(id, init) {
    return _builder.default.apply("VariableDeclarator", arguments);
}
function whileStatement(test, body) {
    return _builder.default.apply("WhileStatement", arguments);
}
function withStatement(object, body) {
    return _builder.default.apply("WithStatement", arguments);
}
function assignmentPattern(left, right) {
    return _builder.default.apply("AssignmentPattern", arguments);
}
function arrayPattern(elements) {
    return _builder.default.apply("ArrayPattern", arguments);
}
function arrowFunctionExpression(params, body, async) {
    return _builder.default.apply("ArrowFunctionExpression", arguments);
}
function classBody(body) {
    return _builder.default.apply("ClassBody", arguments);
}
function classExpression(id, superClass, body, decorators) {
    return _builder.default.apply("ClassExpression", arguments);
}
function classDeclaration(id, superClass, body, decorators) {
    return _builder.default.apply("ClassDeclaration", arguments);
}
function exportAllDeclaration(source) {
    return _builder.default.apply("ExportAllDeclaration", arguments);
}
function exportDefaultDeclaration(declaration) {
    return _builder.default.apply("ExportDefaultDeclaration", arguments);
}
function exportNamedDeclaration(declaration, specifiers, source) {
    return _builder.default.apply("ExportNamedDeclaration", arguments);
}
function exportSpecifier(local, exported) {
    return _builder.default.apply("ExportSpecifier", arguments);
}
function forOfStatement(left, right, body, _await) {
    return _builder.default.apply("ForOfStatement", arguments);
}
function importDeclaration(specifiers, source) {
    return _builder.default.apply("ImportDeclaration", arguments);
}
function importDefaultSpecifier(local) {
    return _builder.default.apply("ImportDefaultSpecifier", arguments);
}
function importNamespaceSpecifier(local) {
    return _builder.default.apply("ImportNamespaceSpecifier", arguments);
}
function importSpecifier(local, imported) {
    return _builder.default.apply("ImportSpecifier", arguments);
}
function metaProperty(meta, property) {
    return _builder.default.apply("MetaProperty", arguments);
}
function classMethod(kind, key, params, body, computed, _static, generator, async) {
    return _builder.default.apply("ClassMethod", arguments);
}
function objectPattern(properties) {
    return _builder.default.apply("ObjectPattern", arguments);
}
function spreadElement(argument) {
    return _builder.default.apply("SpreadElement", arguments);
}
function _super() {
    return _builder.default.apply("Super", arguments);
}
function taggedTemplateExpression(tag, quasi) {
    return _builder.default.apply("TaggedTemplateExpression", arguments);
}
function templateElement(value, tail) {
    return _builder.default.apply("TemplateElement", arguments);
}
function templateLiteral(quasis, expressions) {
    return _builder.default.apply("TemplateLiteral", arguments);
}
function yieldExpression(argument, delegate) {
    return _builder.default.apply("YieldExpression", arguments);
}
function awaitExpression(argument) {
    return _builder.default.apply("AwaitExpression", arguments);
}
function _import() {
    return _builder.default.apply("Import", arguments);
}
function bigIntLiteral(value) {
    return _builder.default.apply("BigIntLiteral", arguments);
}
function exportNamespaceSpecifier(exported) {
    return _builder.default.apply("ExportNamespaceSpecifier", arguments);
}
function optionalMemberExpression(object, property, computed, optional) {
    return _builder.default.apply("OptionalMemberExpression", arguments);
}
function optionalCallExpression(callee, _arguments, optional) {
    return _builder.default.apply("OptionalCallExpression", arguments);
}
function classProperty(key, value, typeAnnotation, decorators, computed, _static) {
    return _builder.default.apply("ClassProperty", arguments);
}
function classPrivateProperty(key, value, decorators, _static) {
    return _builder.default.apply("ClassPrivateProperty", arguments);
}
function classPrivateMethod(kind, key, params, body, _static) {
    return _builder.default.apply("ClassPrivateMethod", arguments);
}
function privateName(id) {
    return _builder.default.apply("PrivateName", arguments);
}
function staticBlock(body) {
    return _builder.default.apply("StaticBlock", arguments);
}
function anyTypeAnnotation() {
    return _builder.default.apply("AnyTypeAnnotation", arguments);
}
function arrayTypeAnnotation(elementType) {
    return _builder.default.apply("ArrayTypeAnnotation", arguments);
}
function booleanTypeAnnotation() {
    return _builder.default.apply("BooleanTypeAnnotation", arguments);
}
function booleanLiteralTypeAnnotation(value) {
    return _builder.default.apply("BooleanLiteralTypeAnnotation", arguments);
}
function nullLiteralTypeAnnotation() {
    return _builder.default.apply("NullLiteralTypeAnnotation", arguments);
}
function classImplements(id, typeParameters) {
    return _builder.default.apply("ClassImplements", arguments);
}
function declareClass(id, typeParameters, _extends, body) {
    return _builder.default.apply("DeclareClass", arguments);
}
function declareFunction(id) {
    return _builder.default.apply("DeclareFunction", arguments);
}
function declareInterface(id, typeParameters, _extends, body) {
    return _builder.default.apply("DeclareInterface", arguments);
}
function declareModule(id, body, kind) {
    return _builder.default.apply("DeclareModule", arguments);
}
function declareModuleExports(typeAnnotation) {
    return _builder.default.apply("DeclareModuleExports", arguments);
}
function declareTypeAlias(id, typeParameters, right) {
    return _builder.default.apply("DeclareTypeAlias", arguments);
}
function declareOpaqueType(id, typeParameters, supertype) {
    return _builder.default.apply("DeclareOpaqueType", arguments);
}
function declareVariable(id) {
    return _builder.default.apply("DeclareVariable", arguments);
}
function declareExportDeclaration(declaration, specifiers, source) {
    return _builder.default.apply("DeclareExportDeclaration", arguments);
}
function declareExportAllDeclaration(source) {
    return _builder.default.apply("DeclareExportAllDeclaration", arguments);
}
function declaredPredicate(value) {
    return _builder.default.apply("DeclaredPredicate", arguments);
}
function existsTypeAnnotation() {
    return _builder.default.apply("ExistsTypeAnnotation", arguments);
}
function functionTypeAnnotation(typeParameters, params, rest, returnType) {
    return _builder.default.apply("FunctionTypeAnnotation", arguments);
}
function functionTypeParam(name, typeAnnotation) {
    return _builder.default.apply("FunctionTypeParam", arguments);
}
function genericTypeAnnotation(id, typeParameters) {
    return _builder.default.apply("GenericTypeAnnotation", arguments);
}
function inferredPredicate() {
    return _builder.default.apply("InferredPredicate", arguments);
}
function interfaceExtends(id, typeParameters) {
    return _builder.default.apply("InterfaceExtends", arguments);
}
function interfaceDeclaration(id, typeParameters, _extends, body) {
    return _builder.default.apply("InterfaceDeclaration", arguments);
}
function interfaceTypeAnnotation(_extends, body) {
    return _builder.default.apply("InterfaceTypeAnnotation", arguments);
}
function intersectionTypeAnnotation(types) {
    return _builder.default.apply("IntersectionTypeAnnotation", arguments);
}
function mixedTypeAnnotation() {
    return _builder.default.apply("MixedTypeAnnotation", arguments);
}
function emptyTypeAnnotation() {
    return _builder.default.apply("EmptyTypeAnnotation", arguments);
}
function nullableTypeAnnotation(typeAnnotation) {
    return _builder.default.apply("NullableTypeAnnotation", arguments);
}
function numberLiteralTypeAnnotation(value) {
    return _builder.default.apply("NumberLiteralTypeAnnotation", arguments);
}
function numberTypeAnnotation() {
    return _builder.default.apply("NumberTypeAnnotation", arguments);
}
function objectTypeAnnotation(properties, indexers, callProperties, internalSlots, exact) {
    return _builder.default.apply("ObjectTypeAnnotation", arguments);
}
function objectTypeInternalSlot(id, value, optional, _static, method) {
    return _builder.default.apply("ObjectTypeInternalSlot", arguments);
}
function objectTypeCallProperty(value) {
    return _builder.default.apply("ObjectTypeCallProperty", arguments);
}
function objectTypeIndexer(id, key, value, variance) {
    return _builder.default.apply("ObjectTypeIndexer", arguments);
}
function objectTypeProperty(key, value, variance) {
    return _builder.default.apply("ObjectTypeProperty", arguments);
}
function objectTypeSpreadProperty(argument) {
    return _builder.default.apply("ObjectTypeSpreadProperty", arguments);
}
function opaqueType(id, typeParameters, supertype, impltype) {
    return _builder.default.apply("OpaqueType", arguments);
}
function qualifiedTypeIdentifier(id, qualification) {
    return _builder.default.apply("QualifiedTypeIdentifier", arguments);
}
function stringLiteralTypeAnnotation(value) {
    return _builder.default.apply("StringLiteralTypeAnnotation", arguments);
}
function stringTypeAnnotation() {
    return _builder.default.apply("StringTypeAnnotation", arguments);
}
function symbolTypeAnnotation() {
    return _builder.default.apply("SymbolTypeAnnotation", arguments);
}
function thisTypeAnnotation() {
    return _builder.default.apply("ThisTypeAnnotation", arguments);
}
function tupleTypeAnnotation(types) {
    return _builder.default.apply("TupleTypeAnnotation", arguments);
}
function typeofTypeAnnotation(argument) {
    return _builder.default.apply("TypeofTypeAnnotation", arguments);
}
function typeAlias(id, typeParameters, right) {
    return _builder.default.apply("TypeAlias", arguments);
}
function typeAnnotation(typeAnnotation) {
    return _builder.default.apply("TypeAnnotation", arguments);
}
function typeCastExpression(expression, typeAnnotation) {
    return _builder.default.apply("TypeCastExpression", arguments);
}
function typeParameter(bound, _default, variance) {
    return _builder.default.apply("TypeParameter", arguments);
}
function typeParameterDeclaration(params) {
    return _builder.default.apply("TypeParameterDeclaration", arguments);
}
function typeParameterInstantiation(params) {
    return _builder.default.apply("TypeParameterInstantiation", arguments);
}
function unionTypeAnnotation(types) {
    return _builder.default.apply("UnionTypeAnnotation", arguments);
}
function variance(kind) {
    return _builder.default.apply("Variance", arguments);
}
function voidTypeAnnotation() {
    return _builder.default.apply("VoidTypeAnnotation", arguments);
}
function enumDeclaration(id, body) {
    return _builder.default.apply("EnumDeclaration", arguments);
}
function enumBooleanBody(members) {
    return _builder.default.apply("EnumBooleanBody", arguments);
}
function enumNumberBody(members) {
    return _builder.default.apply("EnumNumberBody", arguments);
}
function enumStringBody(members) {
    return _builder.default.apply("EnumStringBody", arguments);
}
function enumSymbolBody(members) {
    return _builder.default.apply("EnumSymbolBody", arguments);
}
function enumBooleanMember(id) {
    return _builder.default.apply("EnumBooleanMember", arguments);
}
function enumNumberMember(id, init) {
    return _builder.default.apply("EnumNumberMember", arguments);
}
function enumStringMember(id, init) {
    return _builder.default.apply("EnumStringMember", arguments);
}
function enumDefaultedMember(id) {
    return _builder.default.apply("EnumDefaultedMember", arguments);
}
function indexedAccessType(objectType, indexType) {
    return _builder.default.apply("IndexedAccessType", arguments);
}
function optionalIndexedAccessType(objectType, indexType) {
    return _builder.default.apply("OptionalIndexedAccessType", arguments);
}
function jsxAttribute(name, value) {
    return _builder.default.apply("JSXAttribute", arguments);
}
function jsxClosingElement(name) {
    return _builder.default.apply("JSXClosingElement", arguments);
}
function jsxElement(openingElement, closingElement, children, selfClosing) {
    return _builder.default.apply("JSXElement", arguments);
}
function jsxEmptyExpression() {
    return _builder.default.apply("JSXEmptyExpression", arguments);
}
function jsxExpressionContainer(expression) {
    return _builder.default.apply("JSXExpressionContainer", arguments);
}
function jsxSpreadChild(expression) {
    return _builder.default.apply("JSXSpreadChild", arguments);
}
function jsxIdentifier(name) {
    return _builder.default.apply("JSXIdentifier", arguments);
}
function jsxMemberExpression(object, property) {
    return _builder.default.apply("JSXMemberExpression", arguments);
}
function jsxNamespacedName(namespace, name) {
    return _builder.default.apply("JSXNamespacedName", arguments);
}
function jsxOpeningElement(name, attributes, selfClosing) {
    return _builder.default.apply("JSXOpeningElement", arguments);
}
function jsxSpreadAttribute(argument) {
    return _builder.default.apply("JSXSpreadAttribute", arguments);
}
function jsxText(value) {
    return _builder.default.apply("JSXText", arguments);
}
function jsxFragment(openingFragment, closingFragment, children) {
    return _builder.default.apply("JSXFragment", arguments);
}
function jsxOpeningFragment() {
    return _builder.default.apply("JSXOpeningFragment", arguments);
}
function jsxClosingFragment() {
    return _builder.default.apply("JSXClosingFragment", arguments);
}
function noop() {
    return _builder.default.apply("Noop", arguments);
}
function placeholder(expectedNode, name) {
    return _builder.default.apply("Placeholder", arguments);
}
function v8IntrinsicIdentifier(name) {
    return _builder.default.apply("V8IntrinsicIdentifier", arguments);
}
function argumentPlaceholder() {
    return _builder.default.apply("ArgumentPlaceholder", arguments);
}
function bindExpression(object, callee) {
    return _builder.default.apply("BindExpression", arguments);
}
function importAttribute(key, value) {
    return _builder.default.apply("ImportAttribute", arguments);
}
function decorator(expression) {
    return _builder.default.apply("Decorator", arguments);
}
function doExpression(body, async) {
    return _builder.default.apply("DoExpression", arguments);
}
function exportDefaultSpecifier(exported) {
    return _builder.default.apply("ExportDefaultSpecifier", arguments);
}
function recordExpression(properties) {
    return _builder.default.apply("RecordExpression", arguments);
}
function tupleExpression(elements) {
    return _builder.default.apply("TupleExpression", arguments);
}
function decimalLiteral(value) {
    return _builder.default.apply("DecimalLiteral", arguments);
}
function moduleExpression(body) {
    return _builder.default.apply("ModuleExpression", arguments);
}
function topicReference() {
    return _builder.default.apply("TopicReference", arguments);
}
function pipelineTopicExpression(expression) {
    return _builder.default.apply("PipelineTopicExpression", arguments);
}
function pipelineBareFunction(callee) {
    return _builder.default.apply("PipelineBareFunction", arguments);
}
function pipelinePrimaryTopicReference() {
    return _builder.default.apply("PipelinePrimaryTopicReference", arguments);
}
function tsParameterProperty(parameter) {
    return _builder.default.apply("TSParameterProperty", arguments);
}
function tsDeclareFunction(id, typeParameters, params, returnType) {
    return _builder.default.apply("TSDeclareFunction", arguments);
}
function tsDeclareMethod(decorators, key, typeParameters, params, returnType) {
    return _builder.default.apply("TSDeclareMethod", arguments);
}
function tsQualifiedName(left, right) {
    return _builder.default.apply("TSQualifiedName", arguments);
}
function tsCallSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
    return _builder.default.apply("TSCallSignatureDeclaration", arguments);
}
function tsConstructSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
    return _builder.default.apply("TSConstructSignatureDeclaration", arguments);
}
function tsPropertySignature(key, typeAnnotation, initializer) {
    return _builder.default.apply("TSPropertySignature", arguments);
}
function tsMethodSignature(key, typeParameters, parameters, typeAnnotation) {
    return _builder.default.apply("TSMethodSignature", arguments);
}
function tsIndexSignature(parameters, typeAnnotation) {
    return _builder.default.apply("TSIndexSignature", arguments);
}
function tsAnyKeyword() {
    return _builder.default.apply("TSAnyKeyword", arguments);
}
function tsBooleanKeyword() {
    return _builder.default.apply("TSBooleanKeyword", arguments);
}
function tsBigIntKeyword() {
    return _builder.default.apply("TSBigIntKeyword", arguments);
}
function tsIntrinsicKeyword() {
    return _builder.default.apply("TSIntrinsicKeyword", arguments);
}
function tsNeverKeyword() {
    return _builder.default.apply("TSNeverKeyword", arguments);
}
function tsNullKeyword() {
    return _builder.default.apply("TSNullKeyword", arguments);
}
function tsNumberKeyword() {
    return _builder.default.apply("TSNumberKeyword", arguments);
}
function tsObjectKeyword() {
    return _builder.default.apply("TSObjectKeyword", arguments);
}
function tsStringKeyword() {
    return _builder.default.apply("TSStringKeyword", arguments);
}
function tsSymbolKeyword() {
    return _builder.default.apply("TSSymbolKeyword", arguments);
}
function tsUndefinedKeyword() {
    return _builder.default.apply("TSUndefinedKeyword", arguments);
}
function tsUnknownKeyword() {
    return _builder.default.apply("TSUnknownKeyword", arguments);
}
function tsVoidKeyword() {
    return _builder.default.apply("TSVoidKeyword", arguments);
}
function tsThisType() {
    return _builder.default.apply("TSThisType", arguments);
}
function tsFunctionType(typeParameters, parameters, typeAnnotation) {
    return _builder.default.apply("TSFunctionType", arguments);
}
function tsConstructorType(typeParameters, parameters, typeAnnotation) {
    return _builder.default.apply("TSConstructorType", arguments);
}
function tsTypeReference(typeName, typeParameters) {
    return _builder.default.apply("TSTypeReference", arguments);
}
function tsTypePredicate(parameterName, typeAnnotation, asserts) {
    return _builder.default.apply("TSTypePredicate", arguments);
}
function tsTypeQuery(exprName) {
    return _builder.default.apply("TSTypeQuery", arguments);
}
function tsTypeLiteral(members) {
    return _builder.default.apply("TSTypeLiteral", arguments);
}
function tsArrayType(elementType) {
    return _builder.default.apply("TSArrayType", arguments);
}
function tsTupleType(elementTypes) {
    return _builder.default.apply("TSTupleType", arguments);
}
function tsOptionalType(typeAnnotation) {
    return _builder.default.apply("TSOptionalType", arguments);
}
function tsRestType(typeAnnotation) {
    return _builder.default.apply("TSRestType", arguments);
}
function tsNamedTupleMember(label, elementType, optional) {
    return _builder.default.apply("TSNamedTupleMember", arguments);
}
function tsUnionType(types) {
    return _builder.default.apply("TSUnionType", arguments);
}
function tsIntersectionType(types) {
    return _builder.default.apply("TSIntersectionType", arguments);
}
function tsConditionalType(checkType, extendsType, trueType, falseType) {
    return _builder.default.apply("TSConditionalType", arguments);
}
function tsInferType(typeParameter) {
    return _builder.default.apply("TSInferType", arguments);
}
function tsParenthesizedType(typeAnnotation) {
    return _builder.default.apply("TSParenthesizedType", arguments);
}
function tsTypeOperator(typeAnnotation) {
    return _builder.default.apply("TSTypeOperator", arguments);
}
function tsIndexedAccessType(objectType, indexType) {
    return _builder.default.apply("TSIndexedAccessType", arguments);
}
function tsMappedType(typeParameter, typeAnnotation, nameType) {
    return _builder.default.apply("TSMappedType", arguments);
}
function tsLiteralType(literal) {
    return _builder.default.apply("TSLiteralType", arguments);
}
function tsExpressionWithTypeArguments(expression, typeParameters) {
    return _builder.default.apply("TSExpressionWithTypeArguments", arguments);
}
function tsInterfaceDeclaration(id, typeParameters, _extends, body) {
    return _builder.default.apply("TSInterfaceDeclaration", arguments);
}
function tsInterfaceBody(body) {
    return _builder.default.apply("TSInterfaceBody", arguments);
}
function tsTypeAliasDeclaration(id, typeParameters, typeAnnotation) {
    return _builder.default.apply("TSTypeAliasDeclaration", arguments);
}
function tsAsExpression(expression, typeAnnotation) {
    return _builder.default.apply("TSAsExpression", arguments);
}
function tsTypeAssertion(typeAnnotation, expression) {
    return _builder.default.apply("TSTypeAssertion", arguments);
}
function tsEnumDeclaration(id, members) {
    return _builder.default.apply("TSEnumDeclaration", arguments);
}
function tsEnumMember(id, initializer) {
    return _builder.default.apply("TSEnumMember", arguments);
}
function tsModuleDeclaration(id, body) {
    return _builder.default.apply("TSModuleDeclaration", arguments);
}
function tsModuleBlock(body) {
    return _builder.default.apply("TSModuleBlock", arguments);
}
function tsImportType(argument, qualifier, typeParameters) {
    return _builder.default.apply("TSImportType", arguments);
}
function tsImportEqualsDeclaration(id, moduleReference) {
    return _builder.default.apply("TSImportEqualsDeclaration", arguments);
}
function tsExternalModuleReference(expression) {
    return _builder.default.apply("TSExternalModuleReference", arguments);
}
function tsNonNullExpression(expression) {
    return _builder.default.apply("TSNonNullExpression", arguments);
}
function tsExportAssignment(expression) {
    return _builder.default.apply("TSExportAssignment", arguments);
}
function tsNamespaceExportDeclaration(id) {
    return _builder.default.apply("TSNamespaceExportDeclaration", arguments);
}
function tsTypeAnnotation(typeAnnotation) {
    return _builder.default.apply("TSTypeAnnotation", arguments);
}
function tsTypeParameterInstantiation(params) {
    return _builder.default.apply("TSTypeParameterInstantiation", arguments);
}
function tsTypeParameterDeclaration(params) {
    return _builder.default.apply("TSTypeParameterDeclaration", arguments);
}
function tsTypeParameter(constraint, _default, name) {
    return _builder.default.apply("TSTypeParameter", arguments);
}
function NumberLiteral(value) {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
    return _builder.default.apply("NumberLiteral", arguments);
}
function RegexLiteral(pattern, flags) {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
    return _builder.default.apply("RegexLiteral", arguments);
}
function RestProperty(argument) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    return _builder.default.apply("RestProperty", arguments);
}
function SpreadProperty(argument) {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");
    return _builder.default.apply("SpreadProperty", arguments);
}

},{"../builder":"4WjRS"}],"4WjRS":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = builder;
var _definitions = require("../definitions");
var _validate = require("../validators/validate");
function builder() {
    const type = this;
    const keys = _definitions.BUILDER_KEYS[type];
    const countArgs = arguments.length;
    if (countArgs > keys.length) throw new Error(`${type}: Too many arguments passed. Received ${countArgs} but can receive no more than ${keys.length}`);
    const node = {
        type
    };
    for(let i = 0; i < keys.length; ++i){
        const key = keys[i];
        const field = _definitions.NODE_FIELDS[type][key];
        let arg;
        if (i < countArgs) arg = arguments[i];
        if (arg === undefined) arg = Array.isArray(field.default) ? [] : field.default;
        node[key] = arg;
    }
    for(const key in node)(0, _validate.default)(node, key, node[key]);
    return node;
}

},{"../definitions":"lTnnW","../validators/validate":"dAbSc"}],"lTnnW":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ALIAS_KEYS", {
    enumerable: true,
    get: function() {
        return _utils.ALIAS_KEYS;
    }
});
Object.defineProperty(exports, "BUILDER_KEYS", {
    enumerable: true,
    get: function() {
        return _utils.BUILDER_KEYS;
    }
});
Object.defineProperty(exports, "DEPRECATED_KEYS", {
    enumerable: true,
    get: function() {
        return _utils.DEPRECATED_KEYS;
    }
});
Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
    enumerable: true,
    get: function() {
        return _utils.FLIPPED_ALIAS_KEYS;
    }
});
Object.defineProperty(exports, "NODE_FIELDS", {
    enumerable: true,
    get: function() {
        return _utils.NODE_FIELDS;
    }
});
Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
    enumerable: true,
    get: function() {
        return _utils.NODE_PARENT_VALIDATIONS;
    }
});
Object.defineProperty(exports, "PLACEHOLDERS", {
    enumerable: true,
    get: function() {
        return _placeholders.PLACEHOLDERS;
    }
});
Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
    enumerable: true,
    get: function() {
        return _placeholders.PLACEHOLDERS_ALIAS;
    }
});
Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: true,
    get: function() {
        return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
    }
});
exports.TYPES = void 0;
Object.defineProperty(exports, "VISITOR_KEYS", {
    enumerable: true,
    get: function() {
        return _utils.VISITOR_KEYS;
    }
});
var _toFastProperties = require("to-fast-properties");
require("./core");
require("./flow");
require("./jsx");
require("./misc");
require("./experimental");
require("./typescript");
var _utils = require("./utils");
var _placeholders = require("./placeholders");
_toFastProperties(_utils.VISITOR_KEYS);
_toFastProperties(_utils.ALIAS_KEYS);
_toFastProperties(_utils.FLIPPED_ALIAS_KEYS);
_toFastProperties(_utils.NODE_FIELDS);
_toFastProperties(_utils.BUILDER_KEYS);
_toFastProperties(_utils.DEPRECATED_KEYS);
_toFastProperties(_placeholders.PLACEHOLDERS_ALIAS);
_toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
const TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
exports.TYPES = TYPES;

},{"to-fast-properties":"60Xij","./core":"dxYBh","./flow":"2Ewm7","./jsx":"erJRU","./misc":"lA04r","./experimental":"dJ9kT","./typescript":"loVZW","./utils":"euwIL","./placeholders":"bQquQ"}],"dxYBh":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;
var _is = require("../validators/is");
var _isValidIdentifier = require("../validators/isValidIdentifier");
var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");
var _constants = require("../constants");
var _utils = require("./utils");
const defineType = (0, _utils.defineAliasedType)("Standardized");
defineType("ArrayExpression", {
    fields: {
        elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
            default: []
        }
    },
    visitor: [
        "elements"
    ],
    aliases: [
        "Expression"
    ]
});
defineType("AssignmentExpression", {
    fields: {
        operator: {
            validate: function() {
                var node, key, val;
                return (0, _utils.assertValueType)("string");
            }()
        },
        left: {
            validate: (0, _utils.assertNodeType)("LVal")
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    builder: [
        "operator",
        "left",
        "right"
    ],
    visitor: [
        "left",
        "right"
    ],
    aliases: [
        "Expression"
    ]
});
defineType("BinaryExpression", {
    builder: [
        "operator",
        "left",
        "right"
    ],
    fields: {
        operator: {
            validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)
        },
        left: {
            validate: function() {
                const expression = (0, _utils.assertNodeType)("Expression");
                const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
                const validator1 = function(node, key, val) {
                    const validator = node.operator === "in" ? inOp : expression;
                    validator(node, key, val);
                };
                validator1.oneOfNodeTypes = [
                    "Expression",
                    "PrivateName"
                ];
                return validator1;
            }()
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    visitor: [
        "left",
        "right"
    ],
    aliases: [
        "Binary",
        "Expression"
    ]
});
defineType("InterpreterDirective", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    }
});
defineType("Directive", {
    visitor: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertNodeType)("DirectiveLiteral")
        }
    }
});
defineType("DirectiveLiteral", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    }
});
defineType("BlockStatement", {
    builder: [
        "body",
        "directives"
    ],
    visitor: [
        "directives",
        "body"
    ],
    fields: {
        directives: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
            default: []
        },
        body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
    },
    aliases: [
        "Scopable",
        "BlockParent",
        "Block",
        "Statement"
    ]
});
defineType("BreakStatement", {
    visitor: [
        "label"
    ],
    fields: {
        label: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
        }
    },
    aliases: [
        "Statement",
        "Terminatorless",
        "CompletionStatement"
    ]
});
defineType("CallExpression", {
    visitor: [
        "callee",
        "arguments",
        "typeParameters",
        "typeArguments"
    ],
    builder: [
        "callee",
        "arguments"
    ],
    aliases: [
        "Expression"
    ],
    fields: Object.assign({
        callee: {
            validate: (0, _utils.assertNodeType)("Expression", "V8IntrinsicIdentifier")
        },
        arguments: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        }
    }, {
        optional: {
            validate: (0, _utils.assertOneOf)(true, false),
            optional: true
        }
    }, {
        typeArguments: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
            optional: true
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
            optional: true
        }
    })
});
defineType("CatchClause", {
    visitor: [
        "param",
        "body"
    ],
    fields: {
        param: {
            validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    },
    aliases: [
        "Scopable",
        "BlockParent"
    ]
});
defineType("ConditionalExpression", {
    visitor: [
        "test",
        "consequent",
        "alternate"
    ],
    fields: {
        test: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        alternate: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    aliases: [
        "Expression",
        "Conditional"
    ]
});
defineType("ContinueStatement", {
    visitor: [
        "label"
    ],
    fields: {
        label: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
        }
    },
    aliases: [
        "Statement",
        "Terminatorless",
        "CompletionStatement"
    ]
});
defineType("DebuggerStatement", {
    aliases: [
        "Statement"
    ]
});
defineType("DoWhileStatement", {
    visitor: [
        "test",
        "body"
    ],
    fields: {
        test: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    },
    aliases: [
        "Statement",
        "BlockParent",
        "Loop",
        "While",
        "Scopable"
    ]
});
defineType("EmptyStatement", {
    aliases: [
        "Statement"
    ]
});
defineType("ExpressionStatement", {
    visitor: [
        "expression"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    aliases: [
        "Statement",
        "ExpressionWrapper"
    ]
});
defineType("File", {
    builder: [
        "program",
        "comments",
        "tokens"
    ],
    visitor: [
        "program"
    ],
    fields: {
        program: {
            validate: (0, _utils.assertNodeType)("Program")
        },
        comments: {
            validate: Object.assign(()=>{}, {
                each: {
                    oneOfNodeTypes: [
                        "CommentBlock",
                        "CommentLine"
                    ]
                }
            }),
            optional: true
        },
        tokens: {
            validate: (0, _utils.assertEach)(Object.assign(()=>{}, {
                type: "any"
            })),
            optional: true
        }
    }
});
defineType("ForInStatement", {
    visitor: [
        "left",
        "right",
        "body"
    ],
    aliases: [
        "Scopable",
        "Statement",
        "For",
        "BlockParent",
        "Loop",
        "ForXStatement"
    ],
    fields: {
        left: {
            validate: (0, _utils.assertNodeType)("VariableDeclaration", "LVal")
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
defineType("ForStatement", {
    visitor: [
        "init",
        "test",
        "update",
        "body"
    ],
    aliases: [
        "Scopable",
        "Statement",
        "For",
        "BlockParent",
        "Loop"
    ],
    fields: {
        init: {
            validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
            optional: true
        },
        test: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        update: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
const functionCommon = {
    params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement")))
    },
    generator: {
        default: false
    },
    async: {
        default: false
    }
};
exports.functionCommon = functionCommon;
const functionTypeAnnotationCommon = {
    returnType: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
    },
    typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
    }
};
exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
const functionDeclarationCommon = Object.assign({}, functionCommon, {
    declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
    },
    id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
    }
});
exports.functionDeclarationCommon = functionDeclarationCommon;
defineType("FunctionDeclaration", {
    builder: [
        "id",
        "params",
        "body",
        "generator",
        "async"
    ],
    visitor: [
        "id",
        "params",
        "body",
        "returnType",
        "typeParameters"
    ],
    fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    }),
    aliases: [
        "Scopable",
        "Function",
        "BlockParent",
        "FunctionParent",
        "Statement",
        "Pureish",
        "Declaration"
    ],
    validate: function() {
        var parent, key, node;
        return ()=>{};
    }()
});
defineType("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: [
        "Scopable",
        "Function",
        "BlockParent",
        "FunctionParent",
        "Expression",
        "Pureish"
    ],
    fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
        id: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    })
});
const patternLikeCommon = {
    typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
    },
    decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
    }
};
exports.patternLikeCommon = patternLikeCommon;
defineType("Identifier", {
    builder: [
        "name"
    ],
    visitor: [
        "typeAnnotation",
        "decorators"
    ],
    aliases: [
        "Expression",
        "PatternLike",
        "LVal",
        "TSEntityName"
    ],
    fields: Object.assign({}, patternLikeCommon, {
        name: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
                return;
            }, {
                type: "string"
            }))
        },
        optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        }
    }),
    validate (parent, key, node) {
        return;
    }
});
defineType("IfStatement", {
    visitor: [
        "test",
        "consequent",
        "alternate"
    ],
    aliases: [
        "Statement",
        "Conditional"
    ],
    fields: {
        test: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
            validate: (0, _utils.assertNodeType)("Statement")
        },
        alternate: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
defineType("LabeledStatement", {
    visitor: [
        "label",
        "body"
    ],
    aliases: [
        "Statement"
    ],
    fields: {
        label: {
            validate: (0, _utils.assertNodeType)("Identifier")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
defineType("StringLiteral", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    },
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
defineType("NumericLiteral", {
    builder: [
        "value"
    ],
    deprecatedAlias: "NumberLiteral",
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("number")
        }
    },
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
defineType("NullLiteral", {
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
defineType("BooleanLiteral", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("boolean")
        }
    },
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
defineType("RegExpLiteral", {
    builder: [
        "pattern",
        "flags"
    ],
    deprecatedAlias: "RegexLiteral",
    aliases: [
        "Expression",
        "Pureish",
        "Literal"
    ],
    fields: {
        pattern: {
            validate: (0, _utils.assertValueType)("string")
        },
        flags: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
                return;
            }, {
                type: "string"
            })),
            default: ""
        }
    }
});
defineType("LogicalExpression", {
    builder: [
        "operator",
        "left",
        "right"
    ],
    visitor: [
        "left",
        "right"
    ],
    aliases: [
        "Binary",
        "Expression"
    ],
    fields: {
        operator: {
            validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)
        },
        left: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("MemberExpression", {
    builder: [
        "object",
        "property",
        "computed",
        "optional"
    ],
    visitor: [
        "object",
        "property"
    ],
    aliases: [
        "Expression",
        "LVal"
    ],
    fields: Object.assign({
        object: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        property: {
            validate: function() {
                const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
                const computed = (0, _utils.assertNodeType)("Expression");
                const validator2 = function(node, key, val) {
                    const validator = node.computed ? computed : normal;
                    validator(node, key, val);
                };
                validator2.oneOfNodeTypes = [
                    "Expression",
                    "Identifier",
                    "PrivateName"
                ];
                return validator2;
            }()
        },
        computed: {
            default: false
        }
    }, {
        optional: {
            validate: (0, _utils.assertOneOf)(true, false),
            optional: true
        }
    })
});
defineType("NewExpression", {
    inherits: "CallExpression"
});
defineType("Program", {
    visitor: [
        "directives",
        "body"
    ],
    builder: [
        "body",
        "directives",
        "sourceType",
        "interpreter"
    ],
    fields: {
        sourceFile: {
            validate: (0, _utils.assertValueType)("string")
        },
        sourceType: {
            validate: (0, _utils.assertOneOf)("script", "module"),
            default: "script"
        },
        interpreter: {
            validate: (0, _utils.assertNodeType)("InterpreterDirective"),
            default: null,
            optional: true
        },
        directives: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
            default: []
        },
        body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
    },
    aliases: [
        "Scopable",
        "BlockParent",
        "Block"
    ]
});
defineType("ObjectExpression", {
    visitor: [
        "properties"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
        }
    }
});
defineType("ObjectMethod", {
    builder: [
        "kind",
        "key",
        "params",
        "body",
        "computed",
        "generator",
        "async"
    ],
    fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
        kind: Object.assign({
            validate: (0, _utils.assertOneOf)("method", "get", "set")
        }, {
            default: "method"
        }),
        computed: {
            default: false
        },
        key: {
            validate: function() {
                const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
                const computed = (0, _utils.assertNodeType)("Expression");
                const validator3 = function(node, key, val) {
                    const validator = node.computed ? computed : normal;
                    validator(node, key, val);
                };
                validator3.oneOfNodeTypes = [
                    "Expression",
                    "Identifier",
                    "StringLiteral",
                    "NumericLiteral"
                ];
                return validator3;
            }()
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    }),
    visitor: [
        "key",
        "params",
        "body",
        "decorators",
        "returnType",
        "typeParameters"
    ],
    aliases: [
        "UserWhitespacable",
        "Function",
        "Scopable",
        "BlockParent",
        "FunctionParent",
        "Method",
        "ObjectMember"
    ]
});
defineType("ObjectProperty", {
    builder: [
        "key",
        "value",
        "computed",
        "shorthand",
        "decorators"
    ],
    fields: {
        computed: {
            default: false
        },
        key: {
            validate: function() {
                const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
                const computed = (0, _utils.assertNodeType)("Expression");
                const validator4 = function(node, key, val) {
                    const validator = node.computed ? computed : normal;
                    validator(node, key, val);
                };
                validator4.oneOfNodeTypes = [
                    "Expression",
                    "Identifier",
                    "StringLiteral",
                    "NumericLiteral"
                ];
                return validator4;
            }()
        },
        value: {
            validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
        },
        shorthand: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
                return;
            }, {
                type: "boolean"
            }), function(node, key, val) {
                return;
            }),
            default: false
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        }
    },
    visitor: [
        "key",
        "value",
        "decorators"
    ],
    aliases: [
        "UserWhitespacable",
        "Property",
        "ObjectMember"
    ],
    validate: function() {
        const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern");
        const expression = (0, _utils.assertNodeType)("Expression");
        return function(parent, key, node) {
            return;
        };
    }()
});
defineType("RestElement", {
    visitor: [
        "argument",
        "typeAnnotation"
    ],
    builder: [
        "argument"
    ],
    aliases: [
        "LVal",
        "PatternLike"
    ],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, patternLikeCommon, {
        argument: {
            validate: (0, _utils.assertNodeType)("LVal")
        },
        optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        }
    }),
    validate (parent, key) {
        return;
    }
});
defineType("ReturnStatement", {
    visitor: [
        "argument"
    ],
    aliases: [
        "Statement",
        "Terminatorless",
        "CompletionStatement"
    ],
    fields: {
        argument: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        }
    }
});
defineType("SequenceExpression", {
    visitor: [
        "expressions"
    ],
    fields: {
        expressions: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
        }
    },
    aliases: [
        "Expression"
    ]
});
defineType("ParenthesizedExpression", {
    visitor: [
        "expression"
    ],
    aliases: [
        "Expression",
        "ExpressionWrapper"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("SwitchCase", {
    visitor: [
        "test",
        "consequent"
    ],
    fields: {
        test: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        consequent: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
    }
});
defineType("SwitchStatement", {
    visitor: [
        "discriminant",
        "cases"
    ],
    aliases: [
        "Statement",
        "BlockParent",
        "Scopable"
    ],
    fields: {
        discriminant: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        cases: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
        }
    }
});
defineType("ThisExpression", {
    aliases: [
        "Expression"
    ]
});
defineType("ThrowStatement", {
    visitor: [
        "argument"
    ],
    aliases: [
        "Statement",
        "Terminatorless",
        "CompletionStatement"
    ],
    fields: {
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("TryStatement", {
    visitor: [
        "block",
        "handler",
        "finalizer"
    ],
    aliases: [
        "Statement"
    ],
    fields: {
        block: {
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node) {
                return;
            }, {
                oneOfNodeTypes: [
                    "BlockStatement"
                ]
            }))
        },
        handler: {
            optional: true,
            validate: (0, _utils.assertNodeType)("CatchClause")
        },
        finalizer: {
            optional: true,
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    }
});
defineType("UnaryExpression", {
    builder: [
        "operator",
        "argument",
        "prefix"
    ],
    fields: {
        prefix: {
            default: true
        },
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        operator: {
            validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)
        }
    },
    visitor: [
        "argument"
    ],
    aliases: [
        "UnaryLike",
        "Expression"
    ]
});
defineType("UpdateExpression", {
    builder: [
        "operator",
        "argument",
        "prefix"
    ],
    fields: {
        prefix: {
            default: false
        },
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        operator: {
            validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)
        }
    },
    visitor: [
        "argument"
    ],
    aliases: [
        "Expression"
    ]
});
defineType("VariableDeclaration", {
    builder: [
        "kind",
        "declarations"
    ],
    visitor: [
        "declarations"
    ],
    aliases: [
        "Statement",
        "Declaration"
    ],
    fields: {
        declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        kind: {
            validate: (0, _utils.assertOneOf)("var", "let", "const")
        },
        declarations: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
        }
    },
    validate (parent, key, node) {
        return;
    }
});
defineType("VariableDeclarator", {
    visitor: [
        "id",
        "init"
    ],
    fields: {
        id: {
            validate: function() {
                var node, key, val;
                return (0, _utils.assertNodeType)("LVal");
            }()
        },
        definite: {
            optional: true,
            validate: (0, _utils.assertValueType)("boolean")
        },
        init: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("WhileStatement", {
    visitor: [
        "test",
        "body"
    ],
    aliases: [
        "Statement",
        "BlockParent",
        "Loop",
        "While",
        "Scopable"
    ],
    fields: {
        test: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
defineType("WithStatement", {
    visitor: [
        "object",
        "body"
    ],
    aliases: [
        "Statement"
    ],
    fields: {
        object: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        }
    }
});
defineType("AssignmentPattern", {
    visitor: [
        "left",
        "right",
        "decorators"
    ],
    builder: [
        "left",
        "right"
    ],
    aliases: [
        "Pattern",
        "PatternLike",
        "LVal"
    ],
    fields: Object.assign({}, patternLikeCommon, {
        left: {
            validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression")
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        }
    })
});
defineType("ArrayPattern", {
    visitor: [
        "elements",
        "typeAnnotation"
    ],
    builder: [
        "elements"
    ],
    aliases: [
        "Pattern",
        "PatternLike",
        "LVal"
    ],
    fields: Object.assign({}, patternLikeCommon, {
        elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike")))
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        }
    })
});
defineType("ArrowFunctionExpression", {
    builder: [
        "params",
        "body",
        "async"
    ],
    visitor: [
        "params",
        "body",
        "returnType",
        "typeParameters"
    ],
    aliases: [
        "Scopable",
        "Function",
        "BlockParent",
        "FunctionParent",
        "Expression",
        "Pureish"
    ],
    fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
        expression: {
            validate: (0, _utils.assertValueType)("boolean")
        },
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
        }
    })
});
defineType("ClassBody", {
    visitor: [
        "body"
    ],
    fields: {
        body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))
        }
    }
});
defineType("ClassExpression", {
    builder: [
        "id",
        "superClass",
        "body",
        "decorators"
    ],
    visitor: [
        "id",
        "body",
        "superClass",
        "mixins",
        "typeParameters",
        "superTypeParameters",
        "implements",
        "decorators"
    ],
    aliases: [
        "Scopable",
        "Class",
        "Expression"
    ],
    fields: {
        id: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: true
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
        },
        superTypeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
        },
        implements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        mixins: {
            validate: (0, _utils.assertNodeType)("InterfaceExtends"),
            optional: true
        }
    }
});
defineType("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: [
        "Scopable",
        "Class",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: {
            validate: (0, _utils.assertNodeType)("Identifier")
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
            optional: true
        },
        body: {
            validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
        },
        superTypeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
        },
        implements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        mixins: {
            validate: (0, _utils.assertNodeType)("InterfaceExtends"),
            optional: true
        },
        declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        abstract: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        }
    },
    validate: function() {
        const identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node) {
            return;
        };
    }()
});
defineType("ExportAllDeclaration", {
    visitor: [
        "source"
    ],
    aliases: [
        "Statement",
        "Declaration",
        "ModuleDeclaration",
        "ExportDeclaration"
    ],
    fields: {
        source: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")),
        assertions: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        }
    }
});
defineType("ExportDefaultDeclaration", {
    visitor: [
        "declaration"
    ],
    aliases: [
        "Statement",
        "Declaration",
        "ModuleDeclaration",
        "ExportDeclaration"
    ],
    fields: {
        declaration: {
            validate: (0, _utils.assertNodeType)("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
    }
});
defineType("ExportNamedDeclaration", {
    visitor: [
        "declaration",
        "specifiers",
        "source"
    ],
    aliases: [
        "Statement",
        "Declaration",
        "ModuleDeclaration",
        "ExportDeclaration"
    ],
    fields: {
        declaration: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node, key, val) {
                return;
            }, {
                oneOfNodeTypes: [
                    "Declaration"
                ]
            }), function(node, key, val) {
                return;
            })
        },
        assertions: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        specifiers: {
            default: [],
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function() {
                const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
                const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
                var node, key, val;
                return sourced;
            }()))
        },
        source: {
            validate: (0, _utils.assertNodeType)("StringLiteral"),
            optional: true
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }
});
defineType("ExportSpecifier", {
    visitor: [
        "local",
        "exported"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        local: {
            validate: (0, _utils.assertNodeType)("Identifier")
        },
        exported: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        exportKind: {
            validate: (0, _utils.assertOneOf)("type", "value"),
            optional: true
        }
    }
});
defineType("ForOfStatement", {
    visitor: [
        "left",
        "right",
        "body"
    ],
    builder: [
        "left",
        "right",
        "body",
        "await"
    ],
    aliases: [
        "Scopable",
        "Statement",
        "For",
        "BlockParent",
        "Loop",
        "ForXStatement"
    ],
    fields: {
        left: {
            validate: function() {
                var node, key, val;
                return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
            }()
        },
        right: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
            validate: (0, _utils.assertNodeType)("Statement")
        },
        await: {
            default: false
        }
    }
});
defineType("ImportDeclaration", {
    visitor: [
        "specifiers",
        "source"
    ],
    aliases: [
        "Statement",
        "Declaration",
        "ModuleDeclaration"
    ],
    fields: {
        assertions: {
            optional: true,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
        },
        specifiers: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
        },
        source: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        importKind: {
            validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
            optional: true
        }
    }
});
defineType("ImportDefaultSpecifier", {
    visitor: [
        "local"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        local: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
defineType("ImportNamespaceSpecifier", {
    visitor: [
        "local"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        local: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
defineType("ImportSpecifier", {
    visitor: [
        "local",
        "imported"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        local: {
            validate: (0, _utils.assertNodeType)("Identifier")
        },
        imported: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        importKind: {
            validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
            optional: true
        }
    }
});
defineType("MetaProperty", {
    visitor: [
        "meta",
        "property"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        meta: {
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node, key, val) {
                return;
            }, {
                oneOfNodeTypes: [
                    "Identifier"
                ]
            }))
        },
        property: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
const classMethodOrPropertyCommon = {
    abstract: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
    },
    accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true
    },
    static: {
        default: false
    },
    override: {
        default: false
    },
    computed: {
        default: false
    },
    optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
    },
    key: {
        validate: (0, _utils.chain)(function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
            const computed = (0, _utils.assertNodeType)("Expression");
            return function(node, key, val) {
                const validator = node.computed ? computed : normal;
                validator(node, key, val);
            };
        }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
    }
};
exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
const classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {
    params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
    },
    kind: {
        validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
        default: "method"
    },
    access: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
        optional: true
    },
    decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
        optional: true
    }
});
exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
defineType("ClassMethod", {
    aliases: [
        "Function",
        "Scopable",
        "BlockParent",
        "FunctionParent",
        "Method"
    ],
    builder: [
        "kind",
        "key",
        "params",
        "body",
        "computed",
        "static",
        "generator",
        "async"
    ],
    visitor: [
        "key",
        "params",
        "body",
        "decorators",
        "returnType",
        "typeParameters"
    ],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    })
});
defineType("ObjectPattern", {
    visitor: [
        "properties",
        "typeAnnotation",
        "decorators"
    ],
    builder: [
        "properties"
    ],
    aliases: [
        "Pattern",
        "PatternLike",
        "LVal"
    ],
    fields: Object.assign({}, patternLikeCommon, {
        properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
        }
    })
});
defineType("SpreadElement", {
    visitor: [
        "argument"
    ],
    aliases: [
        "UnaryLike"
    ],
    deprecatedAlias: "SpreadProperty",
    fields: {
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("Super", {
    aliases: [
        "Expression"
    ]
});
defineType("TaggedTemplateExpression", {
    visitor: [
        "tag",
        "quasi",
        "typeParameters"
    ],
    builder: [
        "tag",
        "quasi"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        tag: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        quasi: {
            validate: (0, _utils.assertNodeType)("TemplateLiteral")
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
        }
    }
});
defineType("TemplateElement", {
    builder: [
        "value",
        "tail"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertShape)({
                raw: {
                    validate: (0, _utils.assertValueType)("string")
                },
                cooked: {
                    validate: (0, _utils.assertValueType)("string"),
                    optional: true
                }
            })
        },
        tail: {
            default: false
        }
    }
});
defineType("TemplateLiteral", {
    visitor: [
        "quasis",
        "expressions"
    ],
    aliases: [
        "Expression",
        "Literal"
    ],
    fields: {
        quasis: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
        },
        expressions: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node, key, val) {
                if (node.quasis.length !== val.length + 1) throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);
            })
        }
    }
});
defineType("YieldExpression", {
    builder: [
        "argument",
        "delegate"
    ],
    visitor: [
        "argument"
    ],
    aliases: [
        "Expression",
        "Terminatorless"
    ],
    fields: {
        delegate: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
                return;
            }, {
                type: "boolean"
            })),
            default: false
        },
        argument: {
            optional: true,
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("AwaitExpression", {
    builder: [
        "argument"
    ],
    visitor: [
        "argument"
    ],
    aliases: [
        "Expression",
        "Terminatorless"
    ],
    fields: {
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("Import", {
    aliases: [
        "Expression"
    ]
});
defineType("BigIntLiteral", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    },
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
defineType("ExportNamespaceSpecifier", {
    visitor: [
        "exported"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        exported: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
defineType("OptionalMemberExpression", {
    builder: [
        "object",
        "property",
        "computed",
        "optional"
    ],
    visitor: [
        "object",
        "property"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        object: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        property: {
            validate: function() {
                const normal = (0, _utils.assertNodeType)("Identifier");
                const computed = (0, _utils.assertNodeType)("Expression");
                const validator5 = function(node, key, val) {
                    const validator = node.computed ? computed : normal;
                    validator(node, key, val);
                };
                validator5.oneOfNodeTypes = [
                    "Expression",
                    "Identifier"
                ];
                return validator5;
            }()
        },
        computed: {
            default: false
        },
        optional: {
            validate: (0, _utils.assertValueType)("boolean")
        }
    }
});
defineType("OptionalCallExpression", {
    visitor: [
        "callee",
        "arguments",
        "typeParameters",
        "typeArguments"
    ],
    builder: [
        "callee",
        "arguments",
        "optional"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        callee: {
            validate: (0, _utils.assertNodeType)("Expression")
        },
        arguments: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
        },
        optional: {
            validate: (0, _utils.assertValueType)("boolean")
        },
        typeArguments: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
            optional: true
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
            optional: true
        }
    }
});
defineType("ClassProperty", {
    visitor: [
        "key",
        "value",
        "typeAnnotation",
        "decorators"
    ],
    builder: [
        "key",
        "value",
        "typeAnnotation",
        "decorators",
        "computed",
        "static"
    ],
    aliases: [
        "Property"
    ],
    fields: Object.assign({}, classMethodOrPropertyCommon, {
        value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: true
        }
    })
});
defineType("ClassPrivateProperty", {
    visitor: [
        "key",
        "value",
        "decorators",
        "typeAnnotation"
    ],
    builder: [
        "key",
        "value",
        "decorators",
        "static"
    ],
    aliases: [
        "Property",
        "Private"
    ],
    fields: {
        key: {
            validate: (0, _utils.assertNodeType)("PrivateName")
        },
        value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: true
        },
        typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        },
        readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: true
        }
    }
});
defineType("ClassPrivateMethod", {
    builder: [
        "kind",
        "key",
        "params",
        "body",
        "static"
    ],
    visitor: [
        "key",
        "params",
        "body",
        "decorators",
        "returnType",
        "typeParameters"
    ],
    aliases: [
        "Function",
        "Scopable",
        "BlockParent",
        "FunctionParent",
        "Method",
        "Private"
    ],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
        key: {
            validate: (0, _utils.assertNodeType)("PrivateName")
        },
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        }
    })
});
defineType("PrivateName", {
    visitor: [
        "id"
    ],
    aliases: [
        "Private"
    ],
    fields: {
        id: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
defineType("StaticBlock", {
    visitor: [
        "body"
    ],
    fields: {
        body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
        }
    },
    aliases: [
        "Scopable",
        "BlockParent",
        "FunctionParent"
    ]
});

},{"../validators/is":"hT8C8","../validators/isValidIdentifier":"gHSEO","@babel/helper-validator-identifier":"f9R0u","../constants":"7tigb","./utils":"euwIL"}],"hT8C8":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = is;
var _shallowEqual = require("../utils/shallowEqual");
var _isType = require("./isType");
var _isPlaceholderType = require("./isPlaceholderType");
var _definitions = require("../definitions");
function is(type, node, opts) {
    if (!node) return false;
    const matches = (0, _isType.default)(node.type, type);
    if (!matches) {
        if (!opts && node.type === "Placeholder" && type in _definitions.FLIPPED_ALIAS_KEYS) return (0, _isPlaceholderType.default)(node.expectedNode, type);
        return false;
    }
    if (typeof opts === "undefined") return true;
    else return (0, _shallowEqual.default)(node, opts);
}

},{"../utils/shallowEqual":"hnhdB","./isType":"bhmzl","./isPlaceholderType":"9J4JA","../definitions":"lTnnW"}],"bhmzl":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isType;
var _definitions = require("../definitions");
function isType(nodeType, targetType) {
    if (nodeType === targetType) return true;
    if (_definitions.ALIAS_KEYS[targetType]) return false;
    const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];
    if (aliases) {
        if (aliases[0] === nodeType) return true;
        for (const alias of aliases){
            if (nodeType === alias) return true;
        }
    }
    return false;
}

},{"../definitions":"lTnnW"}],"9J4JA":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isPlaceholderType;
var _definitions = require("../definitions");
function isPlaceholderType(placeholderType, targetType) {
    if (placeholderType === targetType) return true;
    const aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];
    if (aliases) for (const alias of aliases){
        if (targetType === alias) return true;
    }
    return false;
}

},{"../definitions":"lTnnW"}],"gHSEO":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isValidIdentifier;
var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");
function isValidIdentifier(name, reserved = true) {
    if (typeof name !== "string") return false;
    if (reserved) {
        if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) return false;
    }
    return (0, _helperValidatorIdentifier.isIdentifierName)(name);
}

},{"@babel/helper-validator-identifier":"f9R0u"}],"7tigb":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.NOT_LOCAL_BINDING = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BLOCK_SCOPED_SYMBOL = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = void 0;
const STATEMENT_OR_BLOCK_KEYS = [
    "consequent",
    "body",
    "alternate"
];
exports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
const FLATTENABLE_KEYS = [
    "body",
    "expressions"
];
exports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
const FOR_INIT_KEYS = [
    "left",
    "init"
];
exports.FOR_INIT_KEYS = FOR_INIT_KEYS;
const COMMENT_KEYS = [
    "leadingComments",
    "trailingComments",
    "innerComments"
];
exports.COMMENT_KEYS = COMMENT_KEYS;
const LOGICAL_OPERATORS = [
    "||",
    "&&",
    "??"
];
exports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
const UPDATE_OPERATORS = [
    "++",
    "--"
];
exports.UPDATE_OPERATORS = UPDATE_OPERATORS;
const BOOLEAN_NUMBER_BINARY_OPERATORS = [
    ">",
    "<",
    ">=",
    "<="
];
exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
const EQUALITY_BINARY_OPERATORS = [
    "==",
    "===",
    "!=",
    "!=="
];
exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
const COMPARISON_BINARY_OPERATORS = [
    ...EQUALITY_BINARY_OPERATORS,
    "in",
    "instanceof"
];
exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
const BOOLEAN_BINARY_OPERATORS = [
    ...COMPARISON_BINARY_OPERATORS,
    ...BOOLEAN_NUMBER_BINARY_OPERATORS
];
exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
const NUMBER_BINARY_OPERATORS = [
    "-",
    "/",
    "%",
    "*",
    "**",
    "&",
    "|",
    ">>",
    ">>>",
    "<<",
    "^"
];
exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
const BINARY_OPERATORS = [
    "+",
    ...NUMBER_BINARY_OPERATORS,
    ...BOOLEAN_BINARY_OPERATORS
];
exports.BINARY_OPERATORS = BINARY_OPERATORS;
const ASSIGNMENT_OPERATORS = [
    "=",
    "+=",
    ...NUMBER_BINARY_OPERATORS.map((op)=>op + "="
    ),
    ...LOGICAL_OPERATORS.map((op)=>op + "="
    )
];
exports.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
const BOOLEAN_UNARY_OPERATORS = [
    "delete",
    "!"
];
exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
const NUMBER_UNARY_OPERATORS = [
    "+",
    "-",
    "~"
];
exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
const STRING_UNARY_OPERATORS = [
    "typeof"
];
exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
const UNARY_OPERATORS = [
    "void",
    "throw",
    ...BOOLEAN_UNARY_OPERATORS,
    ...NUMBER_UNARY_OPERATORS,
    ...STRING_UNARY_OPERATORS
];
exports.UNARY_OPERATORS = UNARY_OPERATORS;
const INHERIT_KEYS = {
    optional: [
        "typeAnnotation",
        "typeParameters",
        "returnType"
    ],
    force: [
        "start",
        "loc",
        "end"
    ]
};
exports.INHERIT_KEYS = INHERIT_KEYS;
const BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
exports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
const NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
exports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;

},{}],"euwIL":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;
exports.arrayOf = arrayOf;
exports.arrayOfType = arrayOfType;
exports.assertEach = assertEach;
exports.assertNodeOrValueType = assertNodeOrValueType;
exports.assertNodeType = assertNodeType;
exports.assertOneOf = assertOneOf;
exports.assertOptionalChainStart = assertOptionalChainStart;
exports.assertShape = assertShape;
exports.assertValueType = assertValueType;
exports.chain = chain;
exports.default = defineType;
exports.defineAliasedType = defineAliasedType;
exports.typeIs = typeIs;
exports.validate = validate;
exports.validateArrayOfType = validateArrayOfType;
exports.validateOptional = validateOptional;
exports.validateOptionalType = validateOptionalType;
exports.validateType = validateType;
var _is = require("../validators/is");
var _validate = require("../validators/validate");
const VISITOR_KEYS = {};
exports.VISITOR_KEYS = VISITOR_KEYS;
const ALIAS_KEYS = {};
exports.ALIAS_KEYS = ALIAS_KEYS;
const FLIPPED_ALIAS_KEYS = {};
exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
const NODE_FIELDS = {};
exports.NODE_FIELDS = NODE_FIELDS;
const BUILDER_KEYS = {};
exports.BUILDER_KEYS = BUILDER_KEYS;
const DEPRECATED_KEYS = {};
exports.DEPRECATED_KEYS = DEPRECATED_KEYS;
const NODE_PARENT_VALIDATIONS = {};
exports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;
function getType(val) {
    if (Array.isArray(val)) return "array";
    else if (val === null) return "null";
    else return typeof val;
}
function validate(validate1) {
    return {
        validate: validate1
    };
}
function typeIs(typeName) {
    return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
}
function validateType(typeName) {
    return validate(typeIs(typeName));
}
function validateOptional(validate2) {
    return {
        validate: validate2,
        optional: true
    };
}
function validateOptionalType(typeName) {
    return {
        validate: typeIs(typeName),
        optional: true
    };
}
function arrayOf(elementType) {
    return chain(assertValueType("array"), assertEach(elementType));
}
function arrayOfType(typeName) {
    return arrayOf(typeIs(typeName));
}
function validateArrayOfType(typeName) {
    return validate(arrayOfType(typeName));
}
function assertEach(callback) {
    function validator(node, key, val) {
        if (!Array.isArray(val)) return;
        for(let i = 0; i < val.length; i++){
            const subkey = `${key}[${i}]`;
            const v = val[i];
            callback(node, subkey, v);
        }
    }
    validator.each = callback;
    return validator;
}
function assertOneOf(...values) {
    function validate3(node, key, val) {
        if (values.indexOf(val) < 0) throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
    }
    validate3.oneOf = values;
    return validate3;
}
function assertNodeType(...types) {
    function validate4(node, key, val) {
        for (const type of types)if ((0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
    }
    validate4.oneOfNodeTypes = types;
    return validate4;
}
function assertNodeOrValueType(...types) {
    function validate5(node, key, val) {
        for (const type of types)if (getType(val) === type || (0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
        }
        throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
    }
    validate5.oneOfNodeOrValueTypes = types;
    return validate5;
}
function assertValueType(type) {
    function validate6(node, key, val) {
        const valid = getType(val) === type;
        if (!valid) throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
    }
    validate6.type = type;
    return validate6;
}
function assertShape(shape) {
    function validate7(node, key, val) {
        const errors = [];
        for (const property of Object.keys(shape))try {
            (0, _validate.validateField)(node, property, val[property], shape[property]);
        } catch (error) {
            if (error instanceof TypeError) {
                errors.push(error.message);
                continue;
            }
            throw error;
        }
        if (errors.length) throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\n${errors.join("\n")}`);
    }
    validate7.shapeOf = shape;
    return validate7;
}
function assertOptionalChainStart() {
    function validate8(node) {
        var _current;
        let current = node;
        while(node){
            const { type  } = current;
            if (type === "OptionalCallExpression") {
                if (current.optional) return;
                current = current.callee;
                continue;
            }
            if (type === "OptionalMemberExpression") {
                if (current.optional) return;
                current = current.object;
                continue;
            }
            break;
        }
        throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
    }
    return validate8;
}
function chain(...fns) {
    function validate9(...args) {
        for (const fn of fns)fn(...args);
    }
    validate9.chainOf = fns;
    if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
    return validate9;
}
const validTypeOpts = [
    "aliases",
    "builder",
    "deprecatedAlias",
    "fields",
    "inherits",
    "visitor",
    "validate"
];
const validFieldKeys = [
    "default",
    "optional",
    "validate"
];
function defineAliasedType(...aliases) {
    return (type, opts = {})=>{
        let defined = opts.aliases;
        if (!defined) {
            var _store$opts$inherits$, _defined;
            if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
            (_defined = defined) != null || (defined = []);
            opts.aliases = defined;
        }
        const additional = aliases.filter((a)=>!defined.includes(a)
        );
        defined.unshift(...additional);
        return defineType(type, opts);
    };
}
function defineType(type, opts = {}) {
    const inherits = opts.inherits && store[opts.inherits] || {};
    let fields = opts.fields;
    if (!fields) {
        fields = {};
        if (inherits.fields) {
            const keys = Object.getOwnPropertyNames(inherits.fields);
            for (const key of keys){
                const field = inherits.fields[key];
                const def = field.default;
                if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") throw new Error("field defaults can only be primitives or empty arrays currently");
                fields[key] = {
                    default: Array.isArray(def) ? [] : def,
                    optional: field.optional,
                    validate: field.validate
                };
            }
        }
    }
    const visitor = opts.visitor || inherits.visitor || [];
    const aliases = opts.aliases || inherits.aliases || [];
    const builder = opts.builder || inherits.builder || opts.visitor || [];
    for (const k of Object.keys(opts)){
        if (validTypeOpts.indexOf(k) === -1) throw new Error(`Unknown type option "${k}" on ${type}`);
    }
    if (opts.deprecatedAlias) DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    for (const key of visitor.concat(builder))fields[key] = fields[key] || {};
    for (const key1 of Object.keys(fields)){
        const field = fields[key1];
        if (field.default !== undefined && builder.indexOf(key1) === -1) field.optional = true;
        if (field.default === undefined) field.default = null;
        else if (!field.validate && field.default != null) field.validate = assertValueType(getType(field.default));
        for (const k of Object.keys(field)){
            if (validFieldKeys.indexOf(k) === -1) throw new Error(`Unknown field key "${k}" on ${type}.${key1}`);
        }
    }
    VISITOR_KEYS[type] = opts.visitor = visitor;
    BUILDER_KEYS[type] = opts.builder = builder;
    NODE_FIELDS[type] = opts.fields = fields;
    ALIAS_KEYS[type] = opts.aliases = aliases;
    aliases.forEach((alias)=>{
        FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
        FLIPPED_ALIAS_KEYS[alias].push(type);
    });
    if (opts.validate) NODE_PARENT_VALIDATIONS[type] = opts.validate;
    store[type] = opts;
}
const store = {};

},{"../validators/is":"hT8C8","../validators/validate":"dAbSc"}],"dAbSc":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = validate;
exports.validateChild = validateChild;
exports.validateField = validateField;
var _definitions = require("../definitions");
function validate(node, key, val) {
    if (!node) return;
    const fields = _definitions.NODE_FIELDS[node.type];
    if (!fields) return;
    const field = fields[key];
    validateField(node, key, val, field);
    validateChild(node, key, val);
}
function validateField(node, key, val, field) {
    if (!(field != null && field.validate)) return;
    if (field.optional && val == null) return;
    field.validate(node, key, val);
}
function validateChild(node, key, val) {
    if (val == null) return;
    const validate1 = _definitions.NODE_PARENT_VALIDATIONS[val.type];
    if (!validate1) return;
    validate1(node, key, val);
}

},{"../definitions":"lTnnW"}],"2Ewm7":[function(require,module,exports) {
"use strict";
var _utils = require("./utils");
const defineType = (0, _utils.defineAliasedType)("Flow");
const defineInterfaceishType = (name, typeParameterType = "TypeParameterDeclaration")=>{
    defineType(name, {
        builder: [
            "id",
            "typeParameters",
            "extends",
            "body"
        ],
        visitor: [
            "id",
            "typeParameters",
            "extends",
            "mixins",
            "implements",
            "body"
        ],
        aliases: [
            "FlowDeclaration",
            "Statement",
            "Declaration"
        ],
        fields: {
            id: (0, _utils.validateType)("Identifier"),
            typeParameters: (0, _utils.validateOptionalType)(typeParameterType),
            extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
            mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
            implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements")),
            body: (0, _utils.validateType)("ObjectTypeAnnotation")
        }
    });
};
defineType("AnyTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("ArrayTypeAnnotation", {
    visitor: [
        "elementType"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        elementType: (0, _utils.validateType)("FlowType")
    }
});
defineType("BooleanTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("BooleanLiteralTypeAnnotation", {
    builder: [
        "value"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("NullLiteralTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("ClassImplements", {
    visitor: [
        "id",
        "typeParameters"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
});
defineInterfaceishType("DeclareClass");
defineType("DeclareFunction", {
    visitor: [
        "id"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
    }
});
defineInterfaceishType("DeclareInterface");
defineType("DeclareModule", {
    builder: [
        "id",
        "body",
        "kind"
    ],
    visitor: [
        "id",
        "body"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)([
            "Identifier",
            "StringLiteral"
        ]),
        body: (0, _utils.validateType)("BlockStatement"),
        kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
    }
});
defineType("DeclareModuleExports", {
    visitor: [
        "typeAnnotation"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
});
defineType("DeclareTypeAlias", {
    visitor: [
        "id",
        "typeParameters",
        "right"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
    }
});
defineType("DeclareOpaqueType", {
    visitor: [
        "id",
        "typeParameters",
        "supertype"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateOptionalType)("FlowType")
    }
});
defineType("DeclareVariable", {
    visitor: [
        "id"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier")
    }
});
defineType("DeclareExportDeclaration", {
    visitor: [
        "declaration",
        "specifiers",
        "source"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        declaration: (0, _utils.validateOptionalType)("Flow"),
        specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)([
            "ExportSpecifier",
            "ExportNamespaceSpecifier"
        ])),
        source: (0, _utils.validateOptionalType)("StringLiteral"),
        default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("DeclareExportAllDeclaration", {
    visitor: [
        "source"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        source: (0, _utils.validateType)("StringLiteral"),
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }
});
defineType("DeclaredPredicate", {
    visitor: [
        "value"
    ],
    aliases: [
        "FlowPredicate"
    ],
    fields: {
        value: (0, _utils.validateType)("Flow")
    }
});
defineType("ExistsTypeAnnotation", {
    aliases: [
        "FlowType"
    ]
});
defineType("FunctionTypeAnnotation", {
    visitor: [
        "typeParameters",
        "params",
        "rest",
        "returnType"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
        rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        returnType: (0, _utils.validateType)("FlowType")
    }
});
defineType("FunctionTypeParam", {
    visitor: [
        "name",
        "typeAnnotation"
    ],
    fields: {
        name: (0, _utils.validateOptionalType)("Identifier"),
        typeAnnotation: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("GenericTypeAnnotation", {
    visitor: [
        "id",
        "typeParameters"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        id: (0, _utils.validateType)([
            "Identifier",
            "QualifiedTypeIdentifier"
        ]),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
});
defineType("InferredPredicate", {
    aliases: [
        "FlowPredicate"
    ]
});
defineType("InterfaceExtends", {
    visitor: [
        "id",
        "typeParameters"
    ],
    fields: {
        id: (0, _utils.validateType)([
            "Identifier",
            "QualifiedTypeIdentifier"
        ]),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
});
defineInterfaceishType("InterfaceDeclaration");
defineType("InterfaceTypeAnnotation", {
    visitor: [
        "extends",
        "body"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        body: (0, _utils.validateType)("ObjectTypeAnnotation")
    }
});
defineType("IntersectionTypeAnnotation", {
    visitor: [
        "types"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
});
defineType("MixedTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("EmptyTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("NullableTypeAnnotation", {
    visitor: [
        "typeAnnotation"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
    }
});
defineType("NumberLiteralTypeAnnotation", {
    builder: [
        "value"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
    }
});
defineType("NumberTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("ObjectTypeAnnotation", {
    visitor: [
        "properties",
        "indexers",
        "callProperties",
        "internalSlots"
    ],
    aliases: [
        "FlowType"
    ],
    builder: [
        "properties",
        "indexers",
        "callProperties",
        "internalSlots",
        "exact"
    ],
    fields: {
        properties: (0, _utils.validate)((0, _utils.arrayOfType)([
            "ObjectTypeProperty",
            "ObjectTypeSpreadProperty"
        ])),
        indexers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeIndexer")),
        callProperties: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeCallProperty")),
        internalSlots: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeInternalSlot")),
        exact: {
            validate: (0, _utils.assertValueType)("boolean"),
            default: false
        },
        inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("ObjectTypeInternalSlot", {
    visitor: [
        "id",
        "value",
        "optional",
        "static",
        "method"
    ],
    aliases: [
        "UserWhitespacable"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        value: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("ObjectTypeCallProperty", {
    visitor: [
        "value"
    ],
    aliases: [
        "UserWhitespacable"
    ],
    fields: {
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("ObjectTypeIndexer", {
    visitor: [
        "id",
        "key",
        "value",
        "variance"
    ],
    aliases: [
        "UserWhitespacable"
    ],
    fields: {
        id: (0, _utils.validateOptionalType)("Identifier"),
        key: (0, _utils.validateType)("FlowType"),
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance")
    }
});
defineType("ObjectTypeProperty", {
    visitor: [
        "key",
        "value",
        "variance"
    ],
    aliases: [
        "UserWhitespacable"
    ],
    fields: {
        key: (0, _utils.validateType)([
            "Identifier",
            "StringLiteral"
        ]),
        value: (0, _utils.validateType)("FlowType"),
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance"),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("ObjectTypeSpreadProperty", {
    visitor: [
        "argument"
    ],
    aliases: [
        "UserWhitespacable"
    ],
    fields: {
        argument: (0, _utils.validateType)("FlowType")
    }
});
defineType("OpaqueType", {
    visitor: [
        "id",
        "typeParameters",
        "supertype",
        "impltype"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateType)("FlowType")
    }
});
defineType("QualifiedTypeIdentifier", {
    visitor: [
        "id",
        "qualification"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        qualification: (0, _utils.validateType)([
            "Identifier",
            "QualifiedTypeIdentifier"
        ])
    }
});
defineType("StringLiteralTypeAnnotation", {
    builder: [
        "value"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
    }
});
defineType("StringTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("SymbolTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("ThisTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("TupleTypeAnnotation", {
    visitor: [
        "types"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
});
defineType("TypeofTypeAnnotation", {
    visitor: [
        "argument"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        argument: (0, _utils.validateType)("FlowType")
    }
});
defineType("TypeAlias", {
    visitor: [
        "id",
        "typeParameters",
        "right"
    ],
    aliases: [
        "FlowDeclaration",
        "Statement",
        "Declaration"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
    }
});
defineType("TypeAnnotation", {
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
    }
});
defineType("TypeCastExpression", {
    visitor: [
        "expression",
        "typeAnnotation"
    ],
    aliases: [
        "ExpressionWrapper",
        "Expression"
    ],
    fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
});
defineType("TypeParameter", {
    visitor: [
        "bound",
        "default",
        "variance"
    ],
    fields: {
        name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
        default: (0, _utils.validateOptionalType)("FlowType"),
        variance: (0, _utils.validateOptionalType)("Variance")
    }
});
defineType("TypeParameterDeclaration", {
    visitor: [
        "params"
    ],
    fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
    }
});
defineType("TypeParameterInstantiation", {
    visitor: [
        "params"
    ],
    fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
});
defineType("UnionTypeAnnotation", {
    visitor: [
        "types"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
});
defineType("Variance", {
    builder: [
        "kind"
    ],
    fields: {
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
    }
});
defineType("VoidTypeAnnotation", {
    aliases: [
        "FlowType",
        "FlowBaseAnnotation"
    ]
});
defineType("EnumDeclaration", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "body"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        body: (0, _utils.validateType)([
            "EnumBooleanBody",
            "EnumNumberBody",
            "EnumStringBody",
            "EnumSymbolBody"
        ])
    }
});
defineType("EnumBooleanBody", {
    aliases: [
        "EnumBody"
    ],
    visitor: [
        "members"
    ],
    fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("EnumNumberBody", {
    aliases: [
        "EnumBody"
    ],
    visitor: [
        "members"
    ],
    fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("EnumStringBody", {
    aliases: [
        "EnumBody"
    ],
    visitor: [
        "members"
    ],
    fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)([
            "EnumStringMember",
            "EnumDefaultedMember"
        ]),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("EnumSymbolBody", {
    aliases: [
        "EnumBody"
    ],
    visitor: [
        "members"
    ],
    fields: {
        members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});
defineType("EnumBooleanMember", {
    aliases: [
        "EnumMember"
    ],
    visitor: [
        "id"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("BooleanLiteral")
    }
});
defineType("EnumNumberMember", {
    aliases: [
        "EnumMember"
    ],
    visitor: [
        "id",
        "init"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("NumericLiteral")
    }
});
defineType("EnumStringMember", {
    aliases: [
        "EnumMember"
    ],
    visitor: [
        "id",
        "init"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("StringLiteral")
    }
});
defineType("EnumDefaultedMember", {
    aliases: [
        "EnumMember"
    ],
    visitor: [
        "id"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier")
    }
});
defineType("IndexedAccessType", {
    visitor: [
        "objectType",
        "indexType"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType")
    }
});
defineType("OptionalIndexedAccessType", {
    visitor: [
        "objectType",
        "indexType"
    ],
    aliases: [
        "FlowType"
    ],
    fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
});

},{"./utils":"euwIL"}],"erJRU":[function(require,module,exports) {
"use strict";
var _utils = require("./utils");
const defineType = (0, _utils.defineAliasedType)("JSX");
defineType("JSXAttribute", {
    visitor: [
        "name",
        "value"
    ],
    aliases: [
        "Immutable"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
        },
        value: {
            optional: true,
            validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
        }
    }
});
defineType("JSXClosingElement", {
    visitor: [
        "name"
    ],
    aliases: [
        "Immutable"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        }
    }
});
defineType("JSXElement", {
    builder: [
        "openingElement",
        "closingElement",
        "children",
        "selfClosing"
    ],
    visitor: [
        "openingElement",
        "children",
        "closingElement"
    ],
    aliases: [
        "Immutable",
        "Expression"
    ],
    fields: {
        openingElement: {
            validate: (0, _utils.assertNodeType)("JSXOpeningElement")
        },
        closingElement: {
            optional: true,
            validate: (0, _utils.assertNodeType)("JSXClosingElement")
        },
        children: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        },
        selfClosing: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        }
    }
});
defineType("JSXEmptyExpression", {});
defineType("JSXExpressionContainer", {
    visitor: [
        "expression"
    ],
    aliases: [
        "Immutable"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
        }
    }
});
defineType("JSXSpreadChild", {
    visitor: [
        "expression"
    ],
    aliases: [
        "Immutable"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("JSXIdentifier", {
    builder: [
        "name"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertValueType)("string")
        }
    }
});
defineType("JSXMemberExpression", {
    visitor: [
        "object",
        "property"
    ],
    fields: {
        object: {
            validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
        },
        property: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
    }
});
defineType("JSXNamespacedName", {
    visitor: [
        "namespace",
        "name"
    ],
    fields: {
        namespace: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
        },
        name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
    }
});
defineType("JSXOpeningElement", {
    builder: [
        "name",
        "attributes",
        "selfClosing"
    ],
    visitor: [
        "name",
        "attributes"
    ],
    aliases: [
        "Immutable"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        },
        selfClosing: {
            default: false
        },
        attributes: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
        },
        typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: true
        }
    }
});
defineType("JSXSpreadAttribute", {
    visitor: [
        "argument"
    ],
    fields: {
        argument: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
defineType("JSXText", {
    aliases: [
        "Immutable"
    ],
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    }
});
defineType("JSXFragment", {
    builder: [
        "openingFragment",
        "closingFragment",
        "children"
    ],
    visitor: [
        "openingFragment",
        "children",
        "closingFragment"
    ],
    aliases: [
        "Immutable",
        "Expression"
    ],
    fields: {
        openingFragment: {
            validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
        },
        closingFragment: {
            validate: (0, _utils.assertNodeType)("JSXClosingFragment")
        },
        children: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
        }
    }
});
defineType("JSXOpeningFragment", {
    aliases: [
        "Immutable"
    ]
});
defineType("JSXClosingFragment", {
    aliases: [
        "Immutable"
    ]
});

},{"./utils":"euwIL"}],"lA04r":[function(require,module,exports) {
"use strict";
var _utils = require("./utils");
var _placeholders = require("./placeholders");
const defineType = (0, _utils.defineAliasedType)("Miscellaneous");
defineType("Noop", {
    visitor: []
});
defineType("Placeholder", {
    visitor: [],
    builder: [
        "expectedNode",
        "name"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertNodeType)("Identifier")
        },
        expectedNode: {
            validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
        }
    }
});
defineType("V8IntrinsicIdentifier", {
    builder: [
        "name"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertValueType)("string")
        }
    }
});

},{"./utils":"euwIL","./placeholders":"bQquQ"}],"bQquQ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;
var _utils = require("./utils");
const PLACEHOLDERS = [
    "Identifier",
    "StringLiteral",
    "Expression",
    "Statement",
    "Declaration",
    "BlockStatement",
    "ClassBody",
    "Pattern"
];
exports.PLACEHOLDERS = PLACEHOLDERS;
const PLACEHOLDERS_ALIAS = {
    Declaration: [
        "Statement"
    ],
    Pattern: [
        "PatternLike",
        "LVal"
    ]
};
exports.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;
for (const type of PLACEHOLDERS){
    const alias = _utils.ALIAS_KEYS[type];
    if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;
}
const PLACEHOLDERS_FLIPPED_ALIAS = {};
exports.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;
Object.keys(PLACEHOLDERS_ALIAS).forEach((type1)=>{
    PLACEHOLDERS_ALIAS[type1].forEach((alias)=>{
        if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
        PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type1);
    });
});

},{"./utils":"euwIL"}],"dJ9kT":[function(require,module,exports) {
"use strict";
var _utils = require("./utils");
(0, _utils.default)("ArgumentPlaceholder", {});
(0, _utils.default)("BindExpression", {
    visitor: [
        "object",
        "callee"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        object: {
            validate: Object.assign(()=>{}, {
                oneOfNodeTypes: [
                    "Expression"
                ]
            })
        },
        callee: {
            validate: Object.assign(()=>{}, {
                oneOfNodeTypes: [
                    "Expression"
                ]
            })
        }
    }
});
(0, _utils.default)("ImportAttribute", {
    visitor: [
        "key",
        "value"
    ],
    fields: {
        key: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        value: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
        }
    }
});
(0, _utils.default)("Decorator", {
    visitor: [
        "expression"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    }
});
(0, _utils.default)("DoExpression", {
    visitor: [
        "body"
    ],
    builder: [
        "body",
        "async"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        async: {
            validate: (0, _utils.assertValueType)("boolean"),
            default: false
        }
    }
});
(0, _utils.default)("ExportDefaultSpecifier", {
    visitor: [
        "exported"
    ],
    aliases: [
        "ModuleSpecifier"
    ],
    fields: {
        exported: {
            validate: (0, _utils.assertNodeType)("Identifier")
        }
    }
});
(0, _utils.default)("RecordExpression", {
    visitor: [
        "properties"
    ],
    aliases: [
        "Expression"
    ],
    fields: {
        properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty", "SpreadElement")))
        }
    }
});
(0, _utils.default)("TupleExpression", {
    fields: {
        elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))),
            default: []
        }
    },
    visitor: [
        "elements"
    ],
    aliases: [
        "Expression"
    ]
});
(0, _utils.default)("DecimalLiteral", {
    builder: [
        "value"
    ],
    fields: {
        value: {
            validate: (0, _utils.assertValueType)("string")
        }
    },
    aliases: [
        "Expression",
        "Pureish",
        "Literal",
        "Immutable"
    ]
});
(0, _utils.default)("ModuleExpression", {
    visitor: [
        "body"
    ],
    fields: {
        body: {
            validate: (0, _utils.assertNodeType)("Program")
        }
    },
    aliases: [
        "Expression"
    ]
});
(0, _utils.default)("TopicReference", {
    aliases: [
        "Expression"
    ]
});
(0, _utils.default)("PipelineTopicExpression", {
    builder: [
        "expression"
    ],
    visitor: [
        "expression"
    ],
    fields: {
        expression: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    aliases: [
        "Expression"
    ]
});
(0, _utils.default)("PipelineBareFunction", {
    builder: [
        "callee"
    ],
    visitor: [
        "callee"
    ],
    fields: {
        callee: {
            validate: (0, _utils.assertNodeType)("Expression")
        }
    },
    aliases: [
        "Expression"
    ]
});
(0, _utils.default)("PipelinePrimaryTopicReference", {
    aliases: [
        "Expression"
    ]
});

},{"./utils":"euwIL"}],"loVZW":[function(require,module,exports) {
"use strict";
var _utils = require("./utils");
var _core = require("./core");
var _is = require("../validators/is");
const defineType = (0, _utils.defineAliasedType)("TypeScript");
const bool = (0, _utils.assertValueType)("boolean");
const tSFunctionTypeAnnotationCommon = {
    returnType: {
        validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
        optional: true
    },
    typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
        optional: true
    }
};
defineType("TSParameterProperty", {
    aliases: [
        "LVal"
    ],
    visitor: [
        "parameter"
    ],
    fields: {
        accessibility: {
            validate: (0, _utils.assertOneOf)("public", "private", "protected"),
            optional: true
        },
        readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        parameter: {
            validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
        },
        override: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: true
        },
        decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
            optional: true
        }
    }
});
defineType("TSDeclareFunction", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "typeParameters",
        "params",
        "returnType"
    ],
    fields: Object.assign({}, _core.functionDeclarationCommon, tSFunctionTypeAnnotationCommon)
});
defineType("TSDeclareMethod", {
    visitor: [
        "decorators",
        "key",
        "typeParameters",
        "params",
        "returnType"
    ],
    fields: Object.assign({}, _core.classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon)
});
defineType("TSQualifiedName", {
    aliases: [
        "TSEntityName"
    ],
    visitor: [
        "left",
        "right"
    ],
    fields: {
        left: (0, _utils.validateType)("TSEntityName"),
        right: (0, _utils.validateType)("Identifier")
    }
});
const signatureDeclarationCommon = {
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, _utils.validateArrayOfType)([
        "Identifier",
        "RestElement"
    ]),
    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
};
const callConstructSignatureDeclaration = {
    aliases: [
        "TSTypeElement"
    ],
    visitor: [
        "typeParameters",
        "parameters",
        "typeAnnotation"
    ],
    fields: signatureDeclarationCommon
};
defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
const namedTypeElementCommon = {
    key: (0, _utils.validateType)("Expression"),
    computed: (0, _utils.validate)(bool),
    optional: (0, _utils.validateOptional)(bool)
};
defineType("TSPropertySignature", {
    aliases: [
        "TSTypeElement"
    ],
    visitor: [
        "key",
        "typeAnnotation",
        "initializer"
    ],
    fields: Object.assign({}, namedTypeElementCommon, {
        readonly: (0, _utils.validateOptional)(bool),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        initializer: (0, _utils.validateOptionalType)("Expression"),
        kind: {
            validate: (0, _utils.assertOneOf)("get", "set")
        }
    })
});
defineType("TSMethodSignature", {
    aliases: [
        "TSTypeElement"
    ],
    visitor: [
        "key",
        "typeParameters",
        "parameters",
        "typeAnnotation"
    ],
    fields: Object.assign({}, signatureDeclarationCommon, namedTypeElementCommon, {
        kind: {
            validate: (0, _utils.assertOneOf)("method", "get", "set")
        }
    })
});
defineType("TSIndexSignature", {
    aliases: [
        "TSTypeElement"
    ],
    visitor: [
        "parameters",
        "typeAnnotation"
    ],
    fields: {
        readonly: (0, _utils.validateOptional)(bool),
        static: (0, _utils.validateOptional)(bool),
        parameters: (0, _utils.validateArrayOfType)("Identifier"),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    }
});
const tsKeywordTypes = [
    "TSAnyKeyword",
    "TSBooleanKeyword",
    "TSBigIntKeyword",
    "TSIntrinsicKeyword",
    "TSNeverKeyword",
    "TSNullKeyword",
    "TSNumberKeyword",
    "TSObjectKeyword",
    "TSStringKeyword",
    "TSSymbolKeyword",
    "TSUndefinedKeyword",
    "TSUnknownKeyword",
    "TSVoidKeyword"
];
for (const type of tsKeywordTypes)defineType(type, {
    aliases: [
        "TSType",
        "TSBaseType"
    ],
    visitor: [],
    fields: {}
});
defineType("TSThisType", {
    aliases: [
        "TSType",
        "TSBaseType"
    ],
    visitor: [],
    fields: {}
});
const fnOrCtrBase = {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeParameters",
        "parameters",
        "typeAnnotation"
    ]
};
defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
    fields: signatureDeclarationCommon
}));
defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
    fields: Object.assign({}, signatureDeclarationCommon, {
        abstract: (0, _utils.validateOptional)(bool)
    })
}));
defineType("TSTypeReference", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeName",
        "typeParameters"
    ],
    fields: {
        typeName: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
});
defineType("TSTypePredicate", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "parameterName",
        "typeAnnotation"
    ],
    builder: [
        "parameterName",
        "typeAnnotation",
        "asserts"
    ],
    fields: {
        parameterName: (0, _utils.validateType)([
            "Identifier",
            "TSThisType"
        ]),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        asserts: (0, _utils.validateOptional)(bool)
    }
});
defineType("TSTypeQuery", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "exprName"
    ],
    fields: {
        exprName: (0, _utils.validateType)([
            "TSEntityName",
            "TSImportType"
        ])
    }
});
defineType("TSTypeLiteral", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "members"
    ],
    fields: {
        members: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
});
defineType("TSArrayType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "elementType"
    ],
    fields: {
        elementType: (0, _utils.validateType)("TSType")
    }
});
defineType("TSTupleType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "elementTypes"
    ],
    fields: {
        elementTypes: (0, _utils.validateArrayOfType)([
            "TSType",
            "TSNamedTupleMember"
        ])
    }
});
defineType("TSOptionalType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSRestType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSNamedTupleMember", {
    visitor: [
        "label",
        "elementType"
    ],
    builder: [
        "label",
        "elementType",
        "optional"
    ],
    fields: {
        label: (0, _utils.validateType)("Identifier"),
        optional: {
            validate: bool,
            default: false
        },
        elementType: (0, _utils.validateType)("TSType")
    }
});
const unionOrIntersection = {
    aliases: [
        "TSType"
    ],
    visitor: [
        "types"
    ],
    fields: {
        types: (0, _utils.validateArrayOfType)("TSType")
    }
};
defineType("TSUnionType", unionOrIntersection);
defineType("TSIntersectionType", unionOrIntersection);
defineType("TSConditionalType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "checkType",
        "extendsType",
        "trueType",
        "falseType"
    ],
    fields: {
        checkType: (0, _utils.validateType)("TSType"),
        extendsType: (0, _utils.validateType)("TSType"),
        trueType: (0, _utils.validateType)("TSType"),
        falseType: (0, _utils.validateType)("TSType")
    }
});
defineType("TSInferType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeParameter"
    ],
    fields: {
        typeParameter: (0, _utils.validateType)("TSTypeParameter")
    }
});
defineType("TSParenthesizedType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSTypeOperator", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSIndexedAccessType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "objectType",
        "indexType"
    ],
    fields: {
        objectType: (0, _utils.validateType)("TSType"),
        indexType: (0, _utils.validateType)("TSType")
    }
});
defineType("TSMappedType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "typeParameter",
        "typeAnnotation",
        "nameType"
    ],
    fields: {
        readonly: (0, _utils.validateOptional)(bool),
        typeParameter: (0, _utils.validateType)("TSTypeParameter"),
        optional: (0, _utils.validateOptional)(bool),
        typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
        nameType: (0, _utils.validateOptionalType)("TSType")
    }
});
defineType("TSLiteralType", {
    aliases: [
        "TSType",
        "TSBaseType"
    ],
    visitor: [
        "literal"
    ],
    fields: {
        literal: {
            validate: function() {
                const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
                const unaryOperator = (0, _utils.assertOneOf)("-");
                const literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral");
                function validator(parent, key, node) {
                    if ((0, _is.default)("UnaryExpression", node)) {
                        unaryOperator(node, "operator", node.operator);
                        unaryExpression(node, "argument", node.argument);
                    } else literal(parent, key, node);
                }
                validator.oneOfNodeTypes = [
                    "NumericLiteral",
                    "StringLiteral",
                    "BooleanLiteral",
                    "BigIntLiteral",
                    "UnaryExpression"
                ];
                return validator;
            }()
        }
    }
});
defineType("TSExpressionWithTypeArguments", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "expression",
        "typeParameters"
    ],
    fields: {
        expression: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
});
defineType("TSInterfaceDeclaration", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "typeParameters",
        "extends",
        "body"
    ],
    fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
        body: (0, _utils.validateType)("TSInterfaceBody")
    }
});
defineType("TSInterfaceBody", {
    visitor: [
        "body"
    ],
    fields: {
        body: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
});
defineType("TSTypeAliasDeclaration", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "typeParameters",
        "typeAnnotation"
    ],
    fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSAsExpression", {
    aliases: [
        "Expression"
    ],
    visitor: [
        "expression",
        "typeAnnotation"
    ],
    fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TSType")
    }
});
defineType("TSTypeAssertion", {
    aliases: [
        "Expression"
    ],
    visitor: [
        "typeAnnotation",
        "expression"
    ],
    fields: {
        typeAnnotation: (0, _utils.validateType)("TSType"),
        expression: (0, _utils.validateType)("Expression")
    }
});
defineType("TSEnumDeclaration", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "members"
    ],
    fields: {
        declare: (0, _utils.validateOptional)(bool),
        const: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        members: (0, _utils.validateArrayOfType)("TSEnumMember"),
        initializer: (0, _utils.validateOptionalType)("Expression")
    }
});
defineType("TSEnumMember", {
    visitor: [
        "id",
        "initializer"
    ],
    fields: {
        id: (0, _utils.validateType)([
            "Identifier",
            "StringLiteral"
        ]),
        initializer: (0, _utils.validateOptionalType)("Expression")
    }
});
defineType("TSModuleDeclaration", {
    aliases: [
        "Statement",
        "Declaration"
    ],
    visitor: [
        "id",
        "body"
    ],
    fields: {
        declare: (0, _utils.validateOptional)(bool),
        global: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)([
            "Identifier",
            "StringLiteral"
        ]),
        body: (0, _utils.validateType)([
            "TSModuleBlock",
            "TSModuleDeclaration"
        ])
    }
});
defineType("TSModuleBlock", {
    aliases: [
        "Scopable",
        "Block",
        "BlockParent"
    ],
    visitor: [
        "body"
    ],
    fields: {
        body: (0, _utils.validateArrayOfType)("Statement")
    }
});
defineType("TSImportType", {
    aliases: [
        "TSType"
    ],
    visitor: [
        "argument",
        "qualifier",
        "typeParameters"
    ],
    fields: {
        argument: (0, _utils.validateType)("StringLiteral"),
        qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
});
defineType("TSImportEqualsDeclaration", {
    aliases: [
        "Statement"
    ],
    visitor: [
        "id",
        "moduleReference"
    ],
    fields: {
        isExport: (0, _utils.validate)(bool),
        id: (0, _utils.validateType)("Identifier"),
        moduleReference: (0, _utils.validateType)([
            "TSEntityName",
            "TSExternalModuleReference"
        ]),
        importKind: {
            validate: (0, _utils.assertOneOf)("type", "value"),
            optional: true
        }
    }
});
defineType("TSExternalModuleReference", {
    visitor: [
        "expression"
    ],
    fields: {
        expression: (0, _utils.validateType)("StringLiteral")
    }
});
defineType("TSNonNullExpression", {
    aliases: [
        "Expression"
    ],
    visitor: [
        "expression"
    ],
    fields: {
        expression: (0, _utils.validateType)("Expression")
    }
});
defineType("TSExportAssignment", {
    aliases: [
        "Statement"
    ],
    visitor: [
        "expression"
    ],
    fields: {
        expression: (0, _utils.validateType)("Expression")
    }
});
defineType("TSNamespaceExportDeclaration", {
    aliases: [
        "Statement"
    ],
    visitor: [
        "id"
    ],
    fields: {
        id: (0, _utils.validateType)("Identifier")
    }
});
defineType("TSTypeAnnotation", {
    visitor: [
        "typeAnnotation"
    ],
    fields: {
        typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TSType")
        }
    }
});
defineType("TSTypeParameterInstantiation", {
    visitor: [
        "params"
    ],
    fields: {
        params: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
        }
    }
});
defineType("TSTypeParameterDeclaration", {
    visitor: [
        "params"
    ],
    fields: {
        params: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
        }
    }
});
defineType("TSTypeParameter", {
    builder: [
        "constraint",
        "default",
        "name"
    ],
    visitor: [
        "constraint",
        "default"
    ],
    fields: {
        name: {
            validate: (0, _utils.assertValueType)("string")
        },
        constraint: {
            validate: (0, _utils.assertNodeType)("TSType"),
            optional: true
        },
        default: {
            validate: (0, _utils.assertNodeType)("TSType"),
            optional: true
        }
    }
});

},{"./utils":"euwIL","./core":"dxYBh","../validators/is":"hT8C8"}],"ckMRa":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = assertNode;
var _isNode = require("../validators/isNode");
function assertNode(node) {
    if (!(0, _isNode.default)(node)) {
        var _node$type;
        const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
        throw new TypeError(`Not a valid node of type "${type}"`);
    }
}

},{"../validators/isNode":"k3KRs"}],"k3KRs":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isNode;
var _definitions = require("../definitions");
function isNode(node) {
    return !!(node && _definitions.VISITOR_KEYS[node.type]);
}

},{"../definitions":"lTnnW"}],"b3BFn":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
exports.assertArrayExpression = assertArrayExpression;
exports.assertArrayPattern = assertArrayPattern;
exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
exports.assertAssignmentExpression = assertAssignmentExpression;
exports.assertAssignmentPattern = assertAssignmentPattern;
exports.assertAwaitExpression = assertAwaitExpression;
exports.assertBigIntLiteral = assertBigIntLiteral;
exports.assertBinary = assertBinary;
exports.assertBinaryExpression = assertBinaryExpression;
exports.assertBindExpression = assertBindExpression;
exports.assertBlock = assertBlock;
exports.assertBlockParent = assertBlockParent;
exports.assertBlockStatement = assertBlockStatement;
exports.assertBooleanLiteral = assertBooleanLiteral;
exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
exports.assertBreakStatement = assertBreakStatement;
exports.assertCallExpression = assertCallExpression;
exports.assertCatchClause = assertCatchClause;
exports.assertClass = assertClass;
exports.assertClassBody = assertClassBody;
exports.assertClassDeclaration = assertClassDeclaration;
exports.assertClassExpression = assertClassExpression;
exports.assertClassImplements = assertClassImplements;
exports.assertClassMethod = assertClassMethod;
exports.assertClassPrivateMethod = assertClassPrivateMethod;
exports.assertClassPrivateProperty = assertClassPrivateProperty;
exports.assertClassProperty = assertClassProperty;
exports.assertCompletionStatement = assertCompletionStatement;
exports.assertConditional = assertConditional;
exports.assertConditionalExpression = assertConditionalExpression;
exports.assertContinueStatement = assertContinueStatement;
exports.assertDebuggerStatement = assertDebuggerStatement;
exports.assertDecimalLiteral = assertDecimalLiteral;
exports.assertDeclaration = assertDeclaration;
exports.assertDeclareClass = assertDeclareClass;
exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
exports.assertDeclareFunction = assertDeclareFunction;
exports.assertDeclareInterface = assertDeclareInterface;
exports.assertDeclareModule = assertDeclareModule;
exports.assertDeclareModuleExports = assertDeclareModuleExports;
exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
exports.assertDeclareVariable = assertDeclareVariable;
exports.assertDeclaredPredicate = assertDeclaredPredicate;
exports.assertDecorator = assertDecorator;
exports.assertDirective = assertDirective;
exports.assertDirectiveLiteral = assertDirectiveLiteral;
exports.assertDoExpression = assertDoExpression;
exports.assertDoWhileStatement = assertDoWhileStatement;
exports.assertEmptyStatement = assertEmptyStatement;
exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
exports.assertEnumBody = assertEnumBody;
exports.assertEnumBooleanBody = assertEnumBooleanBody;
exports.assertEnumBooleanMember = assertEnumBooleanMember;
exports.assertEnumDeclaration = assertEnumDeclaration;
exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
exports.assertEnumMember = assertEnumMember;
exports.assertEnumNumberBody = assertEnumNumberBody;
exports.assertEnumNumberMember = assertEnumNumberMember;
exports.assertEnumStringBody = assertEnumStringBody;
exports.assertEnumStringMember = assertEnumStringMember;
exports.assertEnumSymbolBody = assertEnumSymbolBody;
exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
exports.assertExportAllDeclaration = assertExportAllDeclaration;
exports.assertExportDeclaration = assertExportDeclaration;
exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
exports.assertExportSpecifier = assertExportSpecifier;
exports.assertExpression = assertExpression;
exports.assertExpressionStatement = assertExpressionStatement;
exports.assertExpressionWrapper = assertExpressionWrapper;
exports.assertFile = assertFile;
exports.assertFlow = assertFlow;
exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
exports.assertFlowDeclaration = assertFlowDeclaration;
exports.assertFlowPredicate = assertFlowPredicate;
exports.assertFlowType = assertFlowType;
exports.assertFor = assertFor;
exports.assertForInStatement = assertForInStatement;
exports.assertForOfStatement = assertForOfStatement;
exports.assertForStatement = assertForStatement;
exports.assertForXStatement = assertForXStatement;
exports.assertFunction = assertFunction;
exports.assertFunctionDeclaration = assertFunctionDeclaration;
exports.assertFunctionExpression = assertFunctionExpression;
exports.assertFunctionParent = assertFunctionParent;
exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
exports.assertFunctionTypeParam = assertFunctionTypeParam;
exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
exports.assertIdentifier = assertIdentifier;
exports.assertIfStatement = assertIfStatement;
exports.assertImmutable = assertImmutable;
exports.assertImport = assertImport;
exports.assertImportAttribute = assertImportAttribute;
exports.assertImportDeclaration = assertImportDeclaration;
exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
exports.assertImportSpecifier = assertImportSpecifier;
exports.assertIndexedAccessType = assertIndexedAccessType;
exports.assertInferredPredicate = assertInferredPredicate;
exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
exports.assertInterfaceExtends = assertInterfaceExtends;
exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
exports.assertInterpreterDirective = assertInterpreterDirective;
exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
exports.assertJSX = assertJSX;
exports.assertJSXAttribute = assertJSXAttribute;
exports.assertJSXClosingElement = assertJSXClosingElement;
exports.assertJSXClosingFragment = assertJSXClosingFragment;
exports.assertJSXElement = assertJSXElement;
exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
exports.assertJSXFragment = assertJSXFragment;
exports.assertJSXIdentifier = assertJSXIdentifier;
exports.assertJSXMemberExpression = assertJSXMemberExpression;
exports.assertJSXNamespacedName = assertJSXNamespacedName;
exports.assertJSXOpeningElement = assertJSXOpeningElement;
exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
exports.assertJSXSpreadChild = assertJSXSpreadChild;
exports.assertJSXText = assertJSXText;
exports.assertLVal = assertLVal;
exports.assertLabeledStatement = assertLabeledStatement;
exports.assertLiteral = assertLiteral;
exports.assertLogicalExpression = assertLogicalExpression;
exports.assertLoop = assertLoop;
exports.assertMemberExpression = assertMemberExpression;
exports.assertMetaProperty = assertMetaProperty;
exports.assertMethod = assertMethod;
exports.assertMiscellaneous = assertMiscellaneous;
exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
exports.assertModuleDeclaration = assertModuleDeclaration;
exports.assertModuleExpression = assertModuleExpression;
exports.assertModuleSpecifier = assertModuleSpecifier;
exports.assertNewExpression = assertNewExpression;
exports.assertNoop = assertNoop;
exports.assertNullLiteral = assertNullLiteral;
exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
exports.assertNumberLiteral = assertNumberLiteral;
exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
exports.assertNumericLiteral = assertNumericLiteral;
exports.assertObjectExpression = assertObjectExpression;
exports.assertObjectMember = assertObjectMember;
exports.assertObjectMethod = assertObjectMethod;
exports.assertObjectPattern = assertObjectPattern;
exports.assertObjectProperty = assertObjectProperty;
exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
exports.assertObjectTypeProperty = assertObjectTypeProperty;
exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
exports.assertOpaqueType = assertOpaqueType;
exports.assertOptionalCallExpression = assertOptionalCallExpression;
exports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
exports.assertParenthesizedExpression = assertParenthesizedExpression;
exports.assertPattern = assertPattern;
exports.assertPatternLike = assertPatternLike;
exports.assertPipelineBareFunction = assertPipelineBareFunction;
exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
exports.assertPlaceholder = assertPlaceholder;
exports.assertPrivate = assertPrivate;
exports.assertPrivateName = assertPrivateName;
exports.assertProgram = assertProgram;
exports.assertProperty = assertProperty;
exports.assertPureish = assertPureish;
exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
exports.assertRecordExpression = assertRecordExpression;
exports.assertRegExpLiteral = assertRegExpLiteral;
exports.assertRegexLiteral = assertRegexLiteral;
exports.assertRestElement = assertRestElement;
exports.assertRestProperty = assertRestProperty;
exports.assertReturnStatement = assertReturnStatement;
exports.assertScopable = assertScopable;
exports.assertSequenceExpression = assertSequenceExpression;
exports.assertSpreadElement = assertSpreadElement;
exports.assertSpreadProperty = assertSpreadProperty;
exports.assertStandardized = assertStandardized;
exports.assertStatement = assertStatement;
exports.assertStaticBlock = assertStaticBlock;
exports.assertStringLiteral = assertStringLiteral;
exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
exports.assertSuper = assertSuper;
exports.assertSwitchCase = assertSwitchCase;
exports.assertSwitchStatement = assertSwitchStatement;
exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
exports.assertTSAnyKeyword = assertTSAnyKeyword;
exports.assertTSArrayType = assertTSArrayType;
exports.assertTSAsExpression = assertTSAsExpression;
exports.assertTSBaseType = assertTSBaseType;
exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
exports.assertTSConditionalType = assertTSConditionalType;
exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
exports.assertTSConstructorType = assertTSConstructorType;
exports.assertTSDeclareFunction = assertTSDeclareFunction;
exports.assertTSDeclareMethod = assertTSDeclareMethod;
exports.assertTSEntityName = assertTSEntityName;
exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
exports.assertTSEnumMember = assertTSEnumMember;
exports.assertTSExportAssignment = assertTSExportAssignment;
exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
exports.assertTSFunctionType = assertTSFunctionType;
exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
exports.assertTSImportType = assertTSImportType;
exports.assertTSIndexSignature = assertTSIndexSignature;
exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
exports.assertTSInferType = assertTSInferType;
exports.assertTSInterfaceBody = assertTSInterfaceBody;
exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
exports.assertTSIntersectionType = assertTSIntersectionType;
exports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
exports.assertTSLiteralType = assertTSLiteralType;
exports.assertTSMappedType = assertTSMappedType;
exports.assertTSMethodSignature = assertTSMethodSignature;
exports.assertTSModuleBlock = assertTSModuleBlock;
exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
exports.assertTSNamedTupleMember = assertTSNamedTupleMember;
exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
exports.assertTSNeverKeyword = assertTSNeverKeyword;
exports.assertTSNonNullExpression = assertTSNonNullExpression;
exports.assertTSNullKeyword = assertTSNullKeyword;
exports.assertTSNumberKeyword = assertTSNumberKeyword;
exports.assertTSObjectKeyword = assertTSObjectKeyword;
exports.assertTSOptionalType = assertTSOptionalType;
exports.assertTSParameterProperty = assertTSParameterProperty;
exports.assertTSParenthesizedType = assertTSParenthesizedType;
exports.assertTSPropertySignature = assertTSPropertySignature;
exports.assertTSQualifiedName = assertTSQualifiedName;
exports.assertTSRestType = assertTSRestType;
exports.assertTSStringKeyword = assertTSStringKeyword;
exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
exports.assertTSThisType = assertTSThisType;
exports.assertTSTupleType = assertTSTupleType;
exports.assertTSType = assertTSType;
exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
exports.assertTSTypeAssertion = assertTSTypeAssertion;
exports.assertTSTypeElement = assertTSTypeElement;
exports.assertTSTypeLiteral = assertTSTypeLiteral;
exports.assertTSTypeOperator = assertTSTypeOperator;
exports.assertTSTypeParameter = assertTSTypeParameter;
exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
exports.assertTSTypePredicate = assertTSTypePredicate;
exports.assertTSTypeQuery = assertTSTypeQuery;
exports.assertTSTypeReference = assertTSTypeReference;
exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
exports.assertTSUnionType = assertTSUnionType;
exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
exports.assertTSVoidKeyword = assertTSVoidKeyword;
exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
exports.assertTemplateElement = assertTemplateElement;
exports.assertTemplateLiteral = assertTemplateLiteral;
exports.assertTerminatorless = assertTerminatorless;
exports.assertThisExpression = assertThisExpression;
exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
exports.assertThrowStatement = assertThrowStatement;
exports.assertTopicReference = assertTopicReference;
exports.assertTryStatement = assertTryStatement;
exports.assertTupleExpression = assertTupleExpression;
exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
exports.assertTypeAlias = assertTypeAlias;
exports.assertTypeAnnotation = assertTypeAnnotation;
exports.assertTypeCastExpression = assertTypeCastExpression;
exports.assertTypeParameter = assertTypeParameter;
exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
exports.assertTypeScript = assertTypeScript;
exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
exports.assertUnaryExpression = assertUnaryExpression;
exports.assertUnaryLike = assertUnaryLike;
exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
exports.assertUpdateExpression = assertUpdateExpression;
exports.assertUserWhitespacable = assertUserWhitespacable;
exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
exports.assertVariableDeclaration = assertVariableDeclaration;
exports.assertVariableDeclarator = assertVariableDeclarator;
exports.assertVariance = assertVariance;
exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
exports.assertWhile = assertWhile;
exports.assertWhileStatement = assertWhileStatement;
exports.assertWithStatement = assertWithStatement;
exports.assertYieldExpression = assertYieldExpression;
var _is = require("../../validators/is");
function assert(type, node, opts) {
    if (!(0, _is.default)(type, node, opts)) throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, ` + `but instead got "${node.type}".`);
}
function assertArrayExpression(node, opts) {
    assert("ArrayExpression", node, opts);
}
function assertAssignmentExpression(node, opts) {
    assert("AssignmentExpression", node, opts);
}
function assertBinaryExpression(node, opts) {
    assert("BinaryExpression", node, opts);
}
function assertInterpreterDirective(node, opts) {
    assert("InterpreterDirective", node, opts);
}
function assertDirective(node, opts) {
    assert("Directive", node, opts);
}
function assertDirectiveLiteral(node, opts) {
    assert("DirectiveLiteral", node, opts);
}
function assertBlockStatement(node, opts) {
    assert("BlockStatement", node, opts);
}
function assertBreakStatement(node, opts) {
    assert("BreakStatement", node, opts);
}
function assertCallExpression(node, opts) {
    assert("CallExpression", node, opts);
}
function assertCatchClause(node, opts) {
    assert("CatchClause", node, opts);
}
function assertConditionalExpression(node, opts) {
    assert("ConditionalExpression", node, opts);
}
function assertContinueStatement(node, opts) {
    assert("ContinueStatement", node, opts);
}
function assertDebuggerStatement(node, opts) {
    assert("DebuggerStatement", node, opts);
}
function assertDoWhileStatement(node, opts) {
    assert("DoWhileStatement", node, opts);
}
function assertEmptyStatement(node, opts) {
    assert("EmptyStatement", node, opts);
}
function assertExpressionStatement(node, opts) {
    assert("ExpressionStatement", node, opts);
}
function assertFile(node, opts) {
    assert("File", node, opts);
}
function assertForInStatement(node, opts) {
    assert("ForInStatement", node, opts);
}
function assertForStatement(node, opts) {
    assert("ForStatement", node, opts);
}
function assertFunctionDeclaration(node, opts) {
    assert("FunctionDeclaration", node, opts);
}
function assertFunctionExpression(node, opts) {
    assert("FunctionExpression", node, opts);
}
function assertIdentifier(node, opts) {
    assert("Identifier", node, opts);
}
function assertIfStatement(node, opts) {
    assert("IfStatement", node, opts);
}
function assertLabeledStatement(node, opts) {
    assert("LabeledStatement", node, opts);
}
function assertStringLiteral(node, opts) {
    assert("StringLiteral", node, opts);
}
function assertNumericLiteral(node, opts) {
    assert("NumericLiteral", node, opts);
}
function assertNullLiteral(node, opts) {
    assert("NullLiteral", node, opts);
}
function assertBooleanLiteral(node, opts) {
    assert("BooleanLiteral", node, opts);
}
function assertRegExpLiteral(node, opts) {
    assert("RegExpLiteral", node, opts);
}
function assertLogicalExpression(node, opts) {
    assert("LogicalExpression", node, opts);
}
function assertMemberExpression(node, opts) {
    assert("MemberExpression", node, opts);
}
function assertNewExpression(node, opts) {
    assert("NewExpression", node, opts);
}
function assertProgram(node, opts) {
    assert("Program", node, opts);
}
function assertObjectExpression(node, opts) {
    assert("ObjectExpression", node, opts);
}
function assertObjectMethod(node, opts) {
    assert("ObjectMethod", node, opts);
}
function assertObjectProperty(node, opts) {
    assert("ObjectProperty", node, opts);
}
function assertRestElement(node, opts) {
    assert("RestElement", node, opts);
}
function assertReturnStatement(node, opts) {
    assert("ReturnStatement", node, opts);
}
function assertSequenceExpression(node, opts) {
    assert("SequenceExpression", node, opts);
}
function assertParenthesizedExpression(node, opts) {
    assert("ParenthesizedExpression", node, opts);
}
function assertSwitchCase(node, opts) {
    assert("SwitchCase", node, opts);
}
function assertSwitchStatement(node, opts) {
    assert("SwitchStatement", node, opts);
}
function assertThisExpression(node, opts) {
    assert("ThisExpression", node, opts);
}
function assertThrowStatement(node, opts) {
    assert("ThrowStatement", node, opts);
}
function assertTryStatement(node, opts) {
    assert("TryStatement", node, opts);
}
function assertUnaryExpression(node, opts) {
    assert("UnaryExpression", node, opts);
}
function assertUpdateExpression(node, opts) {
    assert("UpdateExpression", node, opts);
}
function assertVariableDeclaration(node, opts) {
    assert("VariableDeclaration", node, opts);
}
function assertVariableDeclarator(node, opts) {
    assert("VariableDeclarator", node, opts);
}
function assertWhileStatement(node, opts) {
    assert("WhileStatement", node, opts);
}
function assertWithStatement(node, opts) {
    assert("WithStatement", node, opts);
}
function assertAssignmentPattern(node, opts) {
    assert("AssignmentPattern", node, opts);
}
function assertArrayPattern(node, opts) {
    assert("ArrayPattern", node, opts);
}
function assertArrowFunctionExpression(node, opts) {
    assert("ArrowFunctionExpression", node, opts);
}
function assertClassBody(node, opts) {
    assert("ClassBody", node, opts);
}
function assertClassExpression(node, opts) {
    assert("ClassExpression", node, opts);
}
function assertClassDeclaration(node, opts) {
    assert("ClassDeclaration", node, opts);
}
function assertExportAllDeclaration(node, opts) {
    assert("ExportAllDeclaration", node, opts);
}
function assertExportDefaultDeclaration(node, opts) {
    assert("ExportDefaultDeclaration", node, opts);
}
function assertExportNamedDeclaration(node, opts) {
    assert("ExportNamedDeclaration", node, opts);
}
function assertExportSpecifier(node, opts) {
    assert("ExportSpecifier", node, opts);
}
function assertForOfStatement(node, opts) {
    assert("ForOfStatement", node, opts);
}
function assertImportDeclaration(node, opts) {
    assert("ImportDeclaration", node, opts);
}
function assertImportDefaultSpecifier(node, opts) {
    assert("ImportDefaultSpecifier", node, opts);
}
function assertImportNamespaceSpecifier(node, opts) {
    assert("ImportNamespaceSpecifier", node, opts);
}
function assertImportSpecifier(node, opts) {
    assert("ImportSpecifier", node, opts);
}
function assertMetaProperty(node, opts) {
    assert("MetaProperty", node, opts);
}
function assertClassMethod(node, opts) {
    assert("ClassMethod", node, opts);
}
function assertObjectPattern(node, opts) {
    assert("ObjectPattern", node, opts);
}
function assertSpreadElement(node, opts) {
    assert("SpreadElement", node, opts);
}
function assertSuper(node, opts) {
    assert("Super", node, opts);
}
function assertTaggedTemplateExpression(node, opts) {
    assert("TaggedTemplateExpression", node, opts);
}
function assertTemplateElement(node, opts) {
    assert("TemplateElement", node, opts);
}
function assertTemplateLiteral(node, opts) {
    assert("TemplateLiteral", node, opts);
}
function assertYieldExpression(node, opts) {
    assert("YieldExpression", node, opts);
}
function assertAwaitExpression(node, opts) {
    assert("AwaitExpression", node, opts);
}
function assertImport(node, opts) {
    assert("Import", node, opts);
}
function assertBigIntLiteral(node, opts) {
    assert("BigIntLiteral", node, opts);
}
function assertExportNamespaceSpecifier(node, opts) {
    assert("ExportNamespaceSpecifier", node, opts);
}
function assertOptionalMemberExpression(node, opts) {
    assert("OptionalMemberExpression", node, opts);
}
function assertOptionalCallExpression(node, opts) {
    assert("OptionalCallExpression", node, opts);
}
function assertClassProperty(node, opts) {
    assert("ClassProperty", node, opts);
}
function assertClassPrivateProperty(node, opts) {
    assert("ClassPrivateProperty", node, opts);
}
function assertClassPrivateMethod(node, opts) {
    assert("ClassPrivateMethod", node, opts);
}
function assertPrivateName(node, opts) {
    assert("PrivateName", node, opts);
}
function assertStaticBlock(node, opts) {
    assert("StaticBlock", node, opts);
}
function assertAnyTypeAnnotation(node, opts) {
    assert("AnyTypeAnnotation", node, opts);
}
function assertArrayTypeAnnotation(node, opts) {
    assert("ArrayTypeAnnotation", node, opts);
}
function assertBooleanTypeAnnotation(node, opts) {
    assert("BooleanTypeAnnotation", node, opts);
}
function assertBooleanLiteralTypeAnnotation(node, opts) {
    assert("BooleanLiteralTypeAnnotation", node, opts);
}
function assertNullLiteralTypeAnnotation(node, opts) {
    assert("NullLiteralTypeAnnotation", node, opts);
}
function assertClassImplements(node, opts) {
    assert("ClassImplements", node, opts);
}
function assertDeclareClass(node, opts) {
    assert("DeclareClass", node, opts);
}
function assertDeclareFunction(node, opts) {
    assert("DeclareFunction", node, opts);
}
function assertDeclareInterface(node, opts) {
    assert("DeclareInterface", node, opts);
}
function assertDeclareModule(node, opts) {
    assert("DeclareModule", node, opts);
}
function assertDeclareModuleExports(node, opts) {
    assert("DeclareModuleExports", node, opts);
}
function assertDeclareTypeAlias(node, opts) {
    assert("DeclareTypeAlias", node, opts);
}
function assertDeclareOpaqueType(node, opts) {
    assert("DeclareOpaqueType", node, opts);
}
function assertDeclareVariable(node, opts) {
    assert("DeclareVariable", node, opts);
}
function assertDeclareExportDeclaration(node, opts) {
    assert("DeclareExportDeclaration", node, opts);
}
function assertDeclareExportAllDeclaration(node, opts) {
    assert("DeclareExportAllDeclaration", node, opts);
}
function assertDeclaredPredicate(node, opts) {
    assert("DeclaredPredicate", node, opts);
}
function assertExistsTypeAnnotation(node, opts) {
    assert("ExistsTypeAnnotation", node, opts);
}
function assertFunctionTypeAnnotation(node, opts) {
    assert("FunctionTypeAnnotation", node, opts);
}
function assertFunctionTypeParam(node, opts) {
    assert("FunctionTypeParam", node, opts);
}
function assertGenericTypeAnnotation(node, opts) {
    assert("GenericTypeAnnotation", node, opts);
}
function assertInferredPredicate(node, opts) {
    assert("InferredPredicate", node, opts);
}
function assertInterfaceExtends(node, opts) {
    assert("InterfaceExtends", node, opts);
}
function assertInterfaceDeclaration(node, opts) {
    assert("InterfaceDeclaration", node, opts);
}
function assertInterfaceTypeAnnotation(node, opts) {
    assert("InterfaceTypeAnnotation", node, opts);
}
function assertIntersectionTypeAnnotation(node, opts) {
    assert("IntersectionTypeAnnotation", node, opts);
}
function assertMixedTypeAnnotation(node, opts) {
    assert("MixedTypeAnnotation", node, opts);
}
function assertEmptyTypeAnnotation(node, opts) {
    assert("EmptyTypeAnnotation", node, opts);
}
function assertNullableTypeAnnotation(node, opts) {
    assert("NullableTypeAnnotation", node, opts);
}
function assertNumberLiteralTypeAnnotation(node, opts) {
    assert("NumberLiteralTypeAnnotation", node, opts);
}
function assertNumberTypeAnnotation(node, opts) {
    assert("NumberTypeAnnotation", node, opts);
}
function assertObjectTypeAnnotation(node, opts) {
    assert("ObjectTypeAnnotation", node, opts);
}
function assertObjectTypeInternalSlot(node, opts) {
    assert("ObjectTypeInternalSlot", node, opts);
}
function assertObjectTypeCallProperty(node, opts) {
    assert("ObjectTypeCallProperty", node, opts);
}
function assertObjectTypeIndexer(node, opts) {
    assert("ObjectTypeIndexer", node, opts);
}
function assertObjectTypeProperty(node, opts) {
    assert("ObjectTypeProperty", node, opts);
}
function assertObjectTypeSpreadProperty(node, opts) {
    assert("ObjectTypeSpreadProperty", node, opts);
}
function assertOpaqueType(node, opts) {
    assert("OpaqueType", node, opts);
}
function assertQualifiedTypeIdentifier(node, opts) {
    assert("QualifiedTypeIdentifier", node, opts);
}
function assertStringLiteralTypeAnnotation(node, opts) {
    assert("StringLiteralTypeAnnotation", node, opts);
}
function assertStringTypeAnnotation(node, opts) {
    assert("StringTypeAnnotation", node, opts);
}
function assertSymbolTypeAnnotation(node, opts) {
    assert("SymbolTypeAnnotation", node, opts);
}
function assertThisTypeAnnotation(node, opts) {
    assert("ThisTypeAnnotation", node, opts);
}
function assertTupleTypeAnnotation(node, opts) {
    assert("TupleTypeAnnotation", node, opts);
}
function assertTypeofTypeAnnotation(node, opts) {
    assert("TypeofTypeAnnotation", node, opts);
}
function assertTypeAlias(node, opts) {
    assert("TypeAlias", node, opts);
}
function assertTypeAnnotation(node, opts) {
    assert("TypeAnnotation", node, opts);
}
function assertTypeCastExpression(node, opts) {
    assert("TypeCastExpression", node, opts);
}
function assertTypeParameter(node, opts) {
    assert("TypeParameter", node, opts);
}
function assertTypeParameterDeclaration(node, opts) {
    assert("TypeParameterDeclaration", node, opts);
}
function assertTypeParameterInstantiation(node, opts) {
    assert("TypeParameterInstantiation", node, opts);
}
function assertUnionTypeAnnotation(node, opts) {
    assert("UnionTypeAnnotation", node, opts);
}
function assertVariance(node, opts) {
    assert("Variance", node, opts);
}
function assertVoidTypeAnnotation(node, opts) {
    assert("VoidTypeAnnotation", node, opts);
}
function assertEnumDeclaration(node, opts) {
    assert("EnumDeclaration", node, opts);
}
function assertEnumBooleanBody(node, opts) {
    assert("EnumBooleanBody", node, opts);
}
function assertEnumNumberBody(node, opts) {
    assert("EnumNumberBody", node, opts);
}
function assertEnumStringBody(node, opts) {
    assert("EnumStringBody", node, opts);
}
function assertEnumSymbolBody(node, opts) {
    assert("EnumSymbolBody", node, opts);
}
function assertEnumBooleanMember(node, opts) {
    assert("EnumBooleanMember", node, opts);
}
function assertEnumNumberMember(node, opts) {
    assert("EnumNumberMember", node, opts);
}
function assertEnumStringMember(node, opts) {
    assert("EnumStringMember", node, opts);
}
function assertEnumDefaultedMember(node, opts) {
    assert("EnumDefaultedMember", node, opts);
}
function assertIndexedAccessType(node, opts) {
    assert("IndexedAccessType", node, opts);
}
function assertOptionalIndexedAccessType(node, opts) {
    assert("OptionalIndexedAccessType", node, opts);
}
function assertJSXAttribute(node, opts) {
    assert("JSXAttribute", node, opts);
}
function assertJSXClosingElement(node, opts) {
    assert("JSXClosingElement", node, opts);
}
function assertJSXElement(node, opts) {
    assert("JSXElement", node, opts);
}
function assertJSXEmptyExpression(node, opts) {
    assert("JSXEmptyExpression", node, opts);
}
function assertJSXExpressionContainer(node, opts) {
    assert("JSXExpressionContainer", node, opts);
}
function assertJSXSpreadChild(node, opts) {
    assert("JSXSpreadChild", node, opts);
}
function assertJSXIdentifier(node, opts) {
    assert("JSXIdentifier", node, opts);
}
function assertJSXMemberExpression(node, opts) {
    assert("JSXMemberExpression", node, opts);
}
function assertJSXNamespacedName(node, opts) {
    assert("JSXNamespacedName", node, opts);
}
function assertJSXOpeningElement(node, opts) {
    assert("JSXOpeningElement", node, opts);
}
function assertJSXSpreadAttribute(node, opts) {
    assert("JSXSpreadAttribute", node, opts);
}
function assertJSXText(node, opts) {
    assert("JSXText", node, opts);
}
function assertJSXFragment(node, opts) {
    assert("JSXFragment", node, opts);
}
function assertJSXOpeningFragment(node, opts) {
    assert("JSXOpeningFragment", node, opts);
}
function assertJSXClosingFragment(node, opts) {
    assert("JSXClosingFragment", node, opts);
}
function assertNoop(node, opts) {
    assert("Noop", node, opts);
}
function assertPlaceholder(node, opts) {
    assert("Placeholder", node, opts);
}
function assertV8IntrinsicIdentifier(node, opts) {
    assert("V8IntrinsicIdentifier", node, opts);
}
function assertArgumentPlaceholder(node, opts) {
    assert("ArgumentPlaceholder", node, opts);
}
function assertBindExpression(node, opts) {
    assert("BindExpression", node, opts);
}
function assertImportAttribute(node, opts) {
    assert("ImportAttribute", node, opts);
}
function assertDecorator(node, opts) {
    assert("Decorator", node, opts);
}
function assertDoExpression(node, opts) {
    assert("DoExpression", node, opts);
}
function assertExportDefaultSpecifier(node, opts) {
    assert("ExportDefaultSpecifier", node, opts);
}
function assertRecordExpression(node, opts) {
    assert("RecordExpression", node, opts);
}
function assertTupleExpression(node, opts) {
    assert("TupleExpression", node, opts);
}
function assertDecimalLiteral(node, opts) {
    assert("DecimalLiteral", node, opts);
}
function assertModuleExpression(node, opts) {
    assert("ModuleExpression", node, opts);
}
function assertTopicReference(node, opts) {
    assert("TopicReference", node, opts);
}
function assertPipelineTopicExpression(node, opts) {
    assert("PipelineTopicExpression", node, opts);
}
function assertPipelineBareFunction(node, opts) {
    assert("PipelineBareFunction", node, opts);
}
function assertPipelinePrimaryTopicReference(node, opts) {
    assert("PipelinePrimaryTopicReference", node, opts);
}
function assertTSParameterProperty(node, opts) {
    assert("TSParameterProperty", node, opts);
}
function assertTSDeclareFunction(node, opts) {
    assert("TSDeclareFunction", node, opts);
}
function assertTSDeclareMethod(node, opts) {
    assert("TSDeclareMethod", node, opts);
}
function assertTSQualifiedName(node, opts) {
    assert("TSQualifiedName", node, opts);
}
function assertTSCallSignatureDeclaration(node, opts) {
    assert("TSCallSignatureDeclaration", node, opts);
}
function assertTSConstructSignatureDeclaration(node, opts) {
    assert("TSConstructSignatureDeclaration", node, opts);
}
function assertTSPropertySignature(node, opts) {
    assert("TSPropertySignature", node, opts);
}
function assertTSMethodSignature(node, opts) {
    assert("TSMethodSignature", node, opts);
}
function assertTSIndexSignature(node, opts) {
    assert("TSIndexSignature", node, opts);
}
function assertTSAnyKeyword(node, opts) {
    assert("TSAnyKeyword", node, opts);
}
function assertTSBooleanKeyword(node, opts) {
    assert("TSBooleanKeyword", node, opts);
}
function assertTSBigIntKeyword(node, opts) {
    assert("TSBigIntKeyword", node, opts);
}
function assertTSIntrinsicKeyword(node, opts) {
    assert("TSIntrinsicKeyword", node, opts);
}
function assertTSNeverKeyword(node, opts) {
    assert("TSNeverKeyword", node, opts);
}
function assertTSNullKeyword(node, opts) {
    assert("TSNullKeyword", node, opts);
}
function assertTSNumberKeyword(node, opts) {
    assert("TSNumberKeyword", node, opts);
}
function assertTSObjectKeyword(node, opts) {
    assert("TSObjectKeyword", node, opts);
}
function assertTSStringKeyword(node, opts) {
    assert("TSStringKeyword", node, opts);
}
function assertTSSymbolKeyword(node, opts) {
    assert("TSSymbolKeyword", node, opts);
}
function assertTSUndefinedKeyword(node, opts) {
    assert("TSUndefinedKeyword", node, opts);
}
function assertTSUnknownKeyword(node, opts) {
    assert("TSUnknownKeyword", node, opts);
}
function assertTSVoidKeyword(node, opts) {
    assert("TSVoidKeyword", node, opts);
}
function assertTSThisType(node, opts) {
    assert("TSThisType", node, opts);
}
function assertTSFunctionType(node, opts) {
    assert("TSFunctionType", node, opts);
}
function assertTSConstructorType(node, opts) {
    assert("TSConstructorType", node, opts);
}
function assertTSTypeReference(node, opts) {
    assert("TSTypeReference", node, opts);
}
function assertTSTypePredicate(node, opts) {
    assert("TSTypePredicate", node, opts);
}
function assertTSTypeQuery(node, opts) {
    assert("TSTypeQuery", node, opts);
}
function assertTSTypeLiteral(node, opts) {
    assert("TSTypeLiteral", node, opts);
}
function assertTSArrayType(node, opts) {
    assert("TSArrayType", node, opts);
}
function assertTSTupleType(node, opts) {
    assert("TSTupleType", node, opts);
}
function assertTSOptionalType(node, opts) {
    assert("TSOptionalType", node, opts);
}
function assertTSRestType(node, opts) {
    assert("TSRestType", node, opts);
}
function assertTSNamedTupleMember(node, opts) {
    assert("TSNamedTupleMember", node, opts);
}
function assertTSUnionType(node, opts) {
    assert("TSUnionType", node, opts);
}
function assertTSIntersectionType(node, opts) {
    assert("TSIntersectionType", node, opts);
}
function assertTSConditionalType(node, opts) {
    assert("TSConditionalType", node, opts);
}
function assertTSInferType(node, opts) {
    assert("TSInferType", node, opts);
}
function assertTSParenthesizedType(node, opts) {
    assert("TSParenthesizedType", node, opts);
}
function assertTSTypeOperator(node, opts) {
    assert("TSTypeOperator", node, opts);
}
function assertTSIndexedAccessType(node, opts) {
    assert("TSIndexedAccessType", node, opts);
}
function assertTSMappedType(node, opts) {
    assert("TSMappedType", node, opts);
}
function assertTSLiteralType(node, opts) {
    assert("TSLiteralType", node, opts);
}
function assertTSExpressionWithTypeArguments(node, opts) {
    assert("TSExpressionWithTypeArguments", node, opts);
}
function assertTSInterfaceDeclaration(node, opts) {
    assert("TSInterfaceDeclaration", node, opts);
}
function assertTSInterfaceBody(node, opts) {
    assert("TSInterfaceBody", node, opts);
}
function assertTSTypeAliasDeclaration(node, opts) {
    assert("TSTypeAliasDeclaration", node, opts);
}
function assertTSAsExpression(node, opts) {
    assert("TSAsExpression", node, opts);
}
function assertTSTypeAssertion(node, opts) {
    assert("TSTypeAssertion", node, opts);
}
function assertTSEnumDeclaration(node, opts) {
    assert("TSEnumDeclaration", node, opts);
}
function assertTSEnumMember(node, opts) {
    assert("TSEnumMember", node, opts);
}
function assertTSModuleDeclaration(node, opts) {
    assert("TSModuleDeclaration", node, opts);
}
function assertTSModuleBlock(node, opts) {
    assert("TSModuleBlock", node, opts);
}
function assertTSImportType(node, opts) {
    assert("TSImportType", node, opts);
}
function assertTSImportEqualsDeclaration(node, opts) {
    assert("TSImportEqualsDeclaration", node, opts);
}
function assertTSExternalModuleReference(node, opts) {
    assert("TSExternalModuleReference", node, opts);
}
function assertTSNonNullExpression(node, opts) {
    assert("TSNonNullExpression", node, opts);
}
function assertTSExportAssignment(node, opts) {
    assert("TSExportAssignment", node, opts);
}
function assertTSNamespaceExportDeclaration(node, opts) {
    assert("TSNamespaceExportDeclaration", node, opts);
}
function assertTSTypeAnnotation(node, opts) {
    assert("TSTypeAnnotation", node, opts);
}
function assertTSTypeParameterInstantiation(node, opts) {
    assert("TSTypeParameterInstantiation", node, opts);
}
function assertTSTypeParameterDeclaration(node, opts) {
    assert("TSTypeParameterDeclaration", node, opts);
}
function assertTSTypeParameter(node, opts) {
    assert("TSTypeParameter", node, opts);
}
function assertStandardized(node, opts) {
    assert("Standardized", node, opts);
}
function assertExpression(node, opts) {
    assert("Expression", node, opts);
}
function assertBinary(node, opts) {
    assert("Binary", node, opts);
}
function assertScopable(node, opts) {
    assert("Scopable", node, opts);
}
function assertBlockParent(node, opts) {
    assert("BlockParent", node, opts);
}
function assertBlock(node, opts) {
    assert("Block", node, opts);
}
function assertStatement(node, opts) {
    assert("Statement", node, opts);
}
function assertTerminatorless(node, opts) {
    assert("Terminatorless", node, opts);
}
function assertCompletionStatement(node, opts) {
    assert("CompletionStatement", node, opts);
}
function assertConditional(node, opts) {
    assert("Conditional", node, opts);
}
function assertLoop(node, opts) {
    assert("Loop", node, opts);
}
function assertWhile(node, opts) {
    assert("While", node, opts);
}
function assertExpressionWrapper(node, opts) {
    assert("ExpressionWrapper", node, opts);
}
function assertFor(node, opts) {
    assert("For", node, opts);
}
function assertForXStatement(node, opts) {
    assert("ForXStatement", node, opts);
}
function assertFunction(node, opts) {
    assert("Function", node, opts);
}
function assertFunctionParent(node, opts) {
    assert("FunctionParent", node, opts);
}
function assertPureish(node, opts) {
    assert("Pureish", node, opts);
}
function assertDeclaration(node, opts) {
    assert("Declaration", node, opts);
}
function assertPatternLike(node, opts) {
    assert("PatternLike", node, opts);
}
function assertLVal(node, opts) {
    assert("LVal", node, opts);
}
function assertTSEntityName(node, opts) {
    assert("TSEntityName", node, opts);
}
function assertLiteral(node, opts) {
    assert("Literal", node, opts);
}
function assertImmutable(node, opts) {
    assert("Immutable", node, opts);
}
function assertUserWhitespacable(node, opts) {
    assert("UserWhitespacable", node, opts);
}
function assertMethod(node, opts) {
    assert("Method", node, opts);
}
function assertObjectMember(node, opts) {
    assert("ObjectMember", node, opts);
}
function assertProperty(node, opts) {
    assert("Property", node, opts);
}
function assertUnaryLike(node, opts) {
    assert("UnaryLike", node, opts);
}
function assertPattern(node, opts) {
    assert("Pattern", node, opts);
}
function assertClass(node, opts) {
    assert("Class", node, opts);
}
function assertModuleDeclaration(node, opts) {
    assert("ModuleDeclaration", node, opts);
}
function assertExportDeclaration(node, opts) {
    assert("ExportDeclaration", node, opts);
}
function assertModuleSpecifier(node, opts) {
    assert("ModuleSpecifier", node, opts);
}
function assertPrivate(node, opts) {
    assert("Private", node, opts);
}
function assertFlow(node, opts) {
    assert("Flow", node, opts);
}
function assertFlowType(node, opts) {
    assert("FlowType", node, opts);
}
function assertFlowBaseAnnotation(node, opts) {
    assert("FlowBaseAnnotation", node, opts);
}
function assertFlowDeclaration(node, opts) {
    assert("FlowDeclaration", node, opts);
}
function assertFlowPredicate(node, opts) {
    assert("FlowPredicate", node, opts);
}
function assertEnumBody(node, opts) {
    assert("EnumBody", node, opts);
}
function assertEnumMember(node, opts) {
    assert("EnumMember", node, opts);
}
function assertJSX(node, opts) {
    assert("JSX", node, opts);
}
function assertMiscellaneous(node, opts) {
    assert("Miscellaneous", node, opts);
}
function assertTypeScript(node, opts) {
    assert("TypeScript", node, opts);
}
function assertTSTypeElement(node, opts) {
    assert("TSTypeElement", node, opts);
}
function assertTSType(node, opts) {
    assert("TSType", node, opts);
}
function assertTSBaseType(node, opts) {
    assert("TSBaseType", node, opts);
}
function assertNumberLiteral(node, opts) {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
    assert("NumberLiteral", node, opts);
}
function assertRegexLiteral(node, opts) {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
    assert("RegexLiteral", node, opts);
}
function assertRestProperty(node, opts) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    assert("RestProperty", node, opts);
}
function assertSpreadProperty(node, opts) {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");
    assert("SpreadProperty", node, opts);
}

},{"../../validators/is":"hT8C8"}],"c7Cgb":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _generated = require("../generated");
var _default = createTypeAnnotationBasedOnTypeof;
exports.default = _default;
function createTypeAnnotationBasedOnTypeof(type) {
    switch(type){
        case "string":
            return (0, _generated.stringTypeAnnotation)();
        case "number":
            return (0, _generated.numberTypeAnnotation)();
        case "undefined":
            return (0, _generated.voidTypeAnnotation)();
        case "boolean":
            return (0, _generated.booleanTypeAnnotation)();
        case "function":
            return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));
        case "object":
            return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));
        case "symbol":
            return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));
        case "bigint":
            return (0, _generated.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + type);
}

},{"../generated":"1bIPZ"}],"jseCf":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = createFlowUnionType;
var _generated = require("../generated");
var _removeTypeDuplicates = require("../../modifications/flow/removeTypeDuplicates");
function createFlowUnionType(types) {
    const flattened = (0, _removeTypeDuplicates.default)(types);
    if (flattened.length === 1) return flattened[0];
    else return (0, _generated.unionTypeAnnotation)(flattened);
}

},{"../generated":"1bIPZ","../../modifications/flow/removeTypeDuplicates":"7ENKW"}],"7ENKW":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removeTypeDuplicates;
var _generated = require("../../validators/generated");
function getQualifiedName(node) {
    return (0, _generated.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
}
function removeTypeDuplicates(nodes) {
    const generics = {};
    const bases = {};
    const typeGroups = new Set();
    const types = [];
    for(let i = 0; i < nodes.length; i++){
        const node = nodes[i];
        if (!node) continue;
        if (types.indexOf(node) >= 0) continue;
        if ((0, _generated.isAnyTypeAnnotation)(node)) return [
            node
        ];
        if ((0, _generated.isFlowBaseAnnotation)(node)) {
            bases[node.type] = node;
            continue;
        }
        if ((0, _generated.isUnionTypeAnnotation)(node)) {
            if (!typeGroups.has(node.types)) {
                nodes = nodes.concat(node.types);
                typeGroups.add(node.types);
            }
            continue;
        }
        if ((0, _generated.isGenericTypeAnnotation)(node)) {
            const name = getQualifiedName(node.id);
            if (generics[name]) {
                let existing = generics[name];
                if (existing.typeParameters) {
                    if (node.typeParameters) existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
                } else existing = node.typeParameters;
            } else generics[name] = node;
            continue;
        }
        types.push(node);
    }
    for (const type of Object.keys(bases))types.push(bases[type]);
    for (const name of Object.keys(generics))types.push(generics[name]);
    return types;
}

},{"../../validators/generated":"cfCci"}],"4SK0U":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = createTSUnionType;
var _generated = require("../generated");
var _removeTypeDuplicates = require("../../modifications/typescript/removeTypeDuplicates");
function createTSUnionType(typeAnnotations) {
    const types = typeAnnotations.map((type)=>type.typeAnnotation
    );
    const flattened = (0, _removeTypeDuplicates.default)(types);
    if (flattened.length === 1) return flattened[0];
    else return (0, _generated.tsUnionType)(flattened);
}

},{"../generated":"1bIPZ","../../modifications/typescript/removeTypeDuplicates":"9pzrX"}],"9pzrX":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removeTypeDuplicates;
var _generated = require("../../validators/generated");
function removeTypeDuplicates(nodes) {
    const generics = {};
    const bases = {};
    const typeGroups = new Set();
    const types = [];
    for(let i = 0; i < nodes.length; i++){
        const node = nodes[i];
        if (!node) continue;
        if (types.indexOf(node) >= 0) continue;
        if ((0, _generated.isTSAnyKeyword)(node)) return [
            node
        ];
        if ((0, _generated.isTSBaseType)(node)) {
            bases[node.type] = node;
            continue;
        }
        if ((0, _generated.isTSUnionType)(node)) {
            if (!typeGroups.has(node.types)) {
                nodes.push(...node.types);
                typeGroups.add(node.types);
            }
            continue;
        }
        types.push(node);
    }
    for (const type of Object.keys(bases))types.push(bases[type]);
    for (const name of Object.keys(generics))types.push(generics[name]);
    return types;
}

},{"../../validators/generated":"cfCci"}],"c1H7g":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "AnyTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.anyTypeAnnotation;
    }
});
Object.defineProperty(exports, "ArgumentPlaceholder", {
    enumerable: true,
    get: function() {
        return _index.argumentPlaceholder;
    }
});
Object.defineProperty(exports, "ArrayExpression", {
    enumerable: true,
    get: function() {
        return _index.arrayExpression;
    }
});
Object.defineProperty(exports, "ArrayPattern", {
    enumerable: true,
    get: function() {
        return _index.arrayPattern;
    }
});
Object.defineProperty(exports, "ArrayTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.arrayTypeAnnotation;
    }
});
Object.defineProperty(exports, "ArrowFunctionExpression", {
    enumerable: true,
    get: function() {
        return _index.arrowFunctionExpression;
    }
});
Object.defineProperty(exports, "AssignmentExpression", {
    enumerable: true,
    get: function() {
        return _index.assignmentExpression;
    }
});
Object.defineProperty(exports, "AssignmentPattern", {
    enumerable: true,
    get: function() {
        return _index.assignmentPattern;
    }
});
Object.defineProperty(exports, "AwaitExpression", {
    enumerable: true,
    get: function() {
        return _index.awaitExpression;
    }
});
Object.defineProperty(exports, "BigIntLiteral", {
    enumerable: true,
    get: function() {
        return _index.bigIntLiteral;
    }
});
Object.defineProperty(exports, "BinaryExpression", {
    enumerable: true,
    get: function() {
        return _index.binaryExpression;
    }
});
Object.defineProperty(exports, "BindExpression", {
    enumerable: true,
    get: function() {
        return _index.bindExpression;
    }
});
Object.defineProperty(exports, "BlockStatement", {
    enumerable: true,
    get: function() {
        return _index.blockStatement;
    }
});
Object.defineProperty(exports, "BooleanLiteral", {
    enumerable: true,
    get: function() {
        return _index.booleanLiteral;
    }
});
Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.booleanLiteralTypeAnnotation;
    }
});
Object.defineProperty(exports, "BooleanTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.booleanTypeAnnotation;
    }
});
Object.defineProperty(exports, "BreakStatement", {
    enumerable: true,
    get: function() {
        return _index.breakStatement;
    }
});
Object.defineProperty(exports, "CallExpression", {
    enumerable: true,
    get: function() {
        return _index.callExpression;
    }
});
Object.defineProperty(exports, "CatchClause", {
    enumerable: true,
    get: function() {
        return _index.catchClause;
    }
});
Object.defineProperty(exports, "ClassBody", {
    enumerable: true,
    get: function() {
        return _index.classBody;
    }
});
Object.defineProperty(exports, "ClassDeclaration", {
    enumerable: true,
    get: function() {
        return _index.classDeclaration;
    }
});
Object.defineProperty(exports, "ClassExpression", {
    enumerable: true,
    get: function() {
        return _index.classExpression;
    }
});
Object.defineProperty(exports, "ClassImplements", {
    enumerable: true,
    get: function() {
        return _index.classImplements;
    }
});
Object.defineProperty(exports, "ClassMethod", {
    enumerable: true,
    get: function() {
        return _index.classMethod;
    }
});
Object.defineProperty(exports, "ClassPrivateMethod", {
    enumerable: true,
    get: function() {
        return _index.classPrivateMethod;
    }
});
Object.defineProperty(exports, "ClassPrivateProperty", {
    enumerable: true,
    get: function() {
        return _index.classPrivateProperty;
    }
});
Object.defineProperty(exports, "ClassProperty", {
    enumerable: true,
    get: function() {
        return _index.classProperty;
    }
});
Object.defineProperty(exports, "ConditionalExpression", {
    enumerable: true,
    get: function() {
        return _index.conditionalExpression;
    }
});
Object.defineProperty(exports, "ContinueStatement", {
    enumerable: true,
    get: function() {
        return _index.continueStatement;
    }
});
Object.defineProperty(exports, "DebuggerStatement", {
    enumerable: true,
    get: function() {
        return _index.debuggerStatement;
    }
});
Object.defineProperty(exports, "DecimalLiteral", {
    enumerable: true,
    get: function() {
        return _index.decimalLiteral;
    }
});
Object.defineProperty(exports, "DeclareClass", {
    enumerable: true,
    get: function() {
        return _index.declareClass;
    }
});
Object.defineProperty(exports, "DeclareExportAllDeclaration", {
    enumerable: true,
    get: function() {
        return _index.declareExportAllDeclaration;
    }
});
Object.defineProperty(exports, "DeclareExportDeclaration", {
    enumerable: true,
    get: function() {
        return _index.declareExportDeclaration;
    }
});
Object.defineProperty(exports, "DeclareFunction", {
    enumerable: true,
    get: function() {
        return _index.declareFunction;
    }
});
Object.defineProperty(exports, "DeclareInterface", {
    enumerable: true,
    get: function() {
        return _index.declareInterface;
    }
});
Object.defineProperty(exports, "DeclareModule", {
    enumerable: true,
    get: function() {
        return _index.declareModule;
    }
});
Object.defineProperty(exports, "DeclareModuleExports", {
    enumerable: true,
    get: function() {
        return _index.declareModuleExports;
    }
});
Object.defineProperty(exports, "DeclareOpaqueType", {
    enumerable: true,
    get: function() {
        return _index.declareOpaqueType;
    }
});
Object.defineProperty(exports, "DeclareTypeAlias", {
    enumerable: true,
    get: function() {
        return _index.declareTypeAlias;
    }
});
Object.defineProperty(exports, "DeclareVariable", {
    enumerable: true,
    get: function() {
        return _index.declareVariable;
    }
});
Object.defineProperty(exports, "DeclaredPredicate", {
    enumerable: true,
    get: function() {
        return _index.declaredPredicate;
    }
});
Object.defineProperty(exports, "Decorator", {
    enumerable: true,
    get: function() {
        return _index.decorator;
    }
});
Object.defineProperty(exports, "Directive", {
    enumerable: true,
    get: function() {
        return _index.directive;
    }
});
Object.defineProperty(exports, "DirectiveLiteral", {
    enumerable: true,
    get: function() {
        return _index.directiveLiteral;
    }
});
Object.defineProperty(exports, "DoExpression", {
    enumerable: true,
    get: function() {
        return _index.doExpression;
    }
});
Object.defineProperty(exports, "DoWhileStatement", {
    enumerable: true,
    get: function() {
        return _index.doWhileStatement;
    }
});
Object.defineProperty(exports, "EmptyStatement", {
    enumerable: true,
    get: function() {
        return _index.emptyStatement;
    }
});
Object.defineProperty(exports, "EmptyTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.emptyTypeAnnotation;
    }
});
Object.defineProperty(exports, "EnumBooleanBody", {
    enumerable: true,
    get: function() {
        return _index.enumBooleanBody;
    }
});
Object.defineProperty(exports, "EnumBooleanMember", {
    enumerable: true,
    get: function() {
        return _index.enumBooleanMember;
    }
});
Object.defineProperty(exports, "EnumDeclaration", {
    enumerable: true,
    get: function() {
        return _index.enumDeclaration;
    }
});
Object.defineProperty(exports, "EnumDefaultedMember", {
    enumerable: true,
    get: function() {
        return _index.enumDefaultedMember;
    }
});
Object.defineProperty(exports, "EnumNumberBody", {
    enumerable: true,
    get: function() {
        return _index.enumNumberBody;
    }
});
Object.defineProperty(exports, "EnumNumberMember", {
    enumerable: true,
    get: function() {
        return _index.enumNumberMember;
    }
});
Object.defineProperty(exports, "EnumStringBody", {
    enumerable: true,
    get: function() {
        return _index.enumStringBody;
    }
});
Object.defineProperty(exports, "EnumStringMember", {
    enumerable: true,
    get: function() {
        return _index.enumStringMember;
    }
});
Object.defineProperty(exports, "EnumSymbolBody", {
    enumerable: true,
    get: function() {
        return _index.enumSymbolBody;
    }
});
Object.defineProperty(exports, "ExistsTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.existsTypeAnnotation;
    }
});
Object.defineProperty(exports, "ExportAllDeclaration", {
    enumerable: true,
    get: function() {
        return _index.exportAllDeclaration;
    }
});
Object.defineProperty(exports, "ExportDefaultDeclaration", {
    enumerable: true,
    get: function() {
        return _index.exportDefaultDeclaration;
    }
});
Object.defineProperty(exports, "ExportDefaultSpecifier", {
    enumerable: true,
    get: function() {
        return _index.exportDefaultSpecifier;
    }
});
Object.defineProperty(exports, "ExportNamedDeclaration", {
    enumerable: true,
    get: function() {
        return _index.exportNamedDeclaration;
    }
});
Object.defineProperty(exports, "ExportNamespaceSpecifier", {
    enumerable: true,
    get: function() {
        return _index.exportNamespaceSpecifier;
    }
});
Object.defineProperty(exports, "ExportSpecifier", {
    enumerable: true,
    get: function() {
        return _index.exportSpecifier;
    }
});
Object.defineProperty(exports, "ExpressionStatement", {
    enumerable: true,
    get: function() {
        return _index.expressionStatement;
    }
});
Object.defineProperty(exports, "File", {
    enumerable: true,
    get: function() {
        return _index.file;
    }
});
Object.defineProperty(exports, "ForInStatement", {
    enumerable: true,
    get: function() {
        return _index.forInStatement;
    }
});
Object.defineProperty(exports, "ForOfStatement", {
    enumerable: true,
    get: function() {
        return _index.forOfStatement;
    }
});
Object.defineProperty(exports, "ForStatement", {
    enumerable: true,
    get: function() {
        return _index.forStatement;
    }
});
Object.defineProperty(exports, "FunctionDeclaration", {
    enumerable: true,
    get: function() {
        return _index.functionDeclaration;
    }
});
Object.defineProperty(exports, "FunctionExpression", {
    enumerable: true,
    get: function() {
        return _index.functionExpression;
    }
});
Object.defineProperty(exports, "FunctionTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.functionTypeAnnotation;
    }
});
Object.defineProperty(exports, "FunctionTypeParam", {
    enumerable: true,
    get: function() {
        return _index.functionTypeParam;
    }
});
Object.defineProperty(exports, "GenericTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.genericTypeAnnotation;
    }
});
Object.defineProperty(exports, "Identifier", {
    enumerable: true,
    get: function() {
        return _index.identifier;
    }
});
Object.defineProperty(exports, "IfStatement", {
    enumerable: true,
    get: function() {
        return _index.ifStatement;
    }
});
Object.defineProperty(exports, "Import", {
    enumerable: true,
    get: function() {
        return _index.import;
    }
});
Object.defineProperty(exports, "ImportAttribute", {
    enumerable: true,
    get: function() {
        return _index.importAttribute;
    }
});
Object.defineProperty(exports, "ImportDeclaration", {
    enumerable: true,
    get: function() {
        return _index.importDeclaration;
    }
});
Object.defineProperty(exports, "ImportDefaultSpecifier", {
    enumerable: true,
    get: function() {
        return _index.importDefaultSpecifier;
    }
});
Object.defineProperty(exports, "ImportNamespaceSpecifier", {
    enumerable: true,
    get: function() {
        return _index.importNamespaceSpecifier;
    }
});
Object.defineProperty(exports, "ImportSpecifier", {
    enumerable: true,
    get: function() {
        return _index.importSpecifier;
    }
});
Object.defineProperty(exports, "IndexedAccessType", {
    enumerable: true,
    get: function() {
        return _index.indexedAccessType;
    }
});
Object.defineProperty(exports, "InferredPredicate", {
    enumerable: true,
    get: function() {
        return _index.inferredPredicate;
    }
});
Object.defineProperty(exports, "InterfaceDeclaration", {
    enumerable: true,
    get: function() {
        return _index.interfaceDeclaration;
    }
});
Object.defineProperty(exports, "InterfaceExtends", {
    enumerable: true,
    get: function() {
        return _index.interfaceExtends;
    }
});
Object.defineProperty(exports, "InterfaceTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.interfaceTypeAnnotation;
    }
});
Object.defineProperty(exports, "InterpreterDirective", {
    enumerable: true,
    get: function() {
        return _index.interpreterDirective;
    }
});
Object.defineProperty(exports, "IntersectionTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.intersectionTypeAnnotation;
    }
});
Object.defineProperty(exports, "JSXAttribute", {
    enumerable: true,
    get: function() {
        return _index.jsxAttribute;
    }
});
Object.defineProperty(exports, "JSXClosingElement", {
    enumerable: true,
    get: function() {
        return _index.jsxClosingElement;
    }
});
Object.defineProperty(exports, "JSXClosingFragment", {
    enumerable: true,
    get: function() {
        return _index.jsxClosingFragment;
    }
});
Object.defineProperty(exports, "JSXElement", {
    enumerable: true,
    get: function() {
        return _index.jsxElement;
    }
});
Object.defineProperty(exports, "JSXEmptyExpression", {
    enumerable: true,
    get: function() {
        return _index.jsxEmptyExpression;
    }
});
Object.defineProperty(exports, "JSXExpressionContainer", {
    enumerable: true,
    get: function() {
        return _index.jsxExpressionContainer;
    }
});
Object.defineProperty(exports, "JSXFragment", {
    enumerable: true,
    get: function() {
        return _index.jsxFragment;
    }
});
Object.defineProperty(exports, "JSXIdentifier", {
    enumerable: true,
    get: function() {
        return _index.jsxIdentifier;
    }
});
Object.defineProperty(exports, "JSXMemberExpression", {
    enumerable: true,
    get: function() {
        return _index.jsxMemberExpression;
    }
});
Object.defineProperty(exports, "JSXNamespacedName", {
    enumerable: true,
    get: function() {
        return _index.jsxNamespacedName;
    }
});
Object.defineProperty(exports, "JSXOpeningElement", {
    enumerable: true,
    get: function() {
        return _index.jsxOpeningElement;
    }
});
Object.defineProperty(exports, "JSXOpeningFragment", {
    enumerable: true,
    get: function() {
        return _index.jsxOpeningFragment;
    }
});
Object.defineProperty(exports, "JSXSpreadAttribute", {
    enumerable: true,
    get: function() {
        return _index.jsxSpreadAttribute;
    }
});
Object.defineProperty(exports, "JSXSpreadChild", {
    enumerable: true,
    get: function() {
        return _index.jsxSpreadChild;
    }
});
Object.defineProperty(exports, "JSXText", {
    enumerable: true,
    get: function() {
        return _index.jsxText;
    }
});
Object.defineProperty(exports, "LabeledStatement", {
    enumerable: true,
    get: function() {
        return _index.labeledStatement;
    }
});
Object.defineProperty(exports, "LogicalExpression", {
    enumerable: true,
    get: function() {
        return _index.logicalExpression;
    }
});
Object.defineProperty(exports, "MemberExpression", {
    enumerable: true,
    get: function() {
        return _index.memberExpression;
    }
});
Object.defineProperty(exports, "MetaProperty", {
    enumerable: true,
    get: function() {
        return _index.metaProperty;
    }
});
Object.defineProperty(exports, "MixedTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.mixedTypeAnnotation;
    }
});
Object.defineProperty(exports, "ModuleExpression", {
    enumerable: true,
    get: function() {
        return _index.moduleExpression;
    }
});
Object.defineProperty(exports, "NewExpression", {
    enumerable: true,
    get: function() {
        return _index.newExpression;
    }
});
Object.defineProperty(exports, "Noop", {
    enumerable: true,
    get: function() {
        return _index.noop;
    }
});
Object.defineProperty(exports, "NullLiteral", {
    enumerable: true,
    get: function() {
        return _index.nullLiteral;
    }
});
Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.nullLiteralTypeAnnotation;
    }
});
Object.defineProperty(exports, "NullableTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.nullableTypeAnnotation;
    }
});
Object.defineProperty(exports, "NumberLiteral", {
    enumerable: true,
    get: function() {
        return _index.numberLiteral;
    }
});
Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.numberLiteralTypeAnnotation;
    }
});
Object.defineProperty(exports, "NumberTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.numberTypeAnnotation;
    }
});
Object.defineProperty(exports, "NumericLiteral", {
    enumerable: true,
    get: function() {
        return _index.numericLiteral;
    }
});
Object.defineProperty(exports, "ObjectExpression", {
    enumerable: true,
    get: function() {
        return _index.objectExpression;
    }
});
Object.defineProperty(exports, "ObjectMethod", {
    enumerable: true,
    get: function() {
        return _index.objectMethod;
    }
});
Object.defineProperty(exports, "ObjectPattern", {
    enumerable: true,
    get: function() {
        return _index.objectPattern;
    }
});
Object.defineProperty(exports, "ObjectProperty", {
    enumerable: true,
    get: function() {
        return _index.objectProperty;
    }
});
Object.defineProperty(exports, "ObjectTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.objectTypeAnnotation;
    }
});
Object.defineProperty(exports, "ObjectTypeCallProperty", {
    enumerable: true,
    get: function() {
        return _index.objectTypeCallProperty;
    }
});
Object.defineProperty(exports, "ObjectTypeIndexer", {
    enumerable: true,
    get: function() {
        return _index.objectTypeIndexer;
    }
});
Object.defineProperty(exports, "ObjectTypeInternalSlot", {
    enumerable: true,
    get: function() {
        return _index.objectTypeInternalSlot;
    }
});
Object.defineProperty(exports, "ObjectTypeProperty", {
    enumerable: true,
    get: function() {
        return _index.objectTypeProperty;
    }
});
Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
    enumerable: true,
    get: function() {
        return _index.objectTypeSpreadProperty;
    }
});
Object.defineProperty(exports, "OpaqueType", {
    enumerable: true,
    get: function() {
        return _index.opaqueType;
    }
});
Object.defineProperty(exports, "OptionalCallExpression", {
    enumerable: true,
    get: function() {
        return _index.optionalCallExpression;
    }
});
Object.defineProperty(exports, "OptionalIndexedAccessType", {
    enumerable: true,
    get: function() {
        return _index.optionalIndexedAccessType;
    }
});
Object.defineProperty(exports, "OptionalMemberExpression", {
    enumerable: true,
    get: function() {
        return _index.optionalMemberExpression;
    }
});
Object.defineProperty(exports, "ParenthesizedExpression", {
    enumerable: true,
    get: function() {
        return _index.parenthesizedExpression;
    }
});
Object.defineProperty(exports, "PipelineBareFunction", {
    enumerable: true,
    get: function() {
        return _index.pipelineBareFunction;
    }
});
Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
    enumerable: true,
    get: function() {
        return _index.pipelinePrimaryTopicReference;
    }
});
Object.defineProperty(exports, "PipelineTopicExpression", {
    enumerable: true,
    get: function() {
        return _index.pipelineTopicExpression;
    }
});
Object.defineProperty(exports, "Placeholder", {
    enumerable: true,
    get: function() {
        return _index.placeholder;
    }
});
Object.defineProperty(exports, "PrivateName", {
    enumerable: true,
    get: function() {
        return _index.privateName;
    }
});
Object.defineProperty(exports, "Program", {
    enumerable: true,
    get: function() {
        return _index.program;
    }
});
Object.defineProperty(exports, "QualifiedTypeIdentifier", {
    enumerable: true,
    get: function() {
        return _index.qualifiedTypeIdentifier;
    }
});
Object.defineProperty(exports, "RecordExpression", {
    enumerable: true,
    get: function() {
        return _index.recordExpression;
    }
});
Object.defineProperty(exports, "RegExpLiteral", {
    enumerable: true,
    get: function() {
        return _index.regExpLiteral;
    }
});
Object.defineProperty(exports, "RegexLiteral", {
    enumerable: true,
    get: function() {
        return _index.regexLiteral;
    }
});
Object.defineProperty(exports, "RestElement", {
    enumerable: true,
    get: function() {
        return _index.restElement;
    }
});
Object.defineProperty(exports, "RestProperty", {
    enumerable: true,
    get: function() {
        return _index.restProperty;
    }
});
Object.defineProperty(exports, "ReturnStatement", {
    enumerable: true,
    get: function() {
        return _index.returnStatement;
    }
});
Object.defineProperty(exports, "SequenceExpression", {
    enumerable: true,
    get: function() {
        return _index.sequenceExpression;
    }
});
Object.defineProperty(exports, "SpreadElement", {
    enumerable: true,
    get: function() {
        return _index.spreadElement;
    }
});
Object.defineProperty(exports, "SpreadProperty", {
    enumerable: true,
    get: function() {
        return _index.spreadProperty;
    }
});
Object.defineProperty(exports, "StaticBlock", {
    enumerable: true,
    get: function() {
        return _index.staticBlock;
    }
});
Object.defineProperty(exports, "StringLiteral", {
    enumerable: true,
    get: function() {
        return _index.stringLiteral;
    }
});
Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.stringLiteralTypeAnnotation;
    }
});
Object.defineProperty(exports, "StringTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.stringTypeAnnotation;
    }
});
Object.defineProperty(exports, "Super", {
    enumerable: true,
    get: function() {
        return _index.super;
    }
});
Object.defineProperty(exports, "SwitchCase", {
    enumerable: true,
    get: function() {
        return _index.switchCase;
    }
});
Object.defineProperty(exports, "SwitchStatement", {
    enumerable: true,
    get: function() {
        return _index.switchStatement;
    }
});
Object.defineProperty(exports, "SymbolTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.symbolTypeAnnotation;
    }
});
Object.defineProperty(exports, "TSAnyKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsAnyKeyword;
    }
});
Object.defineProperty(exports, "TSArrayType", {
    enumerable: true,
    get: function() {
        return _index.tsArrayType;
    }
});
Object.defineProperty(exports, "TSAsExpression", {
    enumerable: true,
    get: function() {
        return _index.tsAsExpression;
    }
});
Object.defineProperty(exports, "TSBigIntKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsBigIntKeyword;
    }
});
Object.defineProperty(exports, "TSBooleanKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsBooleanKeyword;
    }
});
Object.defineProperty(exports, "TSCallSignatureDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsCallSignatureDeclaration;
    }
});
Object.defineProperty(exports, "TSConditionalType", {
    enumerable: true,
    get: function() {
        return _index.tsConditionalType;
    }
});
Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsConstructSignatureDeclaration;
    }
});
Object.defineProperty(exports, "TSConstructorType", {
    enumerable: true,
    get: function() {
        return _index.tsConstructorType;
    }
});
Object.defineProperty(exports, "TSDeclareFunction", {
    enumerable: true,
    get: function() {
        return _index.tsDeclareFunction;
    }
});
Object.defineProperty(exports, "TSDeclareMethod", {
    enumerable: true,
    get: function() {
        return _index.tsDeclareMethod;
    }
});
Object.defineProperty(exports, "TSEnumDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsEnumDeclaration;
    }
});
Object.defineProperty(exports, "TSEnumMember", {
    enumerable: true,
    get: function() {
        return _index.tsEnumMember;
    }
});
Object.defineProperty(exports, "TSExportAssignment", {
    enumerable: true,
    get: function() {
        return _index.tsExportAssignment;
    }
});
Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
    enumerable: true,
    get: function() {
        return _index.tsExpressionWithTypeArguments;
    }
});
Object.defineProperty(exports, "TSExternalModuleReference", {
    enumerable: true,
    get: function() {
        return _index.tsExternalModuleReference;
    }
});
Object.defineProperty(exports, "TSFunctionType", {
    enumerable: true,
    get: function() {
        return _index.tsFunctionType;
    }
});
Object.defineProperty(exports, "TSImportEqualsDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsImportEqualsDeclaration;
    }
});
Object.defineProperty(exports, "TSImportType", {
    enumerable: true,
    get: function() {
        return _index.tsImportType;
    }
});
Object.defineProperty(exports, "TSIndexSignature", {
    enumerable: true,
    get: function() {
        return _index.tsIndexSignature;
    }
});
Object.defineProperty(exports, "TSIndexedAccessType", {
    enumerable: true,
    get: function() {
        return _index.tsIndexedAccessType;
    }
});
Object.defineProperty(exports, "TSInferType", {
    enumerable: true,
    get: function() {
        return _index.tsInferType;
    }
});
Object.defineProperty(exports, "TSInterfaceBody", {
    enumerable: true,
    get: function() {
        return _index.tsInterfaceBody;
    }
});
Object.defineProperty(exports, "TSInterfaceDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsInterfaceDeclaration;
    }
});
Object.defineProperty(exports, "TSIntersectionType", {
    enumerable: true,
    get: function() {
        return _index.tsIntersectionType;
    }
});
Object.defineProperty(exports, "TSIntrinsicKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsIntrinsicKeyword;
    }
});
Object.defineProperty(exports, "TSLiteralType", {
    enumerable: true,
    get: function() {
        return _index.tsLiteralType;
    }
});
Object.defineProperty(exports, "TSMappedType", {
    enumerable: true,
    get: function() {
        return _index.tsMappedType;
    }
});
Object.defineProperty(exports, "TSMethodSignature", {
    enumerable: true,
    get: function() {
        return _index.tsMethodSignature;
    }
});
Object.defineProperty(exports, "TSModuleBlock", {
    enumerable: true,
    get: function() {
        return _index.tsModuleBlock;
    }
});
Object.defineProperty(exports, "TSModuleDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsModuleDeclaration;
    }
});
Object.defineProperty(exports, "TSNamedTupleMember", {
    enumerable: true,
    get: function() {
        return _index.tsNamedTupleMember;
    }
});
Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsNamespaceExportDeclaration;
    }
});
Object.defineProperty(exports, "TSNeverKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsNeverKeyword;
    }
});
Object.defineProperty(exports, "TSNonNullExpression", {
    enumerable: true,
    get: function() {
        return _index.tsNonNullExpression;
    }
});
Object.defineProperty(exports, "TSNullKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsNullKeyword;
    }
});
Object.defineProperty(exports, "TSNumberKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsNumberKeyword;
    }
});
Object.defineProperty(exports, "TSObjectKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsObjectKeyword;
    }
});
Object.defineProperty(exports, "TSOptionalType", {
    enumerable: true,
    get: function() {
        return _index.tsOptionalType;
    }
});
Object.defineProperty(exports, "TSParameterProperty", {
    enumerable: true,
    get: function() {
        return _index.tsParameterProperty;
    }
});
Object.defineProperty(exports, "TSParenthesizedType", {
    enumerable: true,
    get: function() {
        return _index.tsParenthesizedType;
    }
});
Object.defineProperty(exports, "TSPropertySignature", {
    enumerable: true,
    get: function() {
        return _index.tsPropertySignature;
    }
});
Object.defineProperty(exports, "TSQualifiedName", {
    enumerable: true,
    get: function() {
        return _index.tsQualifiedName;
    }
});
Object.defineProperty(exports, "TSRestType", {
    enumerable: true,
    get: function() {
        return _index.tsRestType;
    }
});
Object.defineProperty(exports, "TSStringKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsStringKeyword;
    }
});
Object.defineProperty(exports, "TSSymbolKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsSymbolKeyword;
    }
});
Object.defineProperty(exports, "TSThisType", {
    enumerable: true,
    get: function() {
        return _index.tsThisType;
    }
});
Object.defineProperty(exports, "TSTupleType", {
    enumerable: true,
    get: function() {
        return _index.tsTupleType;
    }
});
Object.defineProperty(exports, "TSTypeAliasDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsTypeAliasDeclaration;
    }
});
Object.defineProperty(exports, "TSTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.tsTypeAnnotation;
    }
});
Object.defineProperty(exports, "TSTypeAssertion", {
    enumerable: true,
    get: function() {
        return _index.tsTypeAssertion;
    }
});
Object.defineProperty(exports, "TSTypeLiteral", {
    enumerable: true,
    get: function() {
        return _index.tsTypeLiteral;
    }
});
Object.defineProperty(exports, "TSTypeOperator", {
    enumerable: true,
    get: function() {
        return _index.tsTypeOperator;
    }
});
Object.defineProperty(exports, "TSTypeParameter", {
    enumerable: true,
    get: function() {
        return _index.tsTypeParameter;
    }
});
Object.defineProperty(exports, "TSTypeParameterDeclaration", {
    enumerable: true,
    get: function() {
        return _index.tsTypeParameterDeclaration;
    }
});
Object.defineProperty(exports, "TSTypeParameterInstantiation", {
    enumerable: true,
    get: function() {
        return _index.tsTypeParameterInstantiation;
    }
});
Object.defineProperty(exports, "TSTypePredicate", {
    enumerable: true,
    get: function() {
        return _index.tsTypePredicate;
    }
});
Object.defineProperty(exports, "TSTypeQuery", {
    enumerable: true,
    get: function() {
        return _index.tsTypeQuery;
    }
});
Object.defineProperty(exports, "TSTypeReference", {
    enumerable: true,
    get: function() {
        return _index.tsTypeReference;
    }
});
Object.defineProperty(exports, "TSUndefinedKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsUndefinedKeyword;
    }
});
Object.defineProperty(exports, "TSUnionType", {
    enumerable: true,
    get: function() {
        return _index.tsUnionType;
    }
});
Object.defineProperty(exports, "TSUnknownKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsUnknownKeyword;
    }
});
Object.defineProperty(exports, "TSVoidKeyword", {
    enumerable: true,
    get: function() {
        return _index.tsVoidKeyword;
    }
});
Object.defineProperty(exports, "TaggedTemplateExpression", {
    enumerable: true,
    get: function() {
        return _index.taggedTemplateExpression;
    }
});
Object.defineProperty(exports, "TemplateElement", {
    enumerable: true,
    get: function() {
        return _index.templateElement;
    }
});
Object.defineProperty(exports, "TemplateLiteral", {
    enumerable: true,
    get: function() {
        return _index.templateLiteral;
    }
});
Object.defineProperty(exports, "ThisExpression", {
    enumerable: true,
    get: function() {
        return _index.thisExpression;
    }
});
Object.defineProperty(exports, "ThisTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.thisTypeAnnotation;
    }
});
Object.defineProperty(exports, "ThrowStatement", {
    enumerable: true,
    get: function() {
        return _index.throwStatement;
    }
});
Object.defineProperty(exports, "TopicReference", {
    enumerable: true,
    get: function() {
        return _index.topicReference;
    }
});
Object.defineProperty(exports, "TryStatement", {
    enumerable: true,
    get: function() {
        return _index.tryStatement;
    }
});
Object.defineProperty(exports, "TupleExpression", {
    enumerable: true,
    get: function() {
        return _index.tupleExpression;
    }
});
Object.defineProperty(exports, "TupleTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.tupleTypeAnnotation;
    }
});
Object.defineProperty(exports, "TypeAlias", {
    enumerable: true,
    get: function() {
        return _index.typeAlias;
    }
});
Object.defineProperty(exports, "TypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.typeAnnotation;
    }
});
Object.defineProperty(exports, "TypeCastExpression", {
    enumerable: true,
    get: function() {
        return _index.typeCastExpression;
    }
});
Object.defineProperty(exports, "TypeParameter", {
    enumerable: true,
    get: function() {
        return _index.typeParameter;
    }
});
Object.defineProperty(exports, "TypeParameterDeclaration", {
    enumerable: true,
    get: function() {
        return _index.typeParameterDeclaration;
    }
});
Object.defineProperty(exports, "TypeParameterInstantiation", {
    enumerable: true,
    get: function() {
        return _index.typeParameterInstantiation;
    }
});
Object.defineProperty(exports, "TypeofTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.typeofTypeAnnotation;
    }
});
Object.defineProperty(exports, "UnaryExpression", {
    enumerable: true,
    get: function() {
        return _index.unaryExpression;
    }
});
Object.defineProperty(exports, "UnionTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.unionTypeAnnotation;
    }
});
Object.defineProperty(exports, "UpdateExpression", {
    enumerable: true,
    get: function() {
        return _index.updateExpression;
    }
});
Object.defineProperty(exports, "V8IntrinsicIdentifier", {
    enumerable: true,
    get: function() {
        return _index.v8IntrinsicIdentifier;
    }
});
Object.defineProperty(exports, "VariableDeclaration", {
    enumerable: true,
    get: function() {
        return _index.variableDeclaration;
    }
});
Object.defineProperty(exports, "VariableDeclarator", {
    enumerable: true,
    get: function() {
        return _index.variableDeclarator;
    }
});
Object.defineProperty(exports, "Variance", {
    enumerable: true,
    get: function() {
        return _index.variance;
    }
});
Object.defineProperty(exports, "VoidTypeAnnotation", {
    enumerable: true,
    get: function() {
        return _index.voidTypeAnnotation;
    }
});
Object.defineProperty(exports, "WhileStatement", {
    enumerable: true,
    get: function() {
        return _index.whileStatement;
    }
});
Object.defineProperty(exports, "WithStatement", {
    enumerable: true,
    get: function() {
        return _index.withStatement;
    }
});
Object.defineProperty(exports, "YieldExpression", {
    enumerable: true,
    get: function() {
        return _index.yieldExpression;
    }
});
var _index = require("./index");

},{"./index":"1bIPZ"}],"5AE4Z":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cloneNode;
var _definitions = require("../definitions");
var _generated = require("../validators/generated");
const has = Function.call.bind(Object.prototype.hasOwnProperty);
function cloneIfNode(obj, deep, withoutLoc) {
    if (obj && typeof obj.type === "string") return cloneNode(obj, deep, withoutLoc);
    return obj;
}
function cloneIfNodeOrArray(obj, deep, withoutLoc) {
    if (Array.isArray(obj)) return obj.map((node)=>cloneIfNode(node, deep, withoutLoc)
    );
    return cloneIfNode(obj, deep, withoutLoc);
}
function cloneNode(node, deep = true, withoutLoc = false) {
    if (!node) return node;
    const { type  } = node;
    const newNode = {
        type: node.type
    };
    if ((0, _generated.isIdentifier)(node)) {
        newNode.name = node.name;
        if (has(node, "optional") && typeof node.optional === "boolean") newNode.optional = node.optional;
        if (has(node, "typeAnnotation")) newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation;
    } else if (!has(_definitions.NODE_FIELDS, type)) throw new Error(`Unknown node type: "${type}"`);
    else {
        for (const field of Object.keys(_definitions.NODE_FIELDS[type]))if (has(node, field)) {
            if (deep) newNode[field] = (0, _generated.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc);
            else newNode[field] = node[field];
        }
    }
    if (has(node, "loc")) {
        if (withoutLoc) newNode.loc = null;
        else newNode.loc = node.loc;
    }
    if (has(node, "leadingComments")) newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc);
    if (has(node, "innerComments")) newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc);
    if (has(node, "trailingComments")) newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc);
    if (has(node, "extra")) newNode.extra = Object.assign({}, node.extra);
    return newNode;
}
function maybeCloneComments(comments, deep, withoutLoc) {
    if (!comments || !deep) return comments;
    return comments.map(({ type , value , loc  })=>{
        if (withoutLoc) return {
            type,
            value,
            loc: null
        };
        return {
            type,
            value,
            loc
        };
    });
}

},{"../definitions":"lTnnW","../validators/generated":"cfCci"}],"5LE1s":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = clone;
var _cloneNode = require("./cloneNode");
function clone(node) {
    return (0, _cloneNode.default)(node, false);
}

},{"./cloneNode":"5AE4Z"}],"cMpx0":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cloneDeep;
var _cloneNode = require("./cloneNode");
function cloneDeep(node) {
    return (0, _cloneNode.default)(node);
}

},{"./cloneNode":"5AE4Z"}],"9AJQI":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cloneDeepWithoutLoc;
var _cloneNode = require("./cloneNode");
function cloneDeepWithoutLoc(node) {
    return (0, _cloneNode.default)(node, true, true);
}

},{"./cloneNode":"5AE4Z"}],"hp1FS":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = cloneWithoutLoc;
var _cloneNode = require("./cloneNode");
function cloneWithoutLoc(node) {
    return (0, _cloneNode.default)(node, false, true);
}

},{"./cloneNode":"5AE4Z"}],"Xa1Mx":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = addComment;
var _addComments = require("./addComments");
function addComment(node, type, content, line) {
    return (0, _addComments.default)(node, type, [
        {
            type: line ? "CommentLine" : "CommentBlock",
            value: content
        }
    ]);
}

},{"./addComments":"5ysA1"}],"5ysA1":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = addComments;
function addComments(node, type, comments) {
    if (!comments || !node) return node;
    const key = `${type}Comments`;
    if (node[key]) {
        if (type === "leading") node[key] = comments.concat(node[key]);
        else node[key].push(...comments);
    } else node[key] = comments;
    return node;
}

},{}],"nwPzA":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inheritInnerComments;
var _inherit = require("../utils/inherit");
function inheritInnerComments(child, parent) {
    (0, _inherit.default)("innerComments", child, parent);
}

},{"../utils/inherit":"d5M1x"}],"d5M1x":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inherit;
function inherit(key, child, parent) {
    if (child && parent) child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
}

},{}],"bdDai":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inheritLeadingComments;
var _inherit = require("../utils/inherit");
function inheritLeadingComments(child, parent) {
    (0, _inherit.default)("leadingComments", child, parent);
}

},{"../utils/inherit":"d5M1x"}],"jiPy2":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inheritsComments;
var _inheritTrailingComments = require("./inheritTrailingComments");
var _inheritLeadingComments = require("./inheritLeadingComments");
var _inheritInnerComments = require("./inheritInnerComments");
function inheritsComments(child, parent) {
    (0, _inheritTrailingComments.default)(child, parent);
    (0, _inheritLeadingComments.default)(child, parent);
    (0, _inheritInnerComments.default)(child, parent);
    return child;
}

},{"./inheritTrailingComments":"4Yyv2","./inheritLeadingComments":"bdDai","./inheritInnerComments":"nwPzA"}],"4Yyv2":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inheritTrailingComments;
var _inherit = require("../utils/inherit");
function inheritTrailingComments(child, parent) {
    (0, _inherit.default)("trailingComments", child, parent);
}

},{"../utils/inherit":"d5M1x"}],"5aNYQ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removeComments;
var _constants = require("../constants");
function removeComments(node) {
    _constants.COMMENT_KEYS.forEach((key)=>{
        node[key] = null;
    });
    return node;
}

},{"../constants":"7tigb"}],"dgplI":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WHILE_TYPES = exports.USERWHITESPACABLE_TYPES = exports.UNARYLIKE_TYPES = exports.TYPESCRIPT_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.TSENTITYNAME_TYPES = exports.TSBASETYPE_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.STANDARDIZED_TYPES = exports.SCOPABLE_TYPES = exports.PUREISH_TYPES = exports.PROPERTY_TYPES = exports.PRIVATE_TYPES = exports.PATTERN_TYPES = exports.PATTERNLIKE_TYPES = exports.OBJECTMEMBER_TYPES = exports.MODULESPECIFIER_TYPES = exports.MODULEDECLARATION_TYPES = exports.MISCELLANEOUS_TYPES = exports.METHOD_TYPES = exports.LVAL_TYPES = exports.LOOP_TYPES = exports.LITERAL_TYPES = exports.JSX_TYPES = exports.IMMUTABLE_TYPES = exports.FUNCTION_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FOR_TYPES = exports.FORXSTATEMENT_TYPES = exports.FLOW_TYPES = exports.FLOWTYPE_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.EXPRESSION_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.DECLARATION_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.CLASS_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.BINARY_TYPES = void 0;
var _definitions = require("../../definitions");
const STANDARDIZED_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Standardized"];
exports.STANDARDIZED_TYPES = STANDARDIZED_TYPES;
const EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Expression"];
exports.EXPRESSION_TYPES = EXPRESSION_TYPES;
const BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Binary"];
exports.BINARY_TYPES = BINARY_TYPES;
const SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Scopable"];
exports.SCOPABLE_TYPES = SCOPABLE_TYPES;
const BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["BlockParent"];
exports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
const BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Block"];
exports.BLOCK_TYPES = BLOCK_TYPES;
const STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Statement"];
exports.STATEMENT_TYPES = STATEMENT_TYPES;
const TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Terminatorless"];
exports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
const COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["CompletionStatement"];
exports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
const CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Conditional"];
exports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
const LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Loop"];
exports.LOOP_TYPES = LOOP_TYPES;
const WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["While"];
exports.WHILE_TYPES = WHILE_TYPES;
const EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
exports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
const FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["For"];
exports.FOR_TYPES = FOR_TYPES;
const FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ForXStatement"];
exports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
const FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Function"];
exports.FUNCTION_TYPES = FUNCTION_TYPES;
const FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FunctionParent"];
exports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
const PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pureish"];
exports.PUREISH_TYPES = PUREISH_TYPES;
const DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Declaration"];
exports.DECLARATION_TYPES = DECLARATION_TYPES;
const PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["PatternLike"];
exports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
const LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["LVal"];
exports.LVAL_TYPES = LVAL_TYPES;
const TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSEntityName"];
exports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
const LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Literal"];
exports.LITERAL_TYPES = LITERAL_TYPES;
const IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Immutable"];
exports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
const USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
exports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
const METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Method"];
exports.METHOD_TYPES = METHOD_TYPES;
const OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ObjectMember"];
exports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
const PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Property"];
exports.PROPERTY_TYPES = PROPERTY_TYPES;
const UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UnaryLike"];
exports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
const PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pattern"];
exports.PATTERN_TYPES = PATTERN_TYPES;
const CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Class"];
exports.CLASS_TYPES = CLASS_TYPES;
const MODULEDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
exports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
const EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
exports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
const MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
exports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
const PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Private"];
exports.PRIVATE_TYPES = PRIVATE_TYPES;
const FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Flow"];
exports.FLOW_TYPES = FLOW_TYPES;
const FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowType"];
exports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
const FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
exports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
const FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
exports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
const FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowPredicate"];
exports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
const ENUMBODY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumBody"];
exports.ENUMBODY_TYPES = ENUMBODY_TYPES;
const ENUMMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumMember"];
exports.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
const JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS["JSX"];
exports.JSX_TYPES = JSX_TYPES;
const MISCELLANEOUS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Miscellaneous"];
exports.MISCELLANEOUS_TYPES = MISCELLANEOUS_TYPES;
const TYPESCRIPT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TypeScript"];
exports.TYPESCRIPT_TYPES = TYPESCRIPT_TYPES;
const TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSTypeElement"];
exports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
const TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSType"];
exports.TSTYPE_TYPES = TSTYPE_TYPES;
const TSBASETYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSBaseType"];
exports.TSBASETYPE_TYPES = TSBASETYPE_TYPES;

},{"../../definitions":"lTnnW"}],"6Cvs0":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = ensureBlock;
var _toBlock = require("./toBlock");
function ensureBlock(node, key = "body") {
    return node[key] = (0, _toBlock.default)(node[key], node);
}

},{"./toBlock":"l0ogU"}],"l0ogU":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toBlock;
var _generated = require("../validators/generated");
var _generated2 = require("../builders/generated");
function toBlock(node, parent) {
    if ((0, _generated.isBlockStatement)(node)) return node;
    let blockNodes = [];
    if ((0, _generated.isEmptyStatement)(node)) blockNodes = [];
    else {
        if (!(0, _generated.isStatement)(node)) {
            if ((0, _generated.isFunction)(parent)) node = (0, _generated2.returnStatement)(node);
            else node = (0, _generated2.expressionStatement)(node);
        }
        blockNodes = [
            node
        ];
    }
    return (0, _generated2.blockStatement)(blockNodes);
}

},{"../validators/generated":"cfCci","../builders/generated":"1bIPZ"}],"3RmFD":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toBindingIdentifierName;
var _toIdentifier = require("./toIdentifier");
function toBindingIdentifierName(name) {
    name = (0, _toIdentifier.default)(name);
    if (name === "eval" || name === "arguments") name = "_" + name;
    return name;
}

},{"./toIdentifier":"afK5o"}],"afK5o":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toIdentifier;
var _isValidIdentifier = require("../validators/isValidIdentifier");
var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");
function toIdentifier(input) {
    input = input + "";
    let name = "";
    for (const c1 of input)name += (0, _helperValidatorIdentifier.isIdentifierChar)(c1.codePointAt(0)) ? c1 : "-";
    name = name.replace(/^[-0-9]+/, "");
    name = name.replace(/[-\s]+(.)?/g, function(match, c) {
        return c ? c.toUpperCase() : "";
    });
    if (!(0, _isValidIdentifier.default)(name)) name = `_${name}`;
    return name || "_";
}

},{"../validators/isValidIdentifier":"gHSEO","@babel/helper-validator-identifier":"f9R0u"}],"izZg2":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toComputedKey;
var _generated = require("../validators/generated");
var _generated2 = require("../builders/generated");
function toComputedKey(node, key = node.key || node.property) {
    if (!node.computed && (0, _generated.isIdentifier)(key)) key = (0, _generated2.stringLiteral)(key.name);
    return key;
}

},{"../validators/generated":"cfCci","../builders/generated":"1bIPZ"}],"2vzK3":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _generated = require("../validators/generated");
var _default = toExpression;
exports.default = _default;
function toExpression(node) {
    if ((0, _generated.isExpressionStatement)(node)) node = node.expression;
    if ((0, _generated.isExpression)(node)) return node;
    if ((0, _generated.isClass)(node)) node.type = "ClassExpression";
    else if ((0, _generated.isFunction)(node)) node.type = "FunctionExpression";
    if (!(0, _generated.isExpression)(node)) throw new Error(`cannot turn ${node.type} to an expression`);
    return node;
}

},{"../validators/generated":"cfCci"}],"7HJGS":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toKeyAlias;
var _generated = require("../validators/generated");
var _cloneNode = require("../clone/cloneNode");
var _removePropertiesDeep = require("../modifications/removePropertiesDeep");
function toKeyAlias(node, key = node.key) {
    let alias;
    if (node.kind === "method") return toKeyAlias.increment() + "";
    else if ((0, _generated.isIdentifier)(key)) alias = key.name;
    else if ((0, _generated.isStringLiteral)(key)) alias = JSON.stringify(key.value);
    else alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
    if (node.computed) alias = `[${alias}]`;
    if (node.static) alias = `static:${alias}`;
    return alias;
}
toKeyAlias.uid = 0;
toKeyAlias.increment = function() {
    if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) return toKeyAlias.uid = 0;
    else return toKeyAlias.uid++;
};

},{"../validators/generated":"cfCci","../clone/cloneNode":"5AE4Z","../modifications/removePropertiesDeep":"2Tf8G"}],"2Tf8G":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removePropertiesDeep;
var _traverseFast = require("../traverse/traverseFast");
var _removeProperties = require("./removeProperties");
function removePropertiesDeep(tree, opts) {
    (0, _traverseFast.default)(tree, _removeProperties.default, opts);
    return tree;
}

},{"../traverse/traverseFast":"9wJiS","./removeProperties":"hcFyb"}],"9wJiS":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = traverseFast;
var _definitions = require("../definitions");
function traverseFast(node, enter, opts) {
    if (!node) return;
    const keys = _definitions.VISITOR_KEYS[node.type];
    if (!keys) return;
    opts = opts || {};
    enter(node, opts);
    for (const key of keys){
        const subNode = node[key];
        if (Array.isArray(subNode)) for (const node1 of subNode)traverseFast(node1, enter, opts);
        else traverseFast(subNode, enter, opts);
    }
}

},{"../definitions":"lTnnW"}],"hcFyb":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = removeProperties;
var _constants = require("../constants");
const CLEAR_KEYS = [
    "tokens",
    "start",
    "end",
    "loc",
    "raw",
    "rawValue"
];
const CLEAR_KEYS_PLUS_COMMENTS = _constants.COMMENT_KEYS.concat([
    "comments"
]).concat(CLEAR_KEYS);
function removeProperties(node, opts = {}) {
    const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
    for (const key of map)if (node[key] != null) node[key] = undefined;
    for (const key1 of Object.keys(node))if (key1[0] === "_" && node[key1] != null) node[key1] = undefined;
    const symbols = Object.getOwnPropertySymbols(node);
    for (const sym of symbols)node[sym] = null;
}

},{"../constants":"7tigb"}],"koQe8":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toSequenceExpression;
var _gatherSequenceExpressions = require("./gatherSequenceExpressions");
function toSequenceExpression(nodes, scope) {
    if (!(nodes != null && nodes.length)) return;
    const declars = [];
    const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
    if (!result) return;
    for (const declar of declars)scope.push(declar);
    return result;
}

},{"./gatherSequenceExpressions":"22U0K"}],"22U0K":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = gatherSequenceExpressions;
var _getBindingIdentifiers = require("../retrievers/getBindingIdentifiers");
var _generated = require("../validators/generated");
var _generated2 = require("../builders/generated");
var _cloneNode = require("../clone/cloneNode");
function gatherSequenceExpressions(nodes, scope, declars) {
    const exprs = [];
    let ensureLastUndefined = true;
    for (const node of nodes){
        if (!(0, _generated.isEmptyStatement)(node)) ensureLastUndefined = false;
        if ((0, _generated.isExpression)(node)) exprs.push(node);
        else if ((0, _generated.isExpressionStatement)(node)) exprs.push(node.expression);
        else if ((0, _generated.isVariableDeclaration)(node)) {
            if (node.kind !== "var") return;
            for (const declar of node.declarations){
                const bindings = (0, _getBindingIdentifiers.default)(declar);
                for (const key of Object.keys(bindings))declars.push({
                    kind: node.kind,
                    id: (0, _cloneNode.default)(bindings[key])
                });
                if (declar.init) exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));
            }
            ensureLastUndefined = true;
        } else if ((0, _generated.isIfStatement)(node)) {
            const consequent = node.consequent ? gatherSequenceExpressions([
                node.consequent
            ], scope, declars) : scope.buildUndefinedNode();
            const alternate = node.alternate ? gatherSequenceExpressions([
                node.alternate
            ], scope, declars) : scope.buildUndefinedNode();
            if (!consequent || !alternate) return;
            exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));
        } else if ((0, _generated.isBlockStatement)(node)) {
            const body = gatherSequenceExpressions(node.body, scope, declars);
            if (!body) return;
            exprs.push(body);
        } else if ((0, _generated.isEmptyStatement)(node)) {
            if (nodes.indexOf(node) === 0) ensureLastUndefined = true;
        } else return;
    }
    if (ensureLastUndefined) exprs.push(scope.buildUndefinedNode());
    if (exprs.length === 1) return exprs[0];
    else return (0, _generated2.sequenceExpression)(exprs);
}

},{"../retrievers/getBindingIdentifiers":"12FR9","../validators/generated":"cfCci","../builders/generated":"1bIPZ","../clone/cloneNode":"5AE4Z"}],"12FR9":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getBindingIdentifiers;
var _generated = require("../validators/generated");
function getBindingIdentifiers(node, duplicates, outerOnly) {
    let search = [].concat(node);
    const ids = Object.create(null);
    while(search.length){
        const id = search.shift();
        if (!id) continue;
        const keys = getBindingIdentifiers.keys[id.type];
        if ((0, _generated.isIdentifier)(id)) {
            if (duplicates) {
                const _ids = ids[id.name] = ids[id.name] || [];
                _ids.push(id);
            } else ids[id.name] = id;
            continue;
        }
        if ((0, _generated.isExportDeclaration)(id) && !(0, _generated.isExportAllDeclaration)(id)) {
            if ((0, _generated.isDeclaration)(id.declaration)) search.push(id.declaration);
            continue;
        }
        if (outerOnly) {
            if ((0, _generated.isFunctionDeclaration)(id)) {
                search.push(id.id);
                continue;
            }
            if ((0, _generated.isFunctionExpression)(id)) continue;
        }
        if (keys) for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            if (id[key]) search = search.concat(id[key]);
        }
    }
    return ids;
}
getBindingIdentifiers.keys = {
    DeclareClass: [
        "id"
    ],
    DeclareFunction: [
        "id"
    ],
    DeclareModule: [
        "id"
    ],
    DeclareVariable: [
        "id"
    ],
    DeclareInterface: [
        "id"
    ],
    DeclareTypeAlias: [
        "id"
    ],
    DeclareOpaqueType: [
        "id"
    ],
    InterfaceDeclaration: [
        "id"
    ],
    TypeAlias: [
        "id"
    ],
    OpaqueType: [
        "id"
    ],
    CatchClause: [
        "param"
    ],
    LabeledStatement: [
        "label"
    ],
    UnaryExpression: [
        "argument"
    ],
    AssignmentExpression: [
        "left"
    ],
    ImportSpecifier: [
        "local"
    ],
    ImportNamespaceSpecifier: [
        "local"
    ],
    ImportDefaultSpecifier: [
        "local"
    ],
    ImportDeclaration: [
        "specifiers"
    ],
    ExportSpecifier: [
        "exported"
    ],
    ExportNamespaceSpecifier: [
        "exported"
    ],
    ExportDefaultSpecifier: [
        "exported"
    ],
    FunctionDeclaration: [
        "id",
        "params"
    ],
    FunctionExpression: [
        "id",
        "params"
    ],
    ArrowFunctionExpression: [
        "params"
    ],
    ObjectMethod: [
        "params"
    ],
    ClassMethod: [
        "params"
    ],
    ClassPrivateMethod: [
        "params"
    ],
    ForInStatement: [
        "left"
    ],
    ForOfStatement: [
        "left"
    ],
    ClassDeclaration: [
        "id"
    ],
    ClassExpression: [
        "id"
    ],
    RestElement: [
        "argument"
    ],
    UpdateExpression: [
        "argument"
    ],
    ObjectProperty: [
        "value"
    ],
    AssignmentPattern: [
        "left"
    ],
    ArrayPattern: [
        "elements"
    ],
    ObjectPattern: [
        "properties"
    ],
    VariableDeclaration: [
        "declarations"
    ],
    VariableDeclarator: [
        "id"
    ]
};

},{"../validators/generated":"cfCci"}],"4yzX8":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _generated = require("../validators/generated");
var _generated2 = require("../builders/generated");
var _default = toStatement;
exports.default = _default;
function toStatement(node, ignore) {
    if ((0, _generated.isStatement)(node)) return node;
    let mustHaveId = false;
    let newType;
    if ((0, _generated.isClass)(node)) {
        mustHaveId = true;
        newType = "ClassDeclaration";
    } else if ((0, _generated.isFunction)(node)) {
        mustHaveId = true;
        newType = "FunctionDeclaration";
    } else if ((0, _generated.isAssignmentExpression)(node)) return (0, _generated2.expressionStatement)(node);
    if (mustHaveId && !node.id) newType = false;
    if (!newType) {
        if (ignore) return false;
        else throw new Error(`cannot turn ${node.type} to a statement`);
    }
    node.type = newType;
    return node;
}

},{"../validators/generated":"cfCci","../builders/generated":"1bIPZ"}],"aUXlu":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _isValidIdentifier = require("../validators/isValidIdentifier");
var _generated = require("../builders/generated");
var _default = valueToNode;
exports.default = _default;
const objectToString = Function.call.bind(Object.prototype.toString);
function isRegExp(value) {
    return objectToString(value) === "[object RegExp]";
}
function isPlainObject(value) {
    if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") return false;
    const proto = Object.getPrototypeOf(value);
    return proto === null || Object.getPrototypeOf(proto) === null;
}
function valueToNode(value) {
    if (value === undefined) return (0, _generated.identifier)("undefined");
    if (value === true || value === false) return (0, _generated.booleanLiteral)(value);
    if (value === null) return (0, _generated.nullLiteral)();
    if (typeof value === "string") return (0, _generated.stringLiteral)(value);
    if (typeof value === "number") {
        let result;
        if (Number.isFinite(value)) result = (0, _generated.numericLiteral)(Math.abs(value));
        else {
            let numerator;
            if (Number.isNaN(value)) numerator = (0, _generated.numericLiteral)(0);
            else numerator = (0, _generated.numericLiteral)(1);
            result = (0, _generated.binaryExpression)("/", numerator, (0, _generated.numericLiteral)(0));
        }
        if (value < 0 || Object.is(value, -0)) result = (0, _generated.unaryExpression)("-", result);
        return result;
    }
    if (isRegExp(value)) {
        const pattern = value.source;
        const flags = value.toString().match(/\/([a-z]+|)$/)[1];
        return (0, _generated.regExpLiteral)(pattern, flags);
    }
    if (Array.isArray(value)) return (0, _generated.arrayExpression)(value.map(valueToNode));
    if (isPlainObject(value)) {
        const props = [];
        for (const key of Object.keys(value)){
            let nodeKey;
            if ((0, _isValidIdentifier.default)(key)) nodeKey = (0, _generated.identifier)(key);
            else nodeKey = (0, _generated.stringLiteral)(key);
            props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));
        }
        return (0, _generated.objectExpression)(props);
    }
    throw new Error("don't know how to turn this value into a node");
}

},{"../validators/isValidIdentifier":"gHSEO","../builders/generated":"1bIPZ"}],"4mHiV":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = appendToMemberExpression;
var _generated = require("../builders/generated");
function appendToMemberExpression(member, append, computed = false) {
    member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed);
    member.property = append;
    member.computed = !!computed;
    return member;
}

},{"../builders/generated":"1bIPZ"}],"i6c9H":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = inherits;
var _constants = require("../constants");
var _inheritsComments = require("../comments/inheritsComments");
function inherits(child, parent) {
    if (!child || !parent) return child;
    for (const key of _constants.INHERIT_KEYS.optional)if (child[key] == null) child[key] = parent[key];
    for (const key1 of Object.keys(parent))if (key1[0] === "_" && key1 !== "__clone") child[key1] = parent[key1];
    for (const key2 of _constants.INHERIT_KEYS.force)child[key2] = parent[key2];
    (0, _inheritsComments.default)(child, parent);
    return child;
}

},{"../constants":"7tigb","../comments/inheritsComments":"jiPy2"}],"lAt2b":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = prependToMemberExpression;
var _generated = require("../builders/generated");
function prependToMemberExpression(member, prepend) {
    member.object = (0, _generated.memberExpression)(prepend, member.object);
    return member;
}

},{"../builders/generated":"1bIPZ"}],"1kpUk":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _getBindingIdentifiers = require("./getBindingIdentifiers");
var _default = getOuterBindingIdentifiers;
exports.default = _default;
function getOuterBindingIdentifiers(node, duplicates) {
    return (0, _getBindingIdentifiers.default)(node, duplicates, true);
}

},{"./getBindingIdentifiers":"12FR9"}],"3xLxF":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = traverse;
var _definitions = require("../definitions");
function traverse(node, handlers, state) {
    if (typeof handlers === "function") handlers = {
        enter: handlers
    };
    const { enter , exit  } = handlers;
    traverseSimpleImpl(node, enter, exit, state, []);
}
function traverseSimpleImpl(node, enter, exit, state, ancestors) {
    const keys = _definitions.VISITOR_KEYS[node.type];
    if (!keys) return;
    if (enter) enter(node, ancestors, state);
    for (const key of keys){
        const subNode = node[key];
        if (Array.isArray(subNode)) for(let i = 0; i < subNode.length; i++){
            const child = subNode[i];
            if (!child) continue;
            ancestors.push({
                node,
                key,
                index: i
            });
            traverseSimpleImpl(child, enter, exit, state, ancestors);
            ancestors.pop();
        }
        else if (subNode) {
            ancestors.push({
                node,
                key
            });
            traverseSimpleImpl(subNode, enter, exit, state, ancestors);
            ancestors.pop();
        }
    }
    if (exit) exit(node, ancestors, state);
}

},{"../definitions":"lTnnW"}],"lWoMG":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isBinding;
var _getBindingIdentifiers = require("../retrievers/getBindingIdentifiers");
function isBinding(node, parent, grandparent) {
    if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") return false;
    const keys = _getBindingIdentifiers.default.keys[parent.type];
    if (keys) for(let i = 0; i < keys.length; i++){
        const key = keys[i];
        const val = parent[key];
        if (Array.isArray(val)) {
            if (val.indexOf(node) >= 0) return true;
        } else {
            if (val === node) return true;
        }
    }
    return false;
}

},{"../retrievers/getBindingIdentifiers":"12FR9"}],"es1iD":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isBlockScoped;
var _generated = require("./generated");
var _isLet = require("./isLet");
function isBlockScoped(node) {
    return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);
}

},{"./generated":"cfCci","./isLet":"hvGBh"}],"hvGBh":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isLet;
var _generated = require("./generated");
var _constants = require("../constants");
function isLet(node) {
    return (0, _generated.isVariableDeclaration)(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
}

},{"./generated":"cfCci","../constants":"7tigb"}],"dlQAn":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isImmutable;
var _isType = require("./isType");
var _generated = require("./generated");
function isImmutable(node) {
    if ((0, _isType.default)(node.type, "Immutable")) return true;
    if ((0, _generated.isIdentifier)(node)) {
        if (node.name === "undefined") return true;
        else return false;
    }
    return false;
}

},{"./isType":"bhmzl","./generated":"cfCci"}],"9L0hZ":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isNodesEquivalent;
var _definitions = require("../definitions");
function isNodesEquivalent(a, b) {
    if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) return a === b;
    if (a.type !== b.type) return false;
    const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);
    const visitorKeys = _definitions.VISITOR_KEYS[a.type];
    for (const field of fields){
        if (typeof a[field] !== typeof b[field]) return false;
        if (a[field] == null && b[field] == null) continue;
        else if (a[field] == null || b[field] == null) return false;
        if (Array.isArray(a[field])) {
            if (!Array.isArray(b[field])) return false;
            if (a[field].length !== b[field].length) return false;
            for(let i = 0; i < a[field].length; i++){
                if (!isNodesEquivalent(a[field][i], b[field][i])) return false;
            }
            continue;
        }
        if (typeof a[field] === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
            for (const key of Object.keys(a[field])){
                if (a[field][key] !== b[field][key]) return false;
            }
            continue;
        }
        if (!isNodesEquivalent(a[field], b[field])) return false;
    }
    return true;
}

},{"../definitions":"lTnnW"}],"1YvUB":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isReferenced;
function isReferenced(node, parent, grandparent) {
    switch(parent.type){
        case "MemberExpression":
        case "OptionalMemberExpression":
            if (parent.property === node) return !!parent.computed;
            return parent.object === node;
        case "JSXMemberExpression":
            return parent.object === node;
        case "VariableDeclarator":
            return parent.init === node;
        case "ArrowFunctionExpression":
            return parent.body === node;
        case "PrivateName":
            return false;
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
            if (parent.key === node) return !!parent.computed;
            return false;
        case "ObjectProperty":
            if (parent.key === node) return !!parent.computed;
            return !grandparent || grandparent.type !== "ObjectPattern";
        case "ClassProperty":
            if (parent.key === node) return !!parent.computed;
            return true;
        case "ClassPrivateProperty":
            return parent.key !== node;
        case "ClassDeclaration":
        case "ClassExpression":
            return parent.superClass === node;
        case "AssignmentExpression":
            return parent.right === node;
        case "AssignmentPattern":
            return parent.right === node;
        case "LabeledStatement":
            return false;
        case "CatchClause":
            return false;
        case "RestElement":
            return false;
        case "BreakStatement":
        case "ContinueStatement":
            return false;
        case "FunctionDeclaration":
        case "FunctionExpression":
            return false;
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
            return false;
        case "ExportSpecifier":
            if (grandparent != null && grandparent.source) return false;
            return parent.local === node;
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
            return false;
        case "ImportAttribute":
            return false;
        case "JSXAttribute":
            return false;
        case "ObjectPattern":
        case "ArrayPattern":
            return false;
        case "MetaProperty":
            return false;
        case "ObjectTypeProperty":
            return parent.key !== node;
        case "TSEnumMember":
            return parent.id !== node;
        case "TSPropertySignature":
            if (parent.key === node) return !!parent.computed;
            return true;
    }
    return true;
}

},{}],"jixT8":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isScope;
var _generated = require("./generated");
function isScope(node, parent) {
    if ((0, _generated.isBlockStatement)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent))) return false;
    if ((0, _generated.isPattern)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent))) return true;
    return (0, _generated.isScopable)(node);
}

},{"./generated":"cfCci"}],"i49IN":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isSpecifierDefault;
var _generated = require("./generated");
function isSpecifierDefault(specifier) {
    return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {
        name: "default"
    });
}

},{"./generated":"cfCci"}],"iZmST":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isValidES3Identifier;
var _isValidIdentifier = require("./isValidIdentifier");
const RESERVED_WORDS_ES3_ONLY = new Set([
    "abstract",
    "boolean",
    "byte",
    "char",
    "double",
    "enum",
    "final",
    "float",
    "goto",
    "implements",
    "int",
    "interface",
    "long",
    "native",
    "package",
    "private",
    "protected",
    "public",
    "short",
    "static",
    "synchronized",
    "throws",
    "transient",
    "volatile"
]);
function isValidES3Identifier(name) {
    return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
}

},{"./isValidIdentifier":"gHSEO"}],"7xyV0":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isVar;
var _generated = require("./generated");
var _constants = require("../constants");
function isVar(node) {
    return (0, _generated.isVariableDeclaration)(node, {
        kind: "var"
    }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
}

},{"./generated":"cfCci","../constants":"7tigb"}],"46KAc":[function(require,module,exports) {

},{}],"bzBEl":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _assert = require("assert");
var _t = require("@babel/types");
const { callExpression , cloneNode , expressionStatement , identifier , importDeclaration , importDefaultSpecifier , importNamespaceSpecifier , importSpecifier , memberExpression , stringLiteral , variableDeclaration , variableDeclarator  } = _t;
class ImportBuilder {
    constructor(importedSource, scope, hub){
        this._statements = [];
        this._resultName = null;
        this._scope = null;
        this._hub = null;
        this._importedSource = void 0;
        this._scope = scope;
        this._hub = hub;
        this._importedSource = importedSource;
    }
    done() {
        return {
            statements: this._statements,
            resultName: this._resultName
        };
    }
    import() {
        this._statements.push(importDeclaration([], stringLiteral(this._importedSource)));
        return this;
    }
    require() {
        this._statements.push(expressionStatement(callExpression(identifier("require"), [
            stringLiteral(this._importedSource)
        ])));
        return this;
    }
    namespace(name = "namespace") {
        const local = this._scope.generateUidIdentifier(name);
        const statement = this._statements[this._statements.length - 1];
        _assert(statement.type === "ImportDeclaration");
        _assert(statement.specifiers.length === 0);
        statement.specifiers = [
            importNamespaceSpecifier(local)
        ];
        this._resultName = cloneNode(local);
        return this;
    }
    default(name) {
        name = this._scope.generateUidIdentifier(name);
        const statement = this._statements[this._statements.length - 1];
        _assert(statement.type === "ImportDeclaration");
        _assert(statement.specifiers.length === 0);
        statement.specifiers = [
            importDefaultSpecifier(name)
        ];
        this._resultName = cloneNode(name);
        return this;
    }
    named(name, importName) {
        if (importName === "default") return this.default(name);
        name = this._scope.generateUidIdentifier(name);
        const statement = this._statements[this._statements.length - 1];
        _assert(statement.type === "ImportDeclaration");
        _assert(statement.specifiers.length === 0);
        statement.specifiers = [
            importSpecifier(name, identifier(importName))
        ];
        this._resultName = cloneNode(name);
        return this;
    }
    var(name) {
        name = this._scope.generateUidIdentifier(name);
        let statement = this._statements[this._statements.length - 1];
        if (statement.type !== "ExpressionStatement") {
            _assert(this._resultName);
            statement = expressionStatement(this._resultName);
            this._statements.push(statement);
        }
        this._statements[this._statements.length - 1] = variableDeclaration("var", [
            variableDeclarator(name, statement.expression)
        ]);
        this._resultName = cloneNode(name);
        return this;
    }
    defaultInterop() {
        return this._interop(this._hub.addHelper("interopRequireDefault"));
    }
    wildcardInterop() {
        return this._interop(this._hub.addHelper("interopRequireWildcard"));
    }
    _interop(callee) {
        const statement = this._statements[this._statements.length - 1];
        if (statement.type === "ExpressionStatement") statement.expression = callExpression(callee, [
            statement.expression
        ]);
        else if (statement.type === "VariableDeclaration") {
            _assert(statement.declarations.length === 1);
            statement.declarations[0].init = callExpression(callee, [
                statement.declarations[0].init
            ]);
        } else _assert.fail("Unexpected type.");
        return this;
    }
    prop(name) {
        const statement = this._statements[this._statements.length - 1];
        if (statement.type === "ExpressionStatement") statement.expression = memberExpression(statement.expression, identifier(name));
        else if (statement.type === "VariableDeclaration") {
            _assert(statement.declarations.length === 1);
            statement.declarations[0].init = memberExpression(statement.declarations[0].init, identifier(name));
        } else _assert.fail("Unexpected type:" + statement.type);
        return this;
    }
    read(name) {
        this._resultName = memberExpression(this._resultName, identifier(name));
    }
}
exports.default = ImportBuilder;

},{"assert":"bNzhs","@babel/types":"dsWVF"}],"eQVXU":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isModule;
function isModule(path) {
    const { sourceType  } = path.node;
    if (sourceType !== "module" && sourceType !== "script") throw path.buildCodeFrameError(`Unknown sourceType "${sourceType}", cannot transform.`);
    return path.node.sourceType === "module";
}

},{}],"7QVnB":[function(require,module,exports) {
"use strict";
var __assign = this && this.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
var named_references_1 = require("./named-references");
var numeric_unicode_map_1 = require("./numeric-unicode-map");
var surrogate_pairs_1 = require("./surrogate-pairs");
var allNamedReferences = __assign(__assign({}, named_references_1.namedReferences), {
    all: named_references_1.namedReferences.html5
});
var encodeRegExps = {
    specialChars: /[<>'"&]/g,
    nonAscii: /(?:[<>'"&\u0080-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
    nonAsciiPrintable: /(?:[<>'"&\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
    extensive: /(?:[\x01-\x0c\x0e-\x1f\x21-\x2c\x2e-\x2f\x3a-\x40\x5b-\x60\x7b-\x7d\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g
};
var defaultEncodeOptions = {
    mode: 'specialChars',
    level: 'all',
    numeric: 'decimal'
};
/** Encodes all the necessary (specified by `level`) characters in the text */ function encode(text, _a) {
    var _b = _a === void 0 ? defaultEncodeOptions : _a, _c = _b.mode, mode = _c === void 0 ? 'specialChars' : _c, _d = _b.numeric, numeric = _d === void 0 ? 'decimal' : _d, _e = _b.level, level = _e === void 0 ? 'all' : _e;
    if (!text) return '';
    var encodeRegExp = encodeRegExps[mode];
    var references = allNamedReferences[level].characters;
    var isHex = numeric === 'hexadecimal';
    encodeRegExp.lastIndex = 0;
    var _b = encodeRegExp.exec(text);
    var _c;
    if (_b) {
        _c = '';
        var _d = 0;
        do {
            if (_d !== _b.index) _c += text.substring(_d, _b.index);
            var _e = _b[0];
            var result_1 = references[_e];
            if (!result_1) {
                var code_1 = _e.length > 1 ? surrogate_pairs_1.getCodePoint(_e, 0) : _e.charCodeAt(0);
                result_1 = (isHex ? '&#x' + code_1.toString(16) : '&#' + code_1) + ';';
            }
            _c += result_1;
            _d = _b.index + _e.length;
        }while (_b = encodeRegExp.exec(text))
        if (_d !== text.length) _c += text.substring(_d);
    } else _c = text;
    return _c;
}
exports.encode = encode;
var defaultDecodeOptions = {
    scope: 'body',
    level: 'all'
};
var strict = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);/g;
var attribute = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;
var baseDecodeRegExps = {
    xml: {
        strict: strict,
        attribute: attribute,
        body: named_references_1.bodyRegExps.xml
    },
    html4: {
        strict: strict,
        attribute: attribute,
        body: named_references_1.bodyRegExps.html4
    },
    html5: {
        strict: strict,
        attribute: attribute,
        body: named_references_1.bodyRegExps.html5
    }
};
var decodeRegExps = __assign(__assign({}, baseDecodeRegExps), {
    all: baseDecodeRegExps.html5
});
var fromCharCode = String.fromCharCode;
var outOfBoundsChar = fromCharCode(65533);
var defaultDecodeEntityOptions = {
    level: 'all'
};
/** Decodes a single entity */ function decodeEntity(entity, _a) {
    var _b = (_a === void 0 ? defaultDecodeEntityOptions : _a).level, level = _b === void 0 ? 'all' : _b;
    if (!entity) return '';
    var _b = entity;
    var decodeEntityLastChar_1 = entity[entity.length - 1];
    var decodeResultByReference_1 = allNamedReferences[level].entities[entity];
    if (decodeResultByReference_1) _b = decodeResultByReference_1;
    else if (entity[0] === '&' && entity[1] === '#') {
        var decodeSecondChar_1 = entity[2];
        var decodeCode_1 = decodeSecondChar_1 == 'x' || decodeSecondChar_1 == 'X' ? parseInt(entity.substr(3), 16) : parseInt(entity.substr(2));
        _b = decodeCode_1 >= 1114111 ? outOfBoundsChar : decodeCode_1 > 65535 ? surrogate_pairs_1.fromCodePoint(decodeCode_1) : fromCharCode(numeric_unicode_map_1.numericUnicodeMap[decodeCode_1] || decodeCode_1);
    }
    return _b;
}
exports.decodeEntity = decodeEntity;
/** Decodes all entities in the text */ function decode(text, _a) {
    var decodeSecondChar_1 = _a === void 0 ? defaultDecodeOptions : _a, decodeCode_1 = decodeSecondChar_1.level, level = decodeCode_1 === void 0 ? 'all' : decodeCode_1, _b = decodeSecondChar_1.scope, scope = _b === void 0 ? level === 'xml' ? 'strict' : 'body' : _b;
    if (!text) return '';
    var decodeRegExp = decodeRegExps[level][scope];
    var references = allNamedReferences[level].entities;
    var isAttribute = scope === 'attribute';
    var isStrict = scope === 'strict';
    decodeRegExp.lastIndex = 0;
    var replaceMatch_1 = decodeRegExp.exec(text);
    var replaceResult_1;
    if (replaceMatch_1) {
        replaceResult_1 = '';
        var replaceLastIndex_1 = 0;
        do {
            if (replaceLastIndex_1 !== replaceMatch_1.index) replaceResult_1 += text.substring(replaceLastIndex_1, replaceMatch_1.index);
            var replaceInput_1 = replaceMatch_1[0];
            var decodeResult_1 = replaceInput_1;
            var decodeEntityLastChar_2 = replaceInput_1[replaceInput_1.length - 1];
            if (isAttribute && decodeEntityLastChar_2 === '=') decodeResult_1 = replaceInput_1;
            else if (isStrict && decodeEntityLastChar_2 !== ';') decodeResult_1 = replaceInput_1;
            else {
                var decodeResultByReference_2 = references[replaceInput_1];
                if (decodeResultByReference_2) decodeResult_1 = decodeResultByReference_2;
                else if (replaceInput_1[0] === '&' && replaceInput_1[1] === '#') {
                    var decodeSecondChar_2 = replaceInput_1[2];
                    var decodeCode_2 = decodeSecondChar_2 == 'x' || decodeSecondChar_2 == 'X' ? parseInt(replaceInput_1.substr(3), 16) : parseInt(replaceInput_1.substr(2));
                    decodeResult_1 = decodeCode_2 >= 1114111 ? outOfBoundsChar : decodeCode_2 > 65535 ? surrogate_pairs_1.fromCodePoint(decodeCode_2) : fromCharCode(numeric_unicode_map_1.numericUnicodeMap[decodeCode_2] || decodeCode_2);
                }
            }
            replaceResult_1 += decodeResult_1;
            replaceLastIndex_1 = replaceMatch_1.index + replaceInput_1.length;
        }while (replaceMatch_1 = decodeRegExp.exec(text))
        if (replaceLastIndex_1 !== text.length) replaceResult_1 += text.substring(replaceLastIndex_1);
    } else replaceResult_1 = text;
    return replaceResult_1;
}
exports.decode = decode;

},{"./named-references":"baHYB","./numeric-unicode-map":"2RgqP","./surrogate-pairs":"4YHvO"}],"baHYB":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bodyRegExps = {
    xml: /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g,
    html4: /&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g,
    html5: /&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g
};
exports.namedReferences = {
    xml: {
        entities: {
            "&lt;": "<",
            "&gt;": ">",
            "&quot;": '"',
            "&apos;": "'",
            "&amp;": "&"
        },
        characters: {
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&apos;",
            "&": "&amp;"
        }
    },
    html4: {
        entities: {
            "&apos;": "'",
            "&nbsp": " ",
            "&nbsp;": " ",
            "&iexcl": "¡",
            "&iexcl;": "¡",
            "&cent": "¢",
            "&cent;": "¢",
            "&pound": "£",
            "&pound;": "£",
            "&curren": "¤",
            "&curren;": "¤",
            "&yen": "¥",
            "&yen;": "¥",
            "&brvbar": "¦",
            "&brvbar;": "¦",
            "&sect": "§",
            "&sect;": "§",
            "&uml": "¨",
            "&uml;": "¨",
            "&copy": "©",
            "&copy;": "©",
            "&ordf": "ª",
            "&ordf;": "ª",
            "&laquo": "«",
            "&laquo;": "«",
            "&not": "¬",
            "&not;": "¬",
            "&shy": "­",
            "&shy;": "­",
            "&reg": "®",
            "&reg;": "®",
            "&macr": "¯",
            "&macr;": "¯",
            "&deg": "°",
            "&deg;": "°",
            "&plusmn": "±",
            "&plusmn;": "±",
            "&sup2": "²",
            "&sup2;": "²",
            "&sup3": "³",
            "&sup3;": "³",
            "&acute": "´",
            "&acute;": "´",
            "&micro": "µ",
            "&micro;": "µ",
            "&para": "¶",
            "&para;": "¶",
            "&middot": "·",
            "&middot;": "·",
            "&cedil": "¸",
            "&cedil;": "¸",
            "&sup1": "¹",
            "&sup1;": "¹",
            "&ordm": "º",
            "&ordm;": "º",
            "&raquo": "»",
            "&raquo;": "»",
            "&frac14": "¼",
            "&frac14;": "¼",
            "&frac12": "½",
            "&frac12;": "½",
            "&frac34": "¾",
            "&frac34;": "¾",
            "&iquest": "¿",
            "&iquest;": "¿",
            "&Agrave": "À",
            "&Agrave;": "À",
            "&Aacute": "Á",
            "&Aacute;": "Á",
            "&Acirc": "Â",
            "&Acirc;": "Â",
            "&Atilde": "Ã",
            "&Atilde;": "Ã",
            "&Auml": "Ä",
            "&Auml;": "Ä",
            "&Aring": "Å",
            "&Aring;": "Å",
            "&AElig": "Æ",
            "&AElig;": "Æ",
            "&Ccedil": "Ç",
            "&Ccedil;": "Ç",
            "&Egrave": "È",
            "&Egrave;": "È",
            "&Eacute": "É",
            "&Eacute;": "É",
            "&Ecirc": "Ê",
            "&Ecirc;": "Ê",
            "&Euml": "Ë",
            "&Euml;": "Ë",
            "&Igrave": "Ì",
            "&Igrave;": "Ì",
            "&Iacute": "Í",
            "&Iacute;": "Í",
            "&Icirc": "Î",
            "&Icirc;": "Î",
            "&Iuml": "Ï",
            "&Iuml;": "Ï",
            "&ETH": "Ð",
            "&ETH;": "Ð",
            "&Ntilde": "Ñ",
            "&Ntilde;": "Ñ",
            "&Ograve": "Ò",
            "&Ograve;": "Ò",
            "&Oacute": "Ó",
            "&Oacute;": "Ó",
            "&Ocirc": "Ô",
            "&Ocirc;": "Ô",
            "&Otilde": "Õ",
            "&Otilde;": "Õ",
            "&Ouml": "Ö",
            "&Ouml;": "Ö",
            "&times": "×",
            "&times;": "×",
            "&Oslash": "Ø",
            "&Oslash;": "Ø",
            "&Ugrave": "Ù",
            "&Ugrave;": "Ù",
            "&Uacute": "Ú",
            "&Uacute;": "Ú",
            "&Ucirc": "Û",
            "&Ucirc;": "Û",
            "&Uuml": "Ü",
            "&Uuml;": "Ü",
            "&Yacute": "Ý",
            "&Yacute;": "Ý",
            "&THORN": "Þ",
            "&THORN;": "Þ",
            "&szlig": "ß",
            "&szlig;": "ß",
            "&agrave": "à",
            "&agrave;": "à",
            "&aacute": "á",
            "&aacute;": "á",
            "&acirc": "â",
            "&acirc;": "â",
            "&atilde": "ã",
            "&atilde;": "ã",
            "&auml": "ä",
            "&auml;": "ä",
            "&aring": "å",
            "&aring;": "å",
            "&aelig": "æ",
            "&aelig;": "æ",
            "&ccedil": "ç",
            "&ccedil;": "ç",
            "&egrave": "è",
            "&egrave;": "è",
            "&eacute": "é",
            "&eacute;": "é",
            "&ecirc": "ê",
            "&ecirc;": "ê",
            "&euml": "ë",
            "&euml;": "ë",
            "&igrave": "ì",
            "&igrave;": "ì",
            "&iacute": "í",
            "&iacute;": "í",
            "&icirc": "î",
            "&icirc;": "î",
            "&iuml": "ï",
            "&iuml;": "ï",
            "&eth": "ð",
            "&eth;": "ð",
            "&ntilde": "ñ",
            "&ntilde;": "ñ",
            "&ograve": "ò",
            "&ograve;": "ò",
            "&oacute": "ó",
            "&oacute;": "ó",
            "&ocirc": "ô",
            "&ocirc;": "ô",
            "&otilde": "õ",
            "&otilde;": "õ",
            "&ouml": "ö",
            "&ouml;": "ö",
            "&divide": "÷",
            "&divide;": "÷",
            "&oslash": "ø",
            "&oslash;": "ø",
            "&ugrave": "ù",
            "&ugrave;": "ù",
            "&uacute": "ú",
            "&uacute;": "ú",
            "&ucirc": "û",
            "&ucirc;": "û",
            "&uuml": "ü",
            "&uuml;": "ü",
            "&yacute": "ý",
            "&yacute;": "ý",
            "&thorn": "þ",
            "&thorn;": "þ",
            "&yuml": "ÿ",
            "&yuml;": "ÿ",
            "&quot": '"',
            "&quot;": '"',
            "&amp": "&",
            "&amp;": "&",
            "&lt": "<",
            "&lt;": "<",
            "&gt": ">",
            "&gt;": ">",
            "&OElig;": "Œ",
            "&oelig;": "œ",
            "&Scaron;": "Š",
            "&scaron;": "š",
            "&Yuml;": "Ÿ",
            "&circ;": "ˆ",
            "&tilde;": "˜",
            "&ensp;": " ",
            "&emsp;": " ",
            "&thinsp;": " ",
            "&zwnj;": "‌",
            "&zwj;": "‍",
            "&lrm;": "‎",
            "&rlm;": "‏",
            "&ndash;": "–",
            "&mdash;": "—",
            "&lsquo;": "‘",
            "&rsquo;": "’",
            "&sbquo;": "‚",
            "&ldquo;": "“",
            "&rdquo;": "”",
            "&bdquo;": "„",
            "&dagger;": "†",
            "&Dagger;": "‡",
            "&permil;": "‰",
            "&lsaquo;": "‹",
            "&rsaquo;": "›",
            "&euro;": "€",
            "&fnof;": "ƒ",
            "&Alpha;": "Α",
            "&Beta;": "Β",
            "&Gamma;": "Γ",
            "&Delta;": "Δ",
            "&Epsilon;": "Ε",
            "&Zeta;": "Ζ",
            "&Eta;": "Η",
            "&Theta;": "Θ",
            "&Iota;": "Ι",
            "&Kappa;": "Κ",
            "&Lambda;": "Λ",
            "&Mu;": "Μ",
            "&Nu;": "Ν",
            "&Xi;": "Ξ",
            "&Omicron;": "Ο",
            "&Pi;": "Π",
            "&Rho;": "Ρ",
            "&Sigma;": "Σ",
            "&Tau;": "Τ",
            "&Upsilon;": "Υ",
            "&Phi;": "Φ",
            "&Chi;": "Χ",
            "&Psi;": "Ψ",
            "&Omega;": "Ω",
            "&alpha;": "α",
            "&beta;": "β",
            "&gamma;": "γ",
            "&delta;": "δ",
            "&epsilon;": "ε",
            "&zeta;": "ζ",
            "&eta;": "η",
            "&theta;": "θ",
            "&iota;": "ι",
            "&kappa;": "κ",
            "&lambda;": "λ",
            "&mu;": "μ",
            "&nu;": "ν",
            "&xi;": "ξ",
            "&omicron;": "ο",
            "&pi;": "π",
            "&rho;": "ρ",
            "&sigmaf;": "ς",
            "&sigma;": "σ",
            "&tau;": "τ",
            "&upsilon;": "υ",
            "&phi;": "φ",
            "&chi;": "χ",
            "&psi;": "ψ",
            "&omega;": "ω",
            "&thetasym;": "ϑ",
            "&upsih;": "ϒ",
            "&piv;": "ϖ",
            "&bull;": "•",
            "&hellip;": "…",
            "&prime;": "′",
            "&Prime;": "″",
            "&oline;": "‾",
            "&frasl;": "⁄",
            "&weierp;": "℘",
            "&image;": "ℑ",
            "&real;": "ℜ",
            "&trade;": "™",
            "&alefsym;": "ℵ",
            "&larr;": "←",
            "&uarr;": "↑",
            "&rarr;": "→",
            "&darr;": "↓",
            "&harr;": "↔",
            "&crarr;": "↵",
            "&lArr;": "⇐",
            "&uArr;": "⇑",
            "&rArr;": "⇒",
            "&dArr;": "⇓",
            "&hArr;": "⇔",
            "&forall;": "∀",
            "&part;": "∂",
            "&exist;": "∃",
            "&empty;": "∅",
            "&nabla;": "∇",
            "&isin;": "∈",
            "&notin;": "∉",
            "&ni;": "∋",
            "&prod;": "∏",
            "&sum;": "∑",
            "&minus;": "−",
            "&lowast;": "∗",
            "&radic;": "√",
            "&prop;": "∝",
            "&infin;": "∞",
            "&ang;": "∠",
            "&and;": "∧",
            "&or;": "∨",
            "&cap;": "∩",
            "&cup;": "∪",
            "&int;": "∫",
            "&there4;": "∴",
            "&sim;": "∼",
            "&cong;": "≅",
            "&asymp;": "≈",
            "&ne;": "≠",
            "&equiv;": "≡",
            "&le;": "≤",
            "&ge;": "≥",
            "&sub;": "⊂",
            "&sup;": "⊃",
            "&nsub;": "⊄",
            "&sube;": "⊆",
            "&supe;": "⊇",
            "&oplus;": "⊕",
            "&otimes;": "⊗",
            "&perp;": "⊥",
            "&sdot;": "⋅",
            "&lceil;": "⌈",
            "&rceil;": "⌉",
            "&lfloor;": "⌊",
            "&rfloor;": "⌋",
            "&lang;": "〈",
            "&rang;": "〉",
            "&loz;": "◊",
            "&spades;": "♠",
            "&clubs;": "♣",
            "&hearts;": "♥",
            "&diams;": "♦"
        },
        characters: {
            "'": "&apos;",
            " ": "&nbsp;",
            "¡": "&iexcl;",
            "¢": "&cent;",
            "£": "&pound;",
            "¤": "&curren;",
            "¥": "&yen;",
            "¦": "&brvbar;",
            "§": "&sect;",
            "¨": "&uml;",
            "©": "&copy;",
            "ª": "&ordf;",
            "«": "&laquo;",
            "¬": "&not;",
            "­": "&shy;",
            "®": "&reg;",
            "¯": "&macr;",
            "°": "&deg;",
            "±": "&plusmn;",
            "²": "&sup2;",
            "³": "&sup3;",
            "´": "&acute;",
            "µ": "&micro;",
            "¶": "&para;",
            "·": "&middot;",
            "¸": "&cedil;",
            "¹": "&sup1;",
            "º": "&ordm;",
            "»": "&raquo;",
            "¼": "&frac14;",
            "½": "&frac12;",
            "¾": "&frac34;",
            "¿": "&iquest;",
            "À": "&Agrave;",
            "Á": "&Aacute;",
            "Â": "&Acirc;",
            "Ã": "&Atilde;",
            "Ä": "&Auml;",
            "Å": "&Aring;",
            "Æ": "&AElig;",
            "Ç": "&Ccedil;",
            "È": "&Egrave;",
            "É": "&Eacute;",
            "Ê": "&Ecirc;",
            "Ë": "&Euml;",
            "Ì": "&Igrave;",
            "Í": "&Iacute;",
            "Î": "&Icirc;",
            "Ï": "&Iuml;",
            "Ð": "&ETH;",
            "Ñ": "&Ntilde;",
            "Ò": "&Ograve;",
            "Ó": "&Oacute;",
            "Ô": "&Ocirc;",
            "Õ": "&Otilde;",
            "Ö": "&Ouml;",
            "×": "&times;",
            "Ø": "&Oslash;",
            "Ù": "&Ugrave;",
            "Ú": "&Uacute;",
            "Û": "&Ucirc;",
            "Ü": "&Uuml;",
            "Ý": "&Yacute;",
            "Þ": "&THORN;",
            "ß": "&szlig;",
            "à": "&agrave;",
            "á": "&aacute;",
            "â": "&acirc;",
            "ã": "&atilde;",
            "ä": "&auml;",
            "å": "&aring;",
            "æ": "&aelig;",
            "ç": "&ccedil;",
            "è": "&egrave;",
            "é": "&eacute;",
            "ê": "&ecirc;",
            "ë": "&euml;",
            "ì": "&igrave;",
            "í": "&iacute;",
            "î": "&icirc;",
            "ï": "&iuml;",
            "ð": "&eth;",
            "ñ": "&ntilde;",
            "ò": "&ograve;",
            "ó": "&oacute;",
            "ô": "&ocirc;",
            "õ": "&otilde;",
            "ö": "&ouml;",
            "÷": "&divide;",
            "ø": "&oslash;",
            "ù": "&ugrave;",
            "ú": "&uacute;",
            "û": "&ucirc;",
            "ü": "&uuml;",
            "ý": "&yacute;",
            "þ": "&thorn;",
            "ÿ": "&yuml;",
            '"': "&quot;",
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            "Œ": "&OElig;",
            "œ": "&oelig;",
            "Š": "&Scaron;",
            "š": "&scaron;",
            "Ÿ": "&Yuml;",
            "ˆ": "&circ;",
            "˜": "&tilde;",
            " ": "&ensp;",
            " ": "&emsp;",
            " ": "&thinsp;",
            "‌": "&zwnj;",
            "‍": "&zwj;",
            "‎": "&lrm;",
            "‏": "&rlm;",
            "–": "&ndash;",
            "—": "&mdash;",
            "‘": "&lsquo;",
            "’": "&rsquo;",
            "‚": "&sbquo;",
            "“": "&ldquo;",
            "”": "&rdquo;",
            "„": "&bdquo;",
            "†": "&dagger;",
            "‡": "&Dagger;",
            "‰": "&permil;",
            "‹": "&lsaquo;",
            "›": "&rsaquo;",
            "€": "&euro;",
            "ƒ": "&fnof;",
            "Α": "&Alpha;",
            "Β": "&Beta;",
            "Γ": "&Gamma;",
            "Δ": "&Delta;",
            "Ε": "&Epsilon;",
            "Ζ": "&Zeta;",
            "Η": "&Eta;",
            "Θ": "&Theta;",
            "Ι": "&Iota;",
            "Κ": "&Kappa;",
            "Λ": "&Lambda;",
            "Μ": "&Mu;",
            "Ν": "&Nu;",
            "Ξ": "&Xi;",
            "Ο": "&Omicron;",
            "Π": "&Pi;",
            "Ρ": "&Rho;",
            "Σ": "&Sigma;",
            "Τ": "&Tau;",
            "Υ": "&Upsilon;",
            "Φ": "&Phi;",
            "Χ": "&Chi;",
            "Ψ": "&Psi;",
            "Ω": "&Omega;",
            "α": "&alpha;",
            "β": "&beta;",
            "γ": "&gamma;",
            "δ": "&delta;",
            "ε": "&epsilon;",
            "ζ": "&zeta;",
            "η": "&eta;",
            "θ": "&theta;",
            "ι": "&iota;",
            "κ": "&kappa;",
            "λ": "&lambda;",
            "μ": "&mu;",
            "ν": "&nu;",
            "ξ": "&xi;",
            "ο": "&omicron;",
            "π": "&pi;",
            "ρ": "&rho;",
            "ς": "&sigmaf;",
            "σ": "&sigma;",
            "τ": "&tau;",
            "υ": "&upsilon;",
            "φ": "&phi;",
            "χ": "&chi;",
            "ψ": "&psi;",
            "ω": "&omega;",
            "ϑ": "&thetasym;",
            "ϒ": "&upsih;",
            "ϖ": "&piv;",
            "•": "&bull;",
            "…": "&hellip;",
            "′": "&prime;",
            "″": "&Prime;",
            "‾": "&oline;",
            "⁄": "&frasl;",
            "℘": "&weierp;",
            "ℑ": "&image;",
            "ℜ": "&real;",
            "™": "&trade;",
            "ℵ": "&alefsym;",
            "←": "&larr;",
            "↑": "&uarr;",
            "→": "&rarr;",
            "↓": "&darr;",
            "↔": "&harr;",
            "↵": "&crarr;",
            "⇐": "&lArr;",
            "⇑": "&uArr;",
            "⇒": "&rArr;",
            "⇓": "&dArr;",
            "⇔": "&hArr;",
            "∀": "&forall;",
            "∂": "&part;",
            "∃": "&exist;",
            "∅": "&empty;",
            "∇": "&nabla;",
            "∈": "&isin;",
            "∉": "&notin;",
            "∋": "&ni;",
            "∏": "&prod;",
            "∑": "&sum;",
            "−": "&minus;",
            "∗": "&lowast;",
            "√": "&radic;",
            "∝": "&prop;",
            "∞": "&infin;",
            "∠": "&ang;",
            "∧": "&and;",
            "∨": "&or;",
            "∩": "&cap;",
            "∪": "&cup;",
            "∫": "&int;",
            "∴": "&there4;",
            "∼": "&sim;",
            "≅": "&cong;",
            "≈": "&asymp;",
            "≠": "&ne;",
            "≡": "&equiv;",
            "≤": "&le;",
            "≥": "&ge;",
            "⊂": "&sub;",
            "⊃": "&sup;",
            "⊄": "&nsub;",
            "⊆": "&sube;",
            "⊇": "&supe;",
            "⊕": "&oplus;",
            "⊗": "&otimes;",
            "⊥": "&perp;",
            "⋅": "&sdot;",
            "⌈": "&lceil;",
            "⌉": "&rceil;",
            "⌊": "&lfloor;",
            "⌋": "&rfloor;",
            "〈": "&lang;",
            "〉": "&rang;",
            "◊": "&loz;",
            "♠": "&spades;",
            "♣": "&clubs;",
            "♥": "&hearts;",
            "♦": "&diams;"
        }
    },
    html5: {
        entities: {
            "&AElig": "Æ",
            "&AElig;": "Æ",
            "&AMP": "&",
            "&AMP;": "&",
            "&Aacute": "Á",
            "&Aacute;": "Á",
            "&Abreve;": "Ă",
            "&Acirc": "Â",
            "&Acirc;": "Â",
            "&Acy;": "А",
            "&Afr;": "𝔄",
            "&Agrave": "À",
            "&Agrave;": "À",
            "&Alpha;": "Α",
            "&Amacr;": "Ā",
            "&And;": "⩓",
            "&Aogon;": "Ą",
            "&Aopf;": "𝔸",
            "&ApplyFunction;": "⁡",
            "&Aring": "Å",
            "&Aring;": "Å",
            "&Ascr;": "𝒜",
            "&Assign;": "≔",
            "&Atilde": "Ã",
            "&Atilde;": "Ã",
            "&Auml": "Ä",
            "&Auml;": "Ä",
            "&Backslash;": "∖",
            "&Barv;": "⫧",
            "&Barwed;": "⌆",
            "&Bcy;": "Б",
            "&Because;": "∵",
            "&Bernoullis;": "ℬ",
            "&Beta;": "Β",
            "&Bfr;": "𝔅",
            "&Bopf;": "𝔹",
            "&Breve;": "˘",
            "&Bscr;": "ℬ",
            "&Bumpeq;": "≎",
            "&CHcy;": "Ч",
            "&COPY": "©",
            "&COPY;": "©",
            "&Cacute;": "Ć",
            "&Cap;": "⋒",
            "&CapitalDifferentialD;": "ⅅ",
            "&Cayleys;": "ℭ",
            "&Ccaron;": "Č",
            "&Ccedil": "Ç",
            "&Ccedil;": "Ç",
            "&Ccirc;": "Ĉ",
            "&Cconint;": "∰",
            "&Cdot;": "Ċ",
            "&Cedilla;": "¸",
            "&CenterDot;": "·",
            "&Cfr;": "ℭ",
            "&Chi;": "Χ",
            "&CircleDot;": "⊙",
            "&CircleMinus;": "⊖",
            "&CirclePlus;": "⊕",
            "&CircleTimes;": "⊗",
            "&ClockwiseContourIntegral;": "∲",
            "&CloseCurlyDoubleQuote;": "”",
            "&CloseCurlyQuote;": "’",
            "&Colon;": "∷",
            "&Colone;": "⩴",
            "&Congruent;": "≡",
            "&Conint;": "∯",
            "&ContourIntegral;": "∮",
            "&Copf;": "ℂ",
            "&Coproduct;": "∐",
            "&CounterClockwiseContourIntegral;": "∳",
            "&Cross;": "⨯",
            "&Cscr;": "𝒞",
            "&Cup;": "⋓",
            "&CupCap;": "≍",
            "&DD;": "ⅅ",
            "&DDotrahd;": "⤑",
            "&DJcy;": "Ђ",
            "&DScy;": "Ѕ",
            "&DZcy;": "Џ",
            "&Dagger;": "‡",
            "&Darr;": "↡",
            "&Dashv;": "⫤",
            "&Dcaron;": "Ď",
            "&Dcy;": "Д",
            "&Del;": "∇",
            "&Delta;": "Δ",
            "&Dfr;": "𝔇",
            "&DiacriticalAcute;": "´",
            "&DiacriticalDot;": "˙",
            "&DiacriticalDoubleAcute;": "˝",
            "&DiacriticalGrave;": "`",
            "&DiacriticalTilde;": "˜",
            "&Diamond;": "⋄",
            "&DifferentialD;": "ⅆ",
            "&Dopf;": "𝔻",
            "&Dot;": "¨",
            "&DotDot;": "⃜",
            "&DotEqual;": "≐",
            "&DoubleContourIntegral;": "∯",
            "&DoubleDot;": "¨",
            "&DoubleDownArrow;": "⇓",
            "&DoubleLeftArrow;": "⇐",
            "&DoubleLeftRightArrow;": "⇔",
            "&DoubleLeftTee;": "⫤",
            "&DoubleLongLeftArrow;": "⟸",
            "&DoubleLongLeftRightArrow;": "⟺",
            "&DoubleLongRightArrow;": "⟹",
            "&DoubleRightArrow;": "⇒",
            "&DoubleRightTee;": "⊨",
            "&DoubleUpArrow;": "⇑",
            "&DoubleUpDownArrow;": "⇕",
            "&DoubleVerticalBar;": "∥",
            "&DownArrow;": "↓",
            "&DownArrowBar;": "⤓",
            "&DownArrowUpArrow;": "⇵",
            "&DownBreve;": "̑",
            "&DownLeftRightVector;": "⥐",
            "&DownLeftTeeVector;": "⥞",
            "&DownLeftVector;": "↽",
            "&DownLeftVectorBar;": "⥖",
            "&DownRightTeeVector;": "⥟",
            "&DownRightVector;": "⇁",
            "&DownRightVectorBar;": "⥗",
            "&DownTee;": "⊤",
            "&DownTeeArrow;": "↧",
            "&Downarrow;": "⇓",
            "&Dscr;": "𝒟",
            "&Dstrok;": "Đ",
            "&ENG;": "Ŋ",
            "&ETH": "Ð",
            "&ETH;": "Ð",
            "&Eacute": "É",
            "&Eacute;": "É",
            "&Ecaron;": "Ě",
            "&Ecirc": "Ê",
            "&Ecirc;": "Ê",
            "&Ecy;": "Э",
            "&Edot;": "Ė",
            "&Efr;": "𝔈",
            "&Egrave": "È",
            "&Egrave;": "È",
            "&Element;": "∈",
            "&Emacr;": "Ē",
            "&EmptySmallSquare;": "◻",
            "&EmptyVerySmallSquare;": "▫",
            "&Eogon;": "Ę",
            "&Eopf;": "𝔼",
            "&Epsilon;": "Ε",
            "&Equal;": "⩵",
            "&EqualTilde;": "≂",
            "&Equilibrium;": "⇌",
            "&Escr;": "ℰ",
            "&Esim;": "⩳",
            "&Eta;": "Η",
            "&Euml": "Ë",
            "&Euml;": "Ë",
            "&Exists;": "∃",
            "&ExponentialE;": "ⅇ",
            "&Fcy;": "Ф",
            "&Ffr;": "𝔉",
            "&FilledSmallSquare;": "◼",
            "&FilledVerySmallSquare;": "▪",
            "&Fopf;": "𝔽",
            "&ForAll;": "∀",
            "&Fouriertrf;": "ℱ",
            "&Fscr;": "ℱ",
            "&GJcy;": "Ѓ",
            "&GT": ">",
            "&GT;": ">",
            "&Gamma;": "Γ",
            "&Gammad;": "Ϝ",
            "&Gbreve;": "Ğ",
            "&Gcedil;": "Ģ",
            "&Gcirc;": "Ĝ",
            "&Gcy;": "Г",
            "&Gdot;": "Ġ",
            "&Gfr;": "𝔊",
            "&Gg;": "⋙",
            "&Gopf;": "𝔾",
            "&GreaterEqual;": "≥",
            "&GreaterEqualLess;": "⋛",
            "&GreaterFullEqual;": "≧",
            "&GreaterGreater;": "⪢",
            "&GreaterLess;": "≷",
            "&GreaterSlantEqual;": "⩾",
            "&GreaterTilde;": "≳",
            "&Gscr;": "𝒢",
            "&Gt;": "≫",
            "&HARDcy;": "Ъ",
            "&Hacek;": "ˇ",
            "&Hat;": "^",
            "&Hcirc;": "Ĥ",
            "&Hfr;": "ℌ",
            "&HilbertSpace;": "ℋ",
            "&Hopf;": "ℍ",
            "&HorizontalLine;": "─",
            "&Hscr;": "ℋ",
            "&Hstrok;": "Ħ",
            "&HumpDownHump;": "≎",
            "&HumpEqual;": "≏",
            "&IEcy;": "Е",
            "&IJlig;": "Ĳ",
            "&IOcy;": "Ё",
            "&Iacute": "Í",
            "&Iacute;": "Í",
            "&Icirc": "Î",
            "&Icirc;": "Î",
            "&Icy;": "И",
            "&Idot;": "İ",
            "&Ifr;": "ℑ",
            "&Igrave": "Ì",
            "&Igrave;": "Ì",
            "&Im;": "ℑ",
            "&Imacr;": "Ī",
            "&ImaginaryI;": "ⅈ",
            "&Implies;": "⇒",
            "&Int;": "∬",
            "&Integral;": "∫",
            "&Intersection;": "⋂",
            "&InvisibleComma;": "⁣",
            "&InvisibleTimes;": "⁢",
            "&Iogon;": "Į",
            "&Iopf;": "𝕀",
            "&Iota;": "Ι",
            "&Iscr;": "ℐ",
            "&Itilde;": "Ĩ",
            "&Iukcy;": "І",
            "&Iuml": "Ï",
            "&Iuml;": "Ï",
            "&Jcirc;": "Ĵ",
            "&Jcy;": "Й",
            "&Jfr;": "𝔍",
            "&Jopf;": "𝕁",
            "&Jscr;": "𝒥",
            "&Jsercy;": "Ј",
            "&Jukcy;": "Є",
            "&KHcy;": "Х",
            "&KJcy;": "Ќ",
            "&Kappa;": "Κ",
            "&Kcedil;": "Ķ",
            "&Kcy;": "К",
            "&Kfr;": "𝔎",
            "&Kopf;": "𝕂",
            "&Kscr;": "𝒦",
            "&LJcy;": "Љ",
            "&LT": "<",
            "&LT;": "<",
            "&Lacute;": "Ĺ",
            "&Lambda;": "Λ",
            "&Lang;": "⟪",
            "&Laplacetrf;": "ℒ",
            "&Larr;": "↞",
            "&Lcaron;": "Ľ",
            "&Lcedil;": "Ļ",
            "&Lcy;": "Л",
            "&LeftAngleBracket;": "⟨",
            "&LeftArrow;": "←",
            "&LeftArrowBar;": "⇤",
            "&LeftArrowRightArrow;": "⇆",
            "&LeftCeiling;": "⌈",
            "&LeftDoubleBracket;": "⟦",
            "&LeftDownTeeVector;": "⥡",
            "&LeftDownVector;": "⇃",
            "&LeftDownVectorBar;": "⥙",
            "&LeftFloor;": "⌊",
            "&LeftRightArrow;": "↔",
            "&LeftRightVector;": "⥎",
            "&LeftTee;": "⊣",
            "&LeftTeeArrow;": "↤",
            "&LeftTeeVector;": "⥚",
            "&LeftTriangle;": "⊲",
            "&LeftTriangleBar;": "⧏",
            "&LeftTriangleEqual;": "⊴",
            "&LeftUpDownVector;": "⥑",
            "&LeftUpTeeVector;": "⥠",
            "&LeftUpVector;": "↿",
            "&LeftUpVectorBar;": "⥘",
            "&LeftVector;": "↼",
            "&LeftVectorBar;": "⥒",
            "&Leftarrow;": "⇐",
            "&Leftrightarrow;": "⇔",
            "&LessEqualGreater;": "⋚",
            "&LessFullEqual;": "≦",
            "&LessGreater;": "≶",
            "&LessLess;": "⪡",
            "&LessSlantEqual;": "⩽",
            "&LessTilde;": "≲",
            "&Lfr;": "𝔏",
            "&Ll;": "⋘",
            "&Lleftarrow;": "⇚",
            "&Lmidot;": "Ŀ",
            "&LongLeftArrow;": "⟵",
            "&LongLeftRightArrow;": "⟷",
            "&LongRightArrow;": "⟶",
            "&Longleftarrow;": "⟸",
            "&Longleftrightarrow;": "⟺",
            "&Longrightarrow;": "⟹",
            "&Lopf;": "𝕃",
            "&LowerLeftArrow;": "↙",
            "&LowerRightArrow;": "↘",
            "&Lscr;": "ℒ",
            "&Lsh;": "↰",
            "&Lstrok;": "Ł",
            "&Lt;": "≪",
            "&Map;": "⤅",
            "&Mcy;": "М",
            "&MediumSpace;": " ",
            "&Mellintrf;": "ℳ",
            "&Mfr;": "𝔐",
            "&MinusPlus;": "∓",
            "&Mopf;": "𝕄",
            "&Mscr;": "ℳ",
            "&Mu;": "Μ",
            "&NJcy;": "Њ",
            "&Nacute;": "Ń",
            "&Ncaron;": "Ň",
            "&Ncedil;": "Ņ",
            "&Ncy;": "Н",
            "&NegativeMediumSpace;": "​",
            "&NegativeThickSpace;": "​",
            "&NegativeThinSpace;": "​",
            "&NegativeVeryThinSpace;": "​",
            "&NestedGreaterGreater;": "≫",
            "&NestedLessLess;": "≪",
            "&NewLine;": "\n",
            "&Nfr;": "𝔑",
            "&NoBreak;": "⁠",
            "&NonBreakingSpace;": " ",
            "&Nopf;": "ℕ",
            "&Not;": "⫬",
            "&NotCongruent;": "≢",
            "&NotCupCap;": "≭",
            "&NotDoubleVerticalBar;": "∦",
            "&NotElement;": "∉",
            "&NotEqual;": "≠",
            "&NotEqualTilde;": "≂̸",
            "&NotExists;": "∄",
            "&NotGreater;": "≯",
            "&NotGreaterEqual;": "≱",
            "&NotGreaterFullEqual;": "≧̸",
            "&NotGreaterGreater;": "≫̸",
            "&NotGreaterLess;": "≹",
            "&NotGreaterSlantEqual;": "⩾̸",
            "&NotGreaterTilde;": "≵",
            "&NotHumpDownHump;": "≎̸",
            "&NotHumpEqual;": "≏̸",
            "&NotLeftTriangle;": "⋪",
            "&NotLeftTriangleBar;": "⧏̸",
            "&NotLeftTriangleEqual;": "⋬",
            "&NotLess;": "≮",
            "&NotLessEqual;": "≰",
            "&NotLessGreater;": "≸",
            "&NotLessLess;": "≪̸",
            "&NotLessSlantEqual;": "⩽̸",
            "&NotLessTilde;": "≴",
            "&NotNestedGreaterGreater;": "⪢̸",
            "&NotNestedLessLess;": "⪡̸",
            "&NotPrecedes;": "⊀",
            "&NotPrecedesEqual;": "⪯̸",
            "&NotPrecedesSlantEqual;": "⋠",
            "&NotReverseElement;": "∌",
            "&NotRightTriangle;": "⋫",
            "&NotRightTriangleBar;": "⧐̸",
            "&NotRightTriangleEqual;": "⋭",
            "&NotSquareSubset;": "⊏̸",
            "&NotSquareSubsetEqual;": "⋢",
            "&NotSquareSuperset;": "⊐̸",
            "&NotSquareSupersetEqual;": "⋣",
            "&NotSubset;": "⊂⃒",
            "&NotSubsetEqual;": "⊈",
            "&NotSucceeds;": "⊁",
            "&NotSucceedsEqual;": "⪰̸",
            "&NotSucceedsSlantEqual;": "⋡",
            "&NotSucceedsTilde;": "≿̸",
            "&NotSuperset;": "⊃⃒",
            "&NotSupersetEqual;": "⊉",
            "&NotTilde;": "≁",
            "&NotTildeEqual;": "≄",
            "&NotTildeFullEqual;": "≇",
            "&NotTildeTilde;": "≉",
            "&NotVerticalBar;": "∤",
            "&Nscr;": "𝒩",
            "&Ntilde": "Ñ",
            "&Ntilde;": "Ñ",
            "&Nu;": "Ν",
            "&OElig;": "Œ",
            "&Oacute": "Ó",
            "&Oacute;": "Ó",
            "&Ocirc": "Ô",
            "&Ocirc;": "Ô",
            "&Ocy;": "О",
            "&Odblac;": "Ő",
            "&Ofr;": "𝔒",
            "&Ograve": "Ò",
            "&Ograve;": "Ò",
            "&Omacr;": "Ō",
            "&Omega;": "Ω",
            "&Omicron;": "Ο",
            "&Oopf;": "𝕆",
            "&OpenCurlyDoubleQuote;": "“",
            "&OpenCurlyQuote;": "‘",
            "&Or;": "⩔",
            "&Oscr;": "𝒪",
            "&Oslash": "Ø",
            "&Oslash;": "Ø",
            "&Otilde": "Õ",
            "&Otilde;": "Õ",
            "&Otimes;": "⨷",
            "&Ouml": "Ö",
            "&Ouml;": "Ö",
            "&OverBar;": "‾",
            "&OverBrace;": "⏞",
            "&OverBracket;": "⎴",
            "&OverParenthesis;": "⏜",
            "&PartialD;": "∂",
            "&Pcy;": "П",
            "&Pfr;": "𝔓",
            "&Phi;": "Φ",
            "&Pi;": "Π",
            "&PlusMinus;": "±",
            "&Poincareplane;": "ℌ",
            "&Popf;": "ℙ",
            "&Pr;": "⪻",
            "&Precedes;": "≺",
            "&PrecedesEqual;": "⪯",
            "&PrecedesSlantEqual;": "≼",
            "&PrecedesTilde;": "≾",
            "&Prime;": "″",
            "&Product;": "∏",
            "&Proportion;": "∷",
            "&Proportional;": "∝",
            "&Pscr;": "𝒫",
            "&Psi;": "Ψ",
            "&QUOT": '"',
            "&QUOT;": '"',
            "&Qfr;": "𝔔",
            "&Qopf;": "ℚ",
            "&Qscr;": "𝒬",
            "&RBarr;": "⤐",
            "&REG": "®",
            "&REG;": "®",
            "&Racute;": "Ŕ",
            "&Rang;": "⟫",
            "&Rarr;": "↠",
            "&Rarrtl;": "⤖",
            "&Rcaron;": "Ř",
            "&Rcedil;": "Ŗ",
            "&Rcy;": "Р",
            "&Re;": "ℜ",
            "&ReverseElement;": "∋",
            "&ReverseEquilibrium;": "⇋",
            "&ReverseUpEquilibrium;": "⥯",
            "&Rfr;": "ℜ",
            "&Rho;": "Ρ",
            "&RightAngleBracket;": "⟩",
            "&RightArrow;": "→",
            "&RightArrowBar;": "⇥",
            "&RightArrowLeftArrow;": "⇄",
            "&RightCeiling;": "⌉",
            "&RightDoubleBracket;": "⟧",
            "&RightDownTeeVector;": "⥝",
            "&RightDownVector;": "⇂",
            "&RightDownVectorBar;": "⥕",
            "&RightFloor;": "⌋",
            "&RightTee;": "⊢",
            "&RightTeeArrow;": "↦",
            "&RightTeeVector;": "⥛",
            "&RightTriangle;": "⊳",
            "&RightTriangleBar;": "⧐",
            "&RightTriangleEqual;": "⊵",
            "&RightUpDownVector;": "⥏",
            "&RightUpTeeVector;": "⥜",
            "&RightUpVector;": "↾",
            "&RightUpVectorBar;": "⥔",
            "&RightVector;": "⇀",
            "&RightVectorBar;": "⥓",
            "&Rightarrow;": "⇒",
            "&Ropf;": "ℝ",
            "&RoundImplies;": "⥰",
            "&Rrightarrow;": "⇛",
            "&Rscr;": "ℛ",
            "&Rsh;": "↱",
            "&RuleDelayed;": "⧴",
            "&SHCHcy;": "Щ",
            "&SHcy;": "Ш",
            "&SOFTcy;": "Ь",
            "&Sacute;": "Ś",
            "&Sc;": "⪼",
            "&Scaron;": "Š",
            "&Scedil;": "Ş",
            "&Scirc;": "Ŝ",
            "&Scy;": "С",
            "&Sfr;": "𝔖",
            "&ShortDownArrow;": "↓",
            "&ShortLeftArrow;": "←",
            "&ShortRightArrow;": "→",
            "&ShortUpArrow;": "↑",
            "&Sigma;": "Σ",
            "&SmallCircle;": "∘",
            "&Sopf;": "𝕊",
            "&Sqrt;": "√",
            "&Square;": "□",
            "&SquareIntersection;": "⊓",
            "&SquareSubset;": "⊏",
            "&SquareSubsetEqual;": "⊑",
            "&SquareSuperset;": "⊐",
            "&SquareSupersetEqual;": "⊒",
            "&SquareUnion;": "⊔",
            "&Sscr;": "𝒮",
            "&Star;": "⋆",
            "&Sub;": "⋐",
            "&Subset;": "⋐",
            "&SubsetEqual;": "⊆",
            "&Succeeds;": "≻",
            "&SucceedsEqual;": "⪰",
            "&SucceedsSlantEqual;": "≽",
            "&SucceedsTilde;": "≿",
            "&SuchThat;": "∋",
            "&Sum;": "∑",
            "&Sup;": "⋑",
            "&Superset;": "⊃",
            "&SupersetEqual;": "⊇",
            "&Supset;": "⋑",
            "&THORN": "Þ",
            "&THORN;": "Þ",
            "&TRADE;": "™",
            "&TSHcy;": "Ћ",
            "&TScy;": "Ц",
            "&Tab;": "\t",
            "&Tau;": "Τ",
            "&Tcaron;": "Ť",
            "&Tcedil;": "Ţ",
            "&Tcy;": "Т",
            "&Tfr;": "𝔗",
            "&Therefore;": "∴",
            "&Theta;": "Θ",
            "&ThickSpace;": "  ",
            "&ThinSpace;": " ",
            "&Tilde;": "∼",
            "&TildeEqual;": "≃",
            "&TildeFullEqual;": "≅",
            "&TildeTilde;": "≈",
            "&Topf;": "𝕋",
            "&TripleDot;": "⃛",
            "&Tscr;": "𝒯",
            "&Tstrok;": "Ŧ",
            "&Uacute": "Ú",
            "&Uacute;": "Ú",
            "&Uarr;": "↟",
            "&Uarrocir;": "⥉",
            "&Ubrcy;": "Ў",
            "&Ubreve;": "Ŭ",
            "&Ucirc": "Û",
            "&Ucirc;": "Û",
            "&Ucy;": "У",
            "&Udblac;": "Ű",
            "&Ufr;": "𝔘",
            "&Ugrave": "Ù",
            "&Ugrave;": "Ù",
            "&Umacr;": "Ū",
            "&UnderBar;": "_",
            "&UnderBrace;": "⏟",
            "&UnderBracket;": "⎵",
            "&UnderParenthesis;": "⏝",
            "&Union;": "⋃",
            "&UnionPlus;": "⊎",
            "&Uogon;": "Ų",
            "&Uopf;": "𝕌",
            "&UpArrow;": "↑",
            "&UpArrowBar;": "⤒",
            "&UpArrowDownArrow;": "⇅",
            "&UpDownArrow;": "↕",
            "&UpEquilibrium;": "⥮",
            "&UpTee;": "⊥",
            "&UpTeeArrow;": "↥",
            "&Uparrow;": "⇑",
            "&Updownarrow;": "⇕",
            "&UpperLeftArrow;": "↖",
            "&UpperRightArrow;": "↗",
            "&Upsi;": "ϒ",
            "&Upsilon;": "Υ",
            "&Uring;": "Ů",
            "&Uscr;": "𝒰",
            "&Utilde;": "Ũ",
            "&Uuml": "Ü",
            "&Uuml;": "Ü",
            "&VDash;": "⊫",
            "&Vbar;": "⫫",
            "&Vcy;": "В",
            "&Vdash;": "⊩",
            "&Vdashl;": "⫦",
            "&Vee;": "⋁",
            "&Verbar;": "‖",
            "&Vert;": "‖",
            "&VerticalBar;": "∣",
            "&VerticalLine;": "|",
            "&VerticalSeparator;": "❘",
            "&VerticalTilde;": "≀",
            "&VeryThinSpace;": " ",
            "&Vfr;": "𝔙",
            "&Vopf;": "𝕍",
            "&Vscr;": "𝒱",
            "&Vvdash;": "⊪",
            "&Wcirc;": "Ŵ",
            "&Wedge;": "⋀",
            "&Wfr;": "𝔚",
            "&Wopf;": "𝕎",
            "&Wscr;": "𝒲",
            "&Xfr;": "𝔛",
            "&Xi;": "Ξ",
            "&Xopf;": "𝕏",
            "&Xscr;": "𝒳",
            "&YAcy;": "Я",
            "&YIcy;": "Ї",
            "&YUcy;": "Ю",
            "&Yacute": "Ý",
            "&Yacute;": "Ý",
            "&Ycirc;": "Ŷ",
            "&Ycy;": "Ы",
            "&Yfr;": "𝔜",
            "&Yopf;": "𝕐",
            "&Yscr;": "𝒴",
            "&Yuml;": "Ÿ",
            "&ZHcy;": "Ж",
            "&Zacute;": "Ź",
            "&Zcaron;": "Ž",
            "&Zcy;": "З",
            "&Zdot;": "Ż",
            "&ZeroWidthSpace;": "​",
            "&Zeta;": "Ζ",
            "&Zfr;": "ℨ",
            "&Zopf;": "ℤ",
            "&Zscr;": "𝒵",
            "&aacute": "á",
            "&aacute;": "á",
            "&abreve;": "ă",
            "&ac;": "∾",
            "&acE;": "∾̳",
            "&acd;": "∿",
            "&acirc": "â",
            "&acirc;": "â",
            "&acute": "´",
            "&acute;": "´",
            "&acy;": "а",
            "&aelig": "æ",
            "&aelig;": "æ",
            "&af;": "⁡",
            "&afr;": "𝔞",
            "&agrave": "à",
            "&agrave;": "à",
            "&alefsym;": "ℵ",
            "&aleph;": "ℵ",
            "&alpha;": "α",
            "&amacr;": "ā",
            "&amalg;": "⨿",
            "&amp": "&",
            "&amp;": "&",
            "&and;": "∧",
            "&andand;": "⩕",
            "&andd;": "⩜",
            "&andslope;": "⩘",
            "&andv;": "⩚",
            "&ang;": "∠",
            "&ange;": "⦤",
            "&angle;": "∠",
            "&angmsd;": "∡",
            "&angmsdaa;": "⦨",
            "&angmsdab;": "⦩",
            "&angmsdac;": "⦪",
            "&angmsdad;": "⦫",
            "&angmsdae;": "⦬",
            "&angmsdaf;": "⦭",
            "&angmsdag;": "⦮",
            "&angmsdah;": "⦯",
            "&angrt;": "∟",
            "&angrtvb;": "⊾",
            "&angrtvbd;": "⦝",
            "&angsph;": "∢",
            "&angst;": "Å",
            "&angzarr;": "⍼",
            "&aogon;": "ą",
            "&aopf;": "𝕒",
            "&ap;": "≈",
            "&apE;": "⩰",
            "&apacir;": "⩯",
            "&ape;": "≊",
            "&apid;": "≋",
            "&apos;": "'",
            "&approx;": "≈",
            "&approxeq;": "≊",
            "&aring": "å",
            "&aring;": "å",
            "&ascr;": "𝒶",
            "&ast;": "*",
            "&asymp;": "≈",
            "&asympeq;": "≍",
            "&atilde": "ã",
            "&atilde;": "ã",
            "&auml": "ä",
            "&auml;": "ä",
            "&awconint;": "∳",
            "&awint;": "⨑",
            "&bNot;": "⫭",
            "&backcong;": "≌",
            "&backepsilon;": "϶",
            "&backprime;": "‵",
            "&backsim;": "∽",
            "&backsimeq;": "⋍",
            "&barvee;": "⊽",
            "&barwed;": "⌅",
            "&barwedge;": "⌅",
            "&bbrk;": "⎵",
            "&bbrktbrk;": "⎶",
            "&bcong;": "≌",
            "&bcy;": "б",
            "&bdquo;": "„",
            "&becaus;": "∵",
            "&because;": "∵",
            "&bemptyv;": "⦰",
            "&bepsi;": "϶",
            "&bernou;": "ℬ",
            "&beta;": "β",
            "&beth;": "ℶ",
            "&between;": "≬",
            "&bfr;": "𝔟",
            "&bigcap;": "⋂",
            "&bigcirc;": "◯",
            "&bigcup;": "⋃",
            "&bigodot;": "⨀",
            "&bigoplus;": "⨁",
            "&bigotimes;": "⨂",
            "&bigsqcup;": "⨆",
            "&bigstar;": "★",
            "&bigtriangledown;": "▽",
            "&bigtriangleup;": "△",
            "&biguplus;": "⨄",
            "&bigvee;": "⋁",
            "&bigwedge;": "⋀",
            "&bkarow;": "⤍",
            "&blacklozenge;": "⧫",
            "&blacksquare;": "▪",
            "&blacktriangle;": "▴",
            "&blacktriangledown;": "▾",
            "&blacktriangleleft;": "◂",
            "&blacktriangleright;": "▸",
            "&blank;": "␣",
            "&blk12;": "▒",
            "&blk14;": "░",
            "&blk34;": "▓",
            "&block;": "█",
            "&bne;": "=⃥",
            "&bnequiv;": "≡⃥",
            "&bnot;": "⌐",
            "&bopf;": "𝕓",
            "&bot;": "⊥",
            "&bottom;": "⊥",
            "&bowtie;": "⋈",
            "&boxDL;": "╗",
            "&boxDR;": "╔",
            "&boxDl;": "╖",
            "&boxDr;": "╓",
            "&boxH;": "═",
            "&boxHD;": "╦",
            "&boxHU;": "╩",
            "&boxHd;": "╤",
            "&boxHu;": "╧",
            "&boxUL;": "╝",
            "&boxUR;": "╚",
            "&boxUl;": "╜",
            "&boxUr;": "╙",
            "&boxV;": "║",
            "&boxVH;": "╬",
            "&boxVL;": "╣",
            "&boxVR;": "╠",
            "&boxVh;": "╫",
            "&boxVl;": "╢",
            "&boxVr;": "╟",
            "&boxbox;": "⧉",
            "&boxdL;": "╕",
            "&boxdR;": "╒",
            "&boxdl;": "┐",
            "&boxdr;": "┌",
            "&boxh;": "─",
            "&boxhD;": "╥",
            "&boxhU;": "╨",
            "&boxhd;": "┬",
            "&boxhu;": "┴",
            "&boxminus;": "⊟",
            "&boxplus;": "⊞",
            "&boxtimes;": "⊠",
            "&boxuL;": "╛",
            "&boxuR;": "╘",
            "&boxul;": "┘",
            "&boxur;": "└",
            "&boxv;": "│",
            "&boxvH;": "╪",
            "&boxvL;": "╡",
            "&boxvR;": "╞",
            "&boxvh;": "┼",
            "&boxvl;": "┤",
            "&boxvr;": "├",
            "&bprime;": "‵",
            "&breve;": "˘",
            "&brvbar": "¦",
            "&brvbar;": "¦",
            "&bscr;": "𝒷",
            "&bsemi;": "⁏",
            "&bsim;": "∽",
            "&bsime;": "⋍",
            "&bsol;": "\\",
            "&bsolb;": "⧅",
            "&bsolhsub;": "⟈",
            "&bull;": "•",
            "&bullet;": "•",
            "&bump;": "≎",
            "&bumpE;": "⪮",
            "&bumpe;": "≏",
            "&bumpeq;": "≏",
            "&cacute;": "ć",
            "&cap;": "∩",
            "&capand;": "⩄",
            "&capbrcup;": "⩉",
            "&capcap;": "⩋",
            "&capcup;": "⩇",
            "&capdot;": "⩀",
            "&caps;": "∩︀",
            "&caret;": "⁁",
            "&caron;": "ˇ",
            "&ccaps;": "⩍",
            "&ccaron;": "č",
            "&ccedil": "ç",
            "&ccedil;": "ç",
            "&ccirc;": "ĉ",
            "&ccups;": "⩌",
            "&ccupssm;": "⩐",
            "&cdot;": "ċ",
            "&cedil": "¸",
            "&cedil;": "¸",
            "&cemptyv;": "⦲",
            "&cent": "¢",
            "&cent;": "¢",
            "&centerdot;": "·",
            "&cfr;": "𝔠",
            "&chcy;": "ч",
            "&check;": "✓",
            "&checkmark;": "✓",
            "&chi;": "χ",
            "&cir;": "○",
            "&cirE;": "⧃",
            "&circ;": "ˆ",
            "&circeq;": "≗",
            "&circlearrowleft;": "↺",
            "&circlearrowright;": "↻",
            "&circledR;": "®",
            "&circledS;": "Ⓢ",
            "&circledast;": "⊛",
            "&circledcirc;": "⊚",
            "&circleddash;": "⊝",
            "&cire;": "≗",
            "&cirfnint;": "⨐",
            "&cirmid;": "⫯",
            "&cirscir;": "⧂",
            "&clubs;": "♣",
            "&clubsuit;": "♣",
            "&colon;": ":",
            "&colone;": "≔",
            "&coloneq;": "≔",
            "&comma;": ",",
            "&commat;": "@",
            "&comp;": "∁",
            "&compfn;": "∘",
            "&complement;": "∁",
            "&complexes;": "ℂ",
            "&cong;": "≅",
            "&congdot;": "⩭",
            "&conint;": "∮",
            "&copf;": "𝕔",
            "&coprod;": "∐",
            "&copy": "©",
            "&copy;": "©",
            "&copysr;": "℗",
            "&crarr;": "↵",
            "&cross;": "✗",
            "&cscr;": "𝒸",
            "&csub;": "⫏",
            "&csube;": "⫑",
            "&csup;": "⫐",
            "&csupe;": "⫒",
            "&ctdot;": "⋯",
            "&cudarrl;": "⤸",
            "&cudarrr;": "⤵",
            "&cuepr;": "⋞",
            "&cuesc;": "⋟",
            "&cularr;": "↶",
            "&cularrp;": "⤽",
            "&cup;": "∪",
            "&cupbrcap;": "⩈",
            "&cupcap;": "⩆",
            "&cupcup;": "⩊",
            "&cupdot;": "⊍",
            "&cupor;": "⩅",
            "&cups;": "∪︀",
            "&curarr;": "↷",
            "&curarrm;": "⤼",
            "&curlyeqprec;": "⋞",
            "&curlyeqsucc;": "⋟",
            "&curlyvee;": "⋎",
            "&curlywedge;": "⋏",
            "&curren": "¤",
            "&curren;": "¤",
            "&curvearrowleft;": "↶",
            "&curvearrowright;": "↷",
            "&cuvee;": "⋎",
            "&cuwed;": "⋏",
            "&cwconint;": "∲",
            "&cwint;": "∱",
            "&cylcty;": "⌭",
            "&dArr;": "⇓",
            "&dHar;": "⥥",
            "&dagger;": "†",
            "&daleth;": "ℸ",
            "&darr;": "↓",
            "&dash;": "‐",
            "&dashv;": "⊣",
            "&dbkarow;": "⤏",
            "&dblac;": "˝",
            "&dcaron;": "ď",
            "&dcy;": "д",
            "&dd;": "ⅆ",
            "&ddagger;": "‡",
            "&ddarr;": "⇊",
            "&ddotseq;": "⩷",
            "&deg": "°",
            "&deg;": "°",
            "&delta;": "δ",
            "&demptyv;": "⦱",
            "&dfisht;": "⥿",
            "&dfr;": "𝔡",
            "&dharl;": "⇃",
            "&dharr;": "⇂",
            "&diam;": "⋄",
            "&diamond;": "⋄",
            "&diamondsuit;": "♦",
            "&diams;": "♦",
            "&die;": "¨",
            "&digamma;": "ϝ",
            "&disin;": "⋲",
            "&div;": "÷",
            "&divide": "÷",
            "&divide;": "÷",
            "&divideontimes;": "⋇",
            "&divonx;": "⋇",
            "&djcy;": "ђ",
            "&dlcorn;": "⌞",
            "&dlcrop;": "⌍",
            "&dollar;": "$",
            "&dopf;": "𝕕",
            "&dot;": "˙",
            "&doteq;": "≐",
            "&doteqdot;": "≑",
            "&dotminus;": "∸",
            "&dotplus;": "∔",
            "&dotsquare;": "⊡",
            "&doublebarwedge;": "⌆",
            "&downarrow;": "↓",
            "&downdownarrows;": "⇊",
            "&downharpoonleft;": "⇃",
            "&downharpoonright;": "⇂",
            "&drbkarow;": "⤐",
            "&drcorn;": "⌟",
            "&drcrop;": "⌌",
            "&dscr;": "𝒹",
            "&dscy;": "ѕ",
            "&dsol;": "⧶",
            "&dstrok;": "đ",
            "&dtdot;": "⋱",
            "&dtri;": "▿",
            "&dtrif;": "▾",
            "&duarr;": "⇵",
            "&duhar;": "⥯",
            "&dwangle;": "⦦",
            "&dzcy;": "џ",
            "&dzigrarr;": "⟿",
            "&eDDot;": "⩷",
            "&eDot;": "≑",
            "&eacute": "é",
            "&eacute;": "é",
            "&easter;": "⩮",
            "&ecaron;": "ě",
            "&ecir;": "≖",
            "&ecirc": "ê",
            "&ecirc;": "ê",
            "&ecolon;": "≕",
            "&ecy;": "э",
            "&edot;": "ė",
            "&ee;": "ⅇ",
            "&efDot;": "≒",
            "&efr;": "𝔢",
            "&eg;": "⪚",
            "&egrave": "è",
            "&egrave;": "è",
            "&egs;": "⪖",
            "&egsdot;": "⪘",
            "&el;": "⪙",
            "&elinters;": "⏧",
            "&ell;": "ℓ",
            "&els;": "⪕",
            "&elsdot;": "⪗",
            "&emacr;": "ē",
            "&empty;": "∅",
            "&emptyset;": "∅",
            "&emptyv;": "∅",
            "&emsp13;": " ",
            "&emsp14;": " ",
            "&emsp;": " ",
            "&eng;": "ŋ",
            "&ensp;": " ",
            "&eogon;": "ę",
            "&eopf;": "𝕖",
            "&epar;": "⋕",
            "&eparsl;": "⧣",
            "&eplus;": "⩱",
            "&epsi;": "ε",
            "&epsilon;": "ε",
            "&epsiv;": "ϵ",
            "&eqcirc;": "≖",
            "&eqcolon;": "≕",
            "&eqsim;": "≂",
            "&eqslantgtr;": "⪖",
            "&eqslantless;": "⪕",
            "&equals;": "=",
            "&equest;": "≟",
            "&equiv;": "≡",
            "&equivDD;": "⩸",
            "&eqvparsl;": "⧥",
            "&erDot;": "≓",
            "&erarr;": "⥱",
            "&escr;": "ℯ",
            "&esdot;": "≐",
            "&esim;": "≂",
            "&eta;": "η",
            "&eth": "ð",
            "&eth;": "ð",
            "&euml": "ë",
            "&euml;": "ë",
            "&euro;": "€",
            "&excl;": "!",
            "&exist;": "∃",
            "&expectation;": "ℰ",
            "&exponentiale;": "ⅇ",
            "&fallingdotseq;": "≒",
            "&fcy;": "ф",
            "&female;": "♀",
            "&ffilig;": "ﬃ",
            "&fflig;": "ﬀ",
            "&ffllig;": "ﬄ",
            "&ffr;": "𝔣",
            "&filig;": "ﬁ",
            "&fjlig;": "fj",
            "&flat;": "♭",
            "&fllig;": "ﬂ",
            "&fltns;": "▱",
            "&fnof;": "ƒ",
            "&fopf;": "𝕗",
            "&forall;": "∀",
            "&fork;": "⋔",
            "&forkv;": "⫙",
            "&fpartint;": "⨍",
            "&frac12": "½",
            "&frac12;": "½",
            "&frac13;": "⅓",
            "&frac14": "¼",
            "&frac14;": "¼",
            "&frac15;": "⅕",
            "&frac16;": "⅙",
            "&frac18;": "⅛",
            "&frac23;": "⅔",
            "&frac25;": "⅖",
            "&frac34": "¾",
            "&frac34;": "¾",
            "&frac35;": "⅗",
            "&frac38;": "⅜",
            "&frac45;": "⅘",
            "&frac56;": "⅚",
            "&frac58;": "⅝",
            "&frac78;": "⅞",
            "&frasl;": "⁄",
            "&frown;": "⌢",
            "&fscr;": "𝒻",
            "&gE;": "≧",
            "&gEl;": "⪌",
            "&gacute;": "ǵ",
            "&gamma;": "γ",
            "&gammad;": "ϝ",
            "&gap;": "⪆",
            "&gbreve;": "ğ",
            "&gcirc;": "ĝ",
            "&gcy;": "г",
            "&gdot;": "ġ",
            "&ge;": "≥",
            "&gel;": "⋛",
            "&geq;": "≥",
            "&geqq;": "≧",
            "&geqslant;": "⩾",
            "&ges;": "⩾",
            "&gescc;": "⪩",
            "&gesdot;": "⪀",
            "&gesdoto;": "⪂",
            "&gesdotol;": "⪄",
            "&gesl;": "⋛︀",
            "&gesles;": "⪔",
            "&gfr;": "𝔤",
            "&gg;": "≫",
            "&ggg;": "⋙",
            "&gimel;": "ℷ",
            "&gjcy;": "ѓ",
            "&gl;": "≷",
            "&glE;": "⪒",
            "&gla;": "⪥",
            "&glj;": "⪤",
            "&gnE;": "≩",
            "&gnap;": "⪊",
            "&gnapprox;": "⪊",
            "&gne;": "⪈",
            "&gneq;": "⪈",
            "&gneqq;": "≩",
            "&gnsim;": "⋧",
            "&gopf;": "𝕘",
            "&grave;": "`",
            "&gscr;": "ℊ",
            "&gsim;": "≳",
            "&gsime;": "⪎",
            "&gsiml;": "⪐",
            "&gt": ">",
            "&gt;": ">",
            "&gtcc;": "⪧",
            "&gtcir;": "⩺",
            "&gtdot;": "⋗",
            "&gtlPar;": "⦕",
            "&gtquest;": "⩼",
            "&gtrapprox;": "⪆",
            "&gtrarr;": "⥸",
            "&gtrdot;": "⋗",
            "&gtreqless;": "⋛",
            "&gtreqqless;": "⪌",
            "&gtrless;": "≷",
            "&gtrsim;": "≳",
            "&gvertneqq;": "≩︀",
            "&gvnE;": "≩︀",
            "&hArr;": "⇔",
            "&hairsp;": " ",
            "&half;": "½",
            "&hamilt;": "ℋ",
            "&hardcy;": "ъ",
            "&harr;": "↔",
            "&harrcir;": "⥈",
            "&harrw;": "↭",
            "&hbar;": "ℏ",
            "&hcirc;": "ĥ",
            "&hearts;": "♥",
            "&heartsuit;": "♥",
            "&hellip;": "…",
            "&hercon;": "⊹",
            "&hfr;": "𝔥",
            "&hksearow;": "⤥",
            "&hkswarow;": "⤦",
            "&hoarr;": "⇿",
            "&homtht;": "∻",
            "&hookleftarrow;": "↩",
            "&hookrightarrow;": "↪",
            "&hopf;": "𝕙",
            "&horbar;": "―",
            "&hscr;": "𝒽",
            "&hslash;": "ℏ",
            "&hstrok;": "ħ",
            "&hybull;": "⁃",
            "&hyphen;": "‐",
            "&iacute": "í",
            "&iacute;": "í",
            "&ic;": "⁣",
            "&icirc": "î",
            "&icirc;": "î",
            "&icy;": "и",
            "&iecy;": "е",
            "&iexcl": "¡",
            "&iexcl;": "¡",
            "&iff;": "⇔",
            "&ifr;": "𝔦",
            "&igrave": "ì",
            "&igrave;": "ì",
            "&ii;": "ⅈ",
            "&iiiint;": "⨌",
            "&iiint;": "∭",
            "&iinfin;": "⧜",
            "&iiota;": "℩",
            "&ijlig;": "ĳ",
            "&imacr;": "ī",
            "&image;": "ℑ",
            "&imagline;": "ℐ",
            "&imagpart;": "ℑ",
            "&imath;": "ı",
            "&imof;": "⊷",
            "&imped;": "Ƶ",
            "&in;": "∈",
            "&incare;": "℅",
            "&infin;": "∞",
            "&infintie;": "⧝",
            "&inodot;": "ı",
            "&int;": "∫",
            "&intcal;": "⊺",
            "&integers;": "ℤ",
            "&intercal;": "⊺",
            "&intlarhk;": "⨗",
            "&intprod;": "⨼",
            "&iocy;": "ё",
            "&iogon;": "į",
            "&iopf;": "𝕚",
            "&iota;": "ι",
            "&iprod;": "⨼",
            "&iquest": "¿",
            "&iquest;": "¿",
            "&iscr;": "𝒾",
            "&isin;": "∈",
            "&isinE;": "⋹",
            "&isindot;": "⋵",
            "&isins;": "⋴",
            "&isinsv;": "⋳",
            "&isinv;": "∈",
            "&it;": "⁢",
            "&itilde;": "ĩ",
            "&iukcy;": "і",
            "&iuml": "ï",
            "&iuml;": "ï",
            "&jcirc;": "ĵ",
            "&jcy;": "й",
            "&jfr;": "𝔧",
            "&jmath;": "ȷ",
            "&jopf;": "𝕛",
            "&jscr;": "𝒿",
            "&jsercy;": "ј",
            "&jukcy;": "є",
            "&kappa;": "κ",
            "&kappav;": "ϰ",
            "&kcedil;": "ķ",
            "&kcy;": "к",
            "&kfr;": "𝔨",
            "&kgreen;": "ĸ",
            "&khcy;": "х",
            "&kjcy;": "ќ",
            "&kopf;": "𝕜",
            "&kscr;": "𝓀",
            "&lAarr;": "⇚",
            "&lArr;": "⇐",
            "&lAtail;": "⤛",
            "&lBarr;": "⤎",
            "&lE;": "≦",
            "&lEg;": "⪋",
            "&lHar;": "⥢",
            "&lacute;": "ĺ",
            "&laemptyv;": "⦴",
            "&lagran;": "ℒ",
            "&lambda;": "λ",
            "&lang;": "⟨",
            "&langd;": "⦑",
            "&langle;": "⟨",
            "&lap;": "⪅",
            "&laquo": "«",
            "&laquo;": "«",
            "&larr;": "←",
            "&larrb;": "⇤",
            "&larrbfs;": "⤟",
            "&larrfs;": "⤝",
            "&larrhk;": "↩",
            "&larrlp;": "↫",
            "&larrpl;": "⤹",
            "&larrsim;": "⥳",
            "&larrtl;": "↢",
            "&lat;": "⪫",
            "&latail;": "⤙",
            "&late;": "⪭",
            "&lates;": "⪭︀",
            "&lbarr;": "⤌",
            "&lbbrk;": "❲",
            "&lbrace;": "{",
            "&lbrack;": "[",
            "&lbrke;": "⦋",
            "&lbrksld;": "⦏",
            "&lbrkslu;": "⦍",
            "&lcaron;": "ľ",
            "&lcedil;": "ļ",
            "&lceil;": "⌈",
            "&lcub;": "{",
            "&lcy;": "л",
            "&ldca;": "⤶",
            "&ldquo;": "“",
            "&ldquor;": "„",
            "&ldrdhar;": "⥧",
            "&ldrushar;": "⥋",
            "&ldsh;": "↲",
            "&le;": "≤",
            "&leftarrow;": "←",
            "&leftarrowtail;": "↢",
            "&leftharpoondown;": "↽",
            "&leftharpoonup;": "↼",
            "&leftleftarrows;": "⇇",
            "&leftrightarrow;": "↔",
            "&leftrightarrows;": "⇆",
            "&leftrightharpoons;": "⇋",
            "&leftrightsquigarrow;": "↭",
            "&leftthreetimes;": "⋋",
            "&leg;": "⋚",
            "&leq;": "≤",
            "&leqq;": "≦",
            "&leqslant;": "⩽",
            "&les;": "⩽",
            "&lescc;": "⪨",
            "&lesdot;": "⩿",
            "&lesdoto;": "⪁",
            "&lesdotor;": "⪃",
            "&lesg;": "⋚︀",
            "&lesges;": "⪓",
            "&lessapprox;": "⪅",
            "&lessdot;": "⋖",
            "&lesseqgtr;": "⋚",
            "&lesseqqgtr;": "⪋",
            "&lessgtr;": "≶",
            "&lesssim;": "≲",
            "&lfisht;": "⥼",
            "&lfloor;": "⌊",
            "&lfr;": "𝔩",
            "&lg;": "≶",
            "&lgE;": "⪑",
            "&lhard;": "↽",
            "&lharu;": "↼",
            "&lharul;": "⥪",
            "&lhblk;": "▄",
            "&ljcy;": "љ",
            "&ll;": "≪",
            "&llarr;": "⇇",
            "&llcorner;": "⌞",
            "&llhard;": "⥫",
            "&lltri;": "◺",
            "&lmidot;": "ŀ",
            "&lmoust;": "⎰",
            "&lmoustache;": "⎰",
            "&lnE;": "≨",
            "&lnap;": "⪉",
            "&lnapprox;": "⪉",
            "&lne;": "⪇",
            "&lneq;": "⪇",
            "&lneqq;": "≨",
            "&lnsim;": "⋦",
            "&loang;": "⟬",
            "&loarr;": "⇽",
            "&lobrk;": "⟦",
            "&longleftarrow;": "⟵",
            "&longleftrightarrow;": "⟷",
            "&longmapsto;": "⟼",
            "&longrightarrow;": "⟶",
            "&looparrowleft;": "↫",
            "&looparrowright;": "↬",
            "&lopar;": "⦅",
            "&lopf;": "𝕝",
            "&loplus;": "⨭",
            "&lotimes;": "⨴",
            "&lowast;": "∗",
            "&lowbar;": "_",
            "&loz;": "◊",
            "&lozenge;": "◊",
            "&lozf;": "⧫",
            "&lpar;": "(",
            "&lparlt;": "⦓",
            "&lrarr;": "⇆",
            "&lrcorner;": "⌟",
            "&lrhar;": "⇋",
            "&lrhard;": "⥭",
            "&lrm;": "‎",
            "&lrtri;": "⊿",
            "&lsaquo;": "‹",
            "&lscr;": "𝓁",
            "&lsh;": "↰",
            "&lsim;": "≲",
            "&lsime;": "⪍",
            "&lsimg;": "⪏",
            "&lsqb;": "[",
            "&lsquo;": "‘",
            "&lsquor;": "‚",
            "&lstrok;": "ł",
            "&lt": "<",
            "&lt;": "<",
            "&ltcc;": "⪦",
            "&ltcir;": "⩹",
            "&ltdot;": "⋖",
            "&lthree;": "⋋",
            "&ltimes;": "⋉",
            "&ltlarr;": "⥶",
            "&ltquest;": "⩻",
            "&ltrPar;": "⦖",
            "&ltri;": "◃",
            "&ltrie;": "⊴",
            "&ltrif;": "◂",
            "&lurdshar;": "⥊",
            "&luruhar;": "⥦",
            "&lvertneqq;": "≨︀",
            "&lvnE;": "≨︀",
            "&mDDot;": "∺",
            "&macr": "¯",
            "&macr;": "¯",
            "&male;": "♂",
            "&malt;": "✠",
            "&maltese;": "✠",
            "&map;": "↦",
            "&mapsto;": "↦",
            "&mapstodown;": "↧",
            "&mapstoleft;": "↤",
            "&mapstoup;": "↥",
            "&marker;": "▮",
            "&mcomma;": "⨩",
            "&mcy;": "м",
            "&mdash;": "—",
            "&measuredangle;": "∡",
            "&mfr;": "𝔪",
            "&mho;": "℧",
            "&micro": "µ",
            "&micro;": "µ",
            "&mid;": "∣",
            "&midast;": "*",
            "&midcir;": "⫰",
            "&middot": "·",
            "&middot;": "·",
            "&minus;": "−",
            "&minusb;": "⊟",
            "&minusd;": "∸",
            "&minusdu;": "⨪",
            "&mlcp;": "⫛",
            "&mldr;": "…",
            "&mnplus;": "∓",
            "&models;": "⊧",
            "&mopf;": "𝕞",
            "&mp;": "∓",
            "&mscr;": "𝓂",
            "&mstpos;": "∾",
            "&mu;": "μ",
            "&multimap;": "⊸",
            "&mumap;": "⊸",
            "&nGg;": "⋙̸",
            "&nGt;": "≫⃒",
            "&nGtv;": "≫̸",
            "&nLeftarrow;": "⇍",
            "&nLeftrightarrow;": "⇎",
            "&nLl;": "⋘̸",
            "&nLt;": "≪⃒",
            "&nLtv;": "≪̸",
            "&nRightarrow;": "⇏",
            "&nVDash;": "⊯",
            "&nVdash;": "⊮",
            "&nabla;": "∇",
            "&nacute;": "ń",
            "&nang;": "∠⃒",
            "&nap;": "≉",
            "&napE;": "⩰̸",
            "&napid;": "≋̸",
            "&napos;": "ŉ",
            "&napprox;": "≉",
            "&natur;": "♮",
            "&natural;": "♮",
            "&naturals;": "ℕ",
            "&nbsp": " ",
            "&nbsp;": " ",
            "&nbump;": "≎̸",
            "&nbumpe;": "≏̸",
            "&ncap;": "⩃",
            "&ncaron;": "ň",
            "&ncedil;": "ņ",
            "&ncong;": "≇",
            "&ncongdot;": "⩭̸",
            "&ncup;": "⩂",
            "&ncy;": "н",
            "&ndash;": "–",
            "&ne;": "≠",
            "&neArr;": "⇗",
            "&nearhk;": "⤤",
            "&nearr;": "↗",
            "&nearrow;": "↗",
            "&nedot;": "≐̸",
            "&nequiv;": "≢",
            "&nesear;": "⤨",
            "&nesim;": "≂̸",
            "&nexist;": "∄",
            "&nexists;": "∄",
            "&nfr;": "𝔫",
            "&ngE;": "≧̸",
            "&nge;": "≱",
            "&ngeq;": "≱",
            "&ngeqq;": "≧̸",
            "&ngeqslant;": "⩾̸",
            "&nges;": "⩾̸",
            "&ngsim;": "≵",
            "&ngt;": "≯",
            "&ngtr;": "≯",
            "&nhArr;": "⇎",
            "&nharr;": "↮",
            "&nhpar;": "⫲",
            "&ni;": "∋",
            "&nis;": "⋼",
            "&nisd;": "⋺",
            "&niv;": "∋",
            "&njcy;": "њ",
            "&nlArr;": "⇍",
            "&nlE;": "≦̸",
            "&nlarr;": "↚",
            "&nldr;": "‥",
            "&nle;": "≰",
            "&nleftarrow;": "↚",
            "&nleftrightarrow;": "↮",
            "&nleq;": "≰",
            "&nleqq;": "≦̸",
            "&nleqslant;": "⩽̸",
            "&nles;": "⩽̸",
            "&nless;": "≮",
            "&nlsim;": "≴",
            "&nlt;": "≮",
            "&nltri;": "⋪",
            "&nltrie;": "⋬",
            "&nmid;": "∤",
            "&nopf;": "𝕟",
            "&not": "¬",
            "&not;": "¬",
            "&notin;": "∉",
            "&notinE;": "⋹̸",
            "&notindot;": "⋵̸",
            "&notinva;": "∉",
            "&notinvb;": "⋷",
            "&notinvc;": "⋶",
            "&notni;": "∌",
            "&notniva;": "∌",
            "&notnivb;": "⋾",
            "&notnivc;": "⋽",
            "&npar;": "∦",
            "&nparallel;": "∦",
            "&nparsl;": "⫽⃥",
            "&npart;": "∂̸",
            "&npolint;": "⨔",
            "&npr;": "⊀",
            "&nprcue;": "⋠",
            "&npre;": "⪯̸",
            "&nprec;": "⊀",
            "&npreceq;": "⪯̸",
            "&nrArr;": "⇏",
            "&nrarr;": "↛",
            "&nrarrc;": "⤳̸",
            "&nrarrw;": "↝̸",
            "&nrightarrow;": "↛",
            "&nrtri;": "⋫",
            "&nrtrie;": "⋭",
            "&nsc;": "⊁",
            "&nsccue;": "⋡",
            "&nsce;": "⪰̸",
            "&nscr;": "𝓃",
            "&nshortmid;": "∤",
            "&nshortparallel;": "∦",
            "&nsim;": "≁",
            "&nsime;": "≄",
            "&nsimeq;": "≄",
            "&nsmid;": "∤",
            "&nspar;": "∦",
            "&nsqsube;": "⋢",
            "&nsqsupe;": "⋣",
            "&nsub;": "⊄",
            "&nsubE;": "⫅̸",
            "&nsube;": "⊈",
            "&nsubset;": "⊂⃒",
            "&nsubseteq;": "⊈",
            "&nsubseteqq;": "⫅̸",
            "&nsucc;": "⊁",
            "&nsucceq;": "⪰̸",
            "&nsup;": "⊅",
            "&nsupE;": "⫆̸",
            "&nsupe;": "⊉",
            "&nsupset;": "⊃⃒",
            "&nsupseteq;": "⊉",
            "&nsupseteqq;": "⫆̸",
            "&ntgl;": "≹",
            "&ntilde": "ñ",
            "&ntilde;": "ñ",
            "&ntlg;": "≸",
            "&ntriangleleft;": "⋪",
            "&ntrianglelefteq;": "⋬",
            "&ntriangleright;": "⋫",
            "&ntrianglerighteq;": "⋭",
            "&nu;": "ν",
            "&num;": "#",
            "&numero;": "№",
            "&numsp;": " ",
            "&nvDash;": "⊭",
            "&nvHarr;": "⤄",
            "&nvap;": "≍⃒",
            "&nvdash;": "⊬",
            "&nvge;": "≥⃒",
            "&nvgt;": ">⃒",
            "&nvinfin;": "⧞",
            "&nvlArr;": "⤂",
            "&nvle;": "≤⃒",
            "&nvlt;": "<⃒",
            "&nvltrie;": "⊴⃒",
            "&nvrArr;": "⤃",
            "&nvrtrie;": "⊵⃒",
            "&nvsim;": "∼⃒",
            "&nwArr;": "⇖",
            "&nwarhk;": "⤣",
            "&nwarr;": "↖",
            "&nwarrow;": "↖",
            "&nwnear;": "⤧",
            "&oS;": "Ⓢ",
            "&oacute": "ó",
            "&oacute;": "ó",
            "&oast;": "⊛",
            "&ocir;": "⊚",
            "&ocirc": "ô",
            "&ocirc;": "ô",
            "&ocy;": "о",
            "&odash;": "⊝",
            "&odblac;": "ő",
            "&odiv;": "⨸",
            "&odot;": "⊙",
            "&odsold;": "⦼",
            "&oelig;": "œ",
            "&ofcir;": "⦿",
            "&ofr;": "𝔬",
            "&ogon;": "˛",
            "&ograve": "ò",
            "&ograve;": "ò",
            "&ogt;": "⧁",
            "&ohbar;": "⦵",
            "&ohm;": "Ω",
            "&oint;": "∮",
            "&olarr;": "↺",
            "&olcir;": "⦾",
            "&olcross;": "⦻",
            "&oline;": "‾",
            "&olt;": "⧀",
            "&omacr;": "ō",
            "&omega;": "ω",
            "&omicron;": "ο",
            "&omid;": "⦶",
            "&ominus;": "⊖",
            "&oopf;": "𝕠",
            "&opar;": "⦷",
            "&operp;": "⦹",
            "&oplus;": "⊕",
            "&or;": "∨",
            "&orarr;": "↻",
            "&ord;": "⩝",
            "&order;": "ℴ",
            "&orderof;": "ℴ",
            "&ordf": "ª",
            "&ordf;": "ª",
            "&ordm": "º",
            "&ordm;": "º",
            "&origof;": "⊶",
            "&oror;": "⩖",
            "&orslope;": "⩗",
            "&orv;": "⩛",
            "&oscr;": "ℴ",
            "&oslash": "ø",
            "&oslash;": "ø",
            "&osol;": "⊘",
            "&otilde": "õ",
            "&otilde;": "õ",
            "&otimes;": "⊗",
            "&otimesas;": "⨶",
            "&ouml": "ö",
            "&ouml;": "ö",
            "&ovbar;": "⌽",
            "&par;": "∥",
            "&para": "¶",
            "&para;": "¶",
            "&parallel;": "∥",
            "&parsim;": "⫳",
            "&parsl;": "⫽",
            "&part;": "∂",
            "&pcy;": "п",
            "&percnt;": "%",
            "&period;": ".",
            "&permil;": "‰",
            "&perp;": "⊥",
            "&pertenk;": "‱",
            "&pfr;": "𝔭",
            "&phi;": "φ",
            "&phiv;": "ϕ",
            "&phmmat;": "ℳ",
            "&phone;": "☎",
            "&pi;": "π",
            "&pitchfork;": "⋔",
            "&piv;": "ϖ",
            "&planck;": "ℏ",
            "&planckh;": "ℎ",
            "&plankv;": "ℏ",
            "&plus;": "+",
            "&plusacir;": "⨣",
            "&plusb;": "⊞",
            "&pluscir;": "⨢",
            "&plusdo;": "∔",
            "&plusdu;": "⨥",
            "&pluse;": "⩲",
            "&plusmn": "±",
            "&plusmn;": "±",
            "&plussim;": "⨦",
            "&plustwo;": "⨧",
            "&pm;": "±",
            "&pointint;": "⨕",
            "&popf;": "𝕡",
            "&pound": "£",
            "&pound;": "£",
            "&pr;": "≺",
            "&prE;": "⪳",
            "&prap;": "⪷",
            "&prcue;": "≼",
            "&pre;": "⪯",
            "&prec;": "≺",
            "&precapprox;": "⪷",
            "&preccurlyeq;": "≼",
            "&preceq;": "⪯",
            "&precnapprox;": "⪹",
            "&precneqq;": "⪵",
            "&precnsim;": "⋨",
            "&precsim;": "≾",
            "&prime;": "′",
            "&primes;": "ℙ",
            "&prnE;": "⪵",
            "&prnap;": "⪹",
            "&prnsim;": "⋨",
            "&prod;": "∏",
            "&profalar;": "⌮",
            "&profline;": "⌒",
            "&profsurf;": "⌓",
            "&prop;": "∝",
            "&propto;": "∝",
            "&prsim;": "≾",
            "&prurel;": "⊰",
            "&pscr;": "𝓅",
            "&psi;": "ψ",
            "&puncsp;": " ",
            "&qfr;": "𝔮",
            "&qint;": "⨌",
            "&qopf;": "𝕢",
            "&qprime;": "⁗",
            "&qscr;": "𝓆",
            "&quaternions;": "ℍ",
            "&quatint;": "⨖",
            "&quest;": "?",
            "&questeq;": "≟",
            "&quot": '"',
            "&quot;": '"',
            "&rAarr;": "⇛",
            "&rArr;": "⇒",
            "&rAtail;": "⤜",
            "&rBarr;": "⤏",
            "&rHar;": "⥤",
            "&race;": "∽̱",
            "&racute;": "ŕ",
            "&radic;": "√",
            "&raemptyv;": "⦳",
            "&rang;": "⟩",
            "&rangd;": "⦒",
            "&range;": "⦥",
            "&rangle;": "⟩",
            "&raquo": "»",
            "&raquo;": "»",
            "&rarr;": "→",
            "&rarrap;": "⥵",
            "&rarrb;": "⇥",
            "&rarrbfs;": "⤠",
            "&rarrc;": "⤳",
            "&rarrfs;": "⤞",
            "&rarrhk;": "↪",
            "&rarrlp;": "↬",
            "&rarrpl;": "⥅",
            "&rarrsim;": "⥴",
            "&rarrtl;": "↣",
            "&rarrw;": "↝",
            "&ratail;": "⤚",
            "&ratio;": "∶",
            "&rationals;": "ℚ",
            "&rbarr;": "⤍",
            "&rbbrk;": "❳",
            "&rbrace;": "}",
            "&rbrack;": "]",
            "&rbrke;": "⦌",
            "&rbrksld;": "⦎",
            "&rbrkslu;": "⦐",
            "&rcaron;": "ř",
            "&rcedil;": "ŗ",
            "&rceil;": "⌉",
            "&rcub;": "}",
            "&rcy;": "р",
            "&rdca;": "⤷",
            "&rdldhar;": "⥩",
            "&rdquo;": "”",
            "&rdquor;": "”",
            "&rdsh;": "↳",
            "&real;": "ℜ",
            "&realine;": "ℛ",
            "&realpart;": "ℜ",
            "&reals;": "ℝ",
            "&rect;": "▭",
            "&reg": "®",
            "&reg;": "®",
            "&rfisht;": "⥽",
            "&rfloor;": "⌋",
            "&rfr;": "𝔯",
            "&rhard;": "⇁",
            "&rharu;": "⇀",
            "&rharul;": "⥬",
            "&rho;": "ρ",
            "&rhov;": "ϱ",
            "&rightarrow;": "→",
            "&rightarrowtail;": "↣",
            "&rightharpoondown;": "⇁",
            "&rightharpoonup;": "⇀",
            "&rightleftarrows;": "⇄",
            "&rightleftharpoons;": "⇌",
            "&rightrightarrows;": "⇉",
            "&rightsquigarrow;": "↝",
            "&rightthreetimes;": "⋌",
            "&ring;": "˚",
            "&risingdotseq;": "≓",
            "&rlarr;": "⇄",
            "&rlhar;": "⇌",
            "&rlm;": "‏",
            "&rmoust;": "⎱",
            "&rmoustache;": "⎱",
            "&rnmid;": "⫮",
            "&roang;": "⟭",
            "&roarr;": "⇾",
            "&robrk;": "⟧",
            "&ropar;": "⦆",
            "&ropf;": "𝕣",
            "&roplus;": "⨮",
            "&rotimes;": "⨵",
            "&rpar;": ")",
            "&rpargt;": "⦔",
            "&rppolint;": "⨒",
            "&rrarr;": "⇉",
            "&rsaquo;": "›",
            "&rscr;": "𝓇",
            "&rsh;": "↱",
            "&rsqb;": "]",
            "&rsquo;": "’",
            "&rsquor;": "’",
            "&rthree;": "⋌",
            "&rtimes;": "⋊",
            "&rtri;": "▹",
            "&rtrie;": "⊵",
            "&rtrif;": "▸",
            "&rtriltri;": "⧎",
            "&ruluhar;": "⥨",
            "&rx;": "℞",
            "&sacute;": "ś",
            "&sbquo;": "‚",
            "&sc;": "≻",
            "&scE;": "⪴",
            "&scap;": "⪸",
            "&scaron;": "š",
            "&sccue;": "≽",
            "&sce;": "⪰",
            "&scedil;": "ş",
            "&scirc;": "ŝ",
            "&scnE;": "⪶",
            "&scnap;": "⪺",
            "&scnsim;": "⋩",
            "&scpolint;": "⨓",
            "&scsim;": "≿",
            "&scy;": "с",
            "&sdot;": "⋅",
            "&sdotb;": "⊡",
            "&sdote;": "⩦",
            "&seArr;": "⇘",
            "&searhk;": "⤥",
            "&searr;": "↘",
            "&searrow;": "↘",
            "&sect": "§",
            "&sect;": "§",
            "&semi;": ";",
            "&seswar;": "⤩",
            "&setminus;": "∖",
            "&setmn;": "∖",
            "&sext;": "✶",
            "&sfr;": "𝔰",
            "&sfrown;": "⌢",
            "&sharp;": "♯",
            "&shchcy;": "щ",
            "&shcy;": "ш",
            "&shortmid;": "∣",
            "&shortparallel;": "∥",
            "&shy": "­",
            "&shy;": "­",
            "&sigma;": "σ",
            "&sigmaf;": "ς",
            "&sigmav;": "ς",
            "&sim;": "∼",
            "&simdot;": "⩪",
            "&sime;": "≃",
            "&simeq;": "≃",
            "&simg;": "⪞",
            "&simgE;": "⪠",
            "&siml;": "⪝",
            "&simlE;": "⪟",
            "&simne;": "≆",
            "&simplus;": "⨤",
            "&simrarr;": "⥲",
            "&slarr;": "←",
            "&smallsetminus;": "∖",
            "&smashp;": "⨳",
            "&smeparsl;": "⧤",
            "&smid;": "∣",
            "&smile;": "⌣",
            "&smt;": "⪪",
            "&smte;": "⪬",
            "&smtes;": "⪬︀",
            "&softcy;": "ь",
            "&sol;": "/",
            "&solb;": "⧄",
            "&solbar;": "⌿",
            "&sopf;": "𝕤",
            "&spades;": "♠",
            "&spadesuit;": "♠",
            "&spar;": "∥",
            "&sqcap;": "⊓",
            "&sqcaps;": "⊓︀",
            "&sqcup;": "⊔",
            "&sqcups;": "⊔︀",
            "&sqsub;": "⊏",
            "&sqsube;": "⊑",
            "&sqsubset;": "⊏",
            "&sqsubseteq;": "⊑",
            "&sqsup;": "⊐",
            "&sqsupe;": "⊒",
            "&sqsupset;": "⊐",
            "&sqsupseteq;": "⊒",
            "&squ;": "□",
            "&square;": "□",
            "&squarf;": "▪",
            "&squf;": "▪",
            "&srarr;": "→",
            "&sscr;": "𝓈",
            "&ssetmn;": "∖",
            "&ssmile;": "⌣",
            "&sstarf;": "⋆",
            "&star;": "☆",
            "&starf;": "★",
            "&straightepsilon;": "ϵ",
            "&straightphi;": "ϕ",
            "&strns;": "¯",
            "&sub;": "⊂",
            "&subE;": "⫅",
            "&subdot;": "⪽",
            "&sube;": "⊆",
            "&subedot;": "⫃",
            "&submult;": "⫁",
            "&subnE;": "⫋",
            "&subne;": "⊊",
            "&subplus;": "⪿",
            "&subrarr;": "⥹",
            "&subset;": "⊂",
            "&subseteq;": "⊆",
            "&subseteqq;": "⫅",
            "&subsetneq;": "⊊",
            "&subsetneqq;": "⫋",
            "&subsim;": "⫇",
            "&subsub;": "⫕",
            "&subsup;": "⫓",
            "&succ;": "≻",
            "&succapprox;": "⪸",
            "&succcurlyeq;": "≽",
            "&succeq;": "⪰",
            "&succnapprox;": "⪺",
            "&succneqq;": "⪶",
            "&succnsim;": "⋩",
            "&succsim;": "≿",
            "&sum;": "∑",
            "&sung;": "♪",
            "&sup1": "¹",
            "&sup1;": "¹",
            "&sup2": "²",
            "&sup2;": "²",
            "&sup3": "³",
            "&sup3;": "³",
            "&sup;": "⊃",
            "&supE;": "⫆",
            "&supdot;": "⪾",
            "&supdsub;": "⫘",
            "&supe;": "⊇",
            "&supedot;": "⫄",
            "&suphsol;": "⟉",
            "&suphsub;": "⫗",
            "&suplarr;": "⥻",
            "&supmult;": "⫂",
            "&supnE;": "⫌",
            "&supne;": "⊋",
            "&supplus;": "⫀",
            "&supset;": "⊃",
            "&supseteq;": "⊇",
            "&supseteqq;": "⫆",
            "&supsetneq;": "⊋",
            "&supsetneqq;": "⫌",
            "&supsim;": "⫈",
            "&supsub;": "⫔",
            "&supsup;": "⫖",
            "&swArr;": "⇙",
            "&swarhk;": "⤦",
            "&swarr;": "↙",
            "&swarrow;": "↙",
            "&swnwar;": "⤪",
            "&szlig": "ß",
            "&szlig;": "ß",
            "&target;": "⌖",
            "&tau;": "τ",
            "&tbrk;": "⎴",
            "&tcaron;": "ť",
            "&tcedil;": "ţ",
            "&tcy;": "т",
            "&tdot;": "⃛",
            "&telrec;": "⌕",
            "&tfr;": "𝔱",
            "&there4;": "∴",
            "&therefore;": "∴",
            "&theta;": "θ",
            "&thetasym;": "ϑ",
            "&thetav;": "ϑ",
            "&thickapprox;": "≈",
            "&thicksim;": "∼",
            "&thinsp;": " ",
            "&thkap;": "≈",
            "&thksim;": "∼",
            "&thorn": "þ",
            "&thorn;": "þ",
            "&tilde;": "˜",
            "&times": "×",
            "&times;": "×",
            "&timesb;": "⊠",
            "&timesbar;": "⨱",
            "&timesd;": "⨰",
            "&tint;": "∭",
            "&toea;": "⤨",
            "&top;": "⊤",
            "&topbot;": "⌶",
            "&topcir;": "⫱",
            "&topf;": "𝕥",
            "&topfork;": "⫚",
            "&tosa;": "⤩",
            "&tprime;": "‴",
            "&trade;": "™",
            "&triangle;": "▵",
            "&triangledown;": "▿",
            "&triangleleft;": "◃",
            "&trianglelefteq;": "⊴",
            "&triangleq;": "≜",
            "&triangleright;": "▹",
            "&trianglerighteq;": "⊵",
            "&tridot;": "◬",
            "&trie;": "≜",
            "&triminus;": "⨺",
            "&triplus;": "⨹",
            "&trisb;": "⧍",
            "&tritime;": "⨻",
            "&trpezium;": "⏢",
            "&tscr;": "𝓉",
            "&tscy;": "ц",
            "&tshcy;": "ћ",
            "&tstrok;": "ŧ",
            "&twixt;": "≬",
            "&twoheadleftarrow;": "↞",
            "&twoheadrightarrow;": "↠",
            "&uArr;": "⇑",
            "&uHar;": "⥣",
            "&uacute": "ú",
            "&uacute;": "ú",
            "&uarr;": "↑",
            "&ubrcy;": "ў",
            "&ubreve;": "ŭ",
            "&ucirc": "û",
            "&ucirc;": "û",
            "&ucy;": "у",
            "&udarr;": "⇅",
            "&udblac;": "ű",
            "&udhar;": "⥮",
            "&ufisht;": "⥾",
            "&ufr;": "𝔲",
            "&ugrave": "ù",
            "&ugrave;": "ù",
            "&uharl;": "↿",
            "&uharr;": "↾",
            "&uhblk;": "▀",
            "&ulcorn;": "⌜",
            "&ulcorner;": "⌜",
            "&ulcrop;": "⌏",
            "&ultri;": "◸",
            "&umacr;": "ū",
            "&uml": "¨",
            "&uml;": "¨",
            "&uogon;": "ų",
            "&uopf;": "𝕦",
            "&uparrow;": "↑",
            "&updownarrow;": "↕",
            "&upharpoonleft;": "↿",
            "&upharpoonright;": "↾",
            "&uplus;": "⊎",
            "&upsi;": "υ",
            "&upsih;": "ϒ",
            "&upsilon;": "υ",
            "&upuparrows;": "⇈",
            "&urcorn;": "⌝",
            "&urcorner;": "⌝",
            "&urcrop;": "⌎",
            "&uring;": "ů",
            "&urtri;": "◹",
            "&uscr;": "𝓊",
            "&utdot;": "⋰",
            "&utilde;": "ũ",
            "&utri;": "▵",
            "&utrif;": "▴",
            "&uuarr;": "⇈",
            "&uuml": "ü",
            "&uuml;": "ü",
            "&uwangle;": "⦧",
            "&vArr;": "⇕",
            "&vBar;": "⫨",
            "&vBarv;": "⫩",
            "&vDash;": "⊨",
            "&vangrt;": "⦜",
            "&varepsilon;": "ϵ",
            "&varkappa;": "ϰ",
            "&varnothing;": "∅",
            "&varphi;": "ϕ",
            "&varpi;": "ϖ",
            "&varpropto;": "∝",
            "&varr;": "↕",
            "&varrho;": "ϱ",
            "&varsigma;": "ς",
            "&varsubsetneq;": "⊊︀",
            "&varsubsetneqq;": "⫋︀",
            "&varsupsetneq;": "⊋︀",
            "&varsupsetneqq;": "⫌︀",
            "&vartheta;": "ϑ",
            "&vartriangleleft;": "⊲",
            "&vartriangleright;": "⊳",
            "&vcy;": "в",
            "&vdash;": "⊢",
            "&vee;": "∨",
            "&veebar;": "⊻",
            "&veeeq;": "≚",
            "&vellip;": "⋮",
            "&verbar;": "|",
            "&vert;": "|",
            "&vfr;": "𝔳",
            "&vltri;": "⊲",
            "&vnsub;": "⊂⃒",
            "&vnsup;": "⊃⃒",
            "&vopf;": "𝕧",
            "&vprop;": "∝",
            "&vrtri;": "⊳",
            "&vscr;": "𝓋",
            "&vsubnE;": "⫋︀",
            "&vsubne;": "⊊︀",
            "&vsupnE;": "⫌︀",
            "&vsupne;": "⊋︀",
            "&vzigzag;": "⦚",
            "&wcirc;": "ŵ",
            "&wedbar;": "⩟",
            "&wedge;": "∧",
            "&wedgeq;": "≙",
            "&weierp;": "℘",
            "&wfr;": "𝔴",
            "&wopf;": "𝕨",
            "&wp;": "℘",
            "&wr;": "≀",
            "&wreath;": "≀",
            "&wscr;": "𝓌",
            "&xcap;": "⋂",
            "&xcirc;": "◯",
            "&xcup;": "⋃",
            "&xdtri;": "▽",
            "&xfr;": "𝔵",
            "&xhArr;": "⟺",
            "&xharr;": "⟷",
            "&xi;": "ξ",
            "&xlArr;": "⟸",
            "&xlarr;": "⟵",
            "&xmap;": "⟼",
            "&xnis;": "⋻",
            "&xodot;": "⨀",
            "&xopf;": "𝕩",
            "&xoplus;": "⨁",
            "&xotime;": "⨂",
            "&xrArr;": "⟹",
            "&xrarr;": "⟶",
            "&xscr;": "𝓍",
            "&xsqcup;": "⨆",
            "&xuplus;": "⨄",
            "&xutri;": "△",
            "&xvee;": "⋁",
            "&xwedge;": "⋀",
            "&yacute": "ý",
            "&yacute;": "ý",
            "&yacy;": "я",
            "&ycirc;": "ŷ",
            "&ycy;": "ы",
            "&yen": "¥",
            "&yen;": "¥",
            "&yfr;": "𝔶",
            "&yicy;": "ї",
            "&yopf;": "𝕪",
            "&yscr;": "𝓎",
            "&yucy;": "ю",
            "&yuml": "ÿ",
            "&yuml;": "ÿ",
            "&zacute;": "ź",
            "&zcaron;": "ž",
            "&zcy;": "з",
            "&zdot;": "ż",
            "&zeetrf;": "ℨ",
            "&zeta;": "ζ",
            "&zfr;": "𝔷",
            "&zhcy;": "ж",
            "&zigrarr;": "⇝",
            "&zopf;": "𝕫",
            "&zscr;": "𝓏",
            "&zwj;": "‍",
            "&zwnj;": "‌"
        },
        characters: {
            "Æ": "&AElig;",
            "&": "&amp;",
            "Á": "&Aacute;",
            "Ă": "&Abreve;",
            "Â": "&Acirc;",
            "А": "&Acy;",
            "𝔄": "&Afr;",
            "À": "&Agrave;",
            "Α": "&Alpha;",
            "Ā": "&Amacr;",
            "⩓": "&And;",
            "Ą": "&Aogon;",
            "𝔸": "&Aopf;",
            "⁡": "&af;",
            "Å": "&angst;",
            "𝒜": "&Ascr;",
            "≔": "&coloneq;",
            "Ã": "&Atilde;",
            "Ä": "&Auml;",
            "∖": "&ssetmn;",
            "⫧": "&Barv;",
            "⌆": "&doublebarwedge;",
            "Б": "&Bcy;",
            "∵": "&because;",
            "ℬ": "&bernou;",
            "Β": "&Beta;",
            "𝔅": "&Bfr;",
            "𝔹": "&Bopf;",
            "˘": "&breve;",
            "≎": "&bump;",
            "Ч": "&CHcy;",
            "©": "&copy;",
            "Ć": "&Cacute;",
            "⋒": "&Cap;",
            "ⅅ": "&DD;",
            "ℭ": "&Cfr;",
            "Č": "&Ccaron;",
            "Ç": "&Ccedil;",
            "Ĉ": "&Ccirc;",
            "∰": "&Cconint;",
            "Ċ": "&Cdot;",
            "¸": "&cedil;",
            "·": "&middot;",
            "Χ": "&Chi;",
            "⊙": "&odot;",
            "⊖": "&ominus;",
            "⊕": "&oplus;",
            "⊗": "&otimes;",
            "∲": "&cwconint;",
            "”": "&rdquor;",
            "’": "&rsquor;",
            "∷": "&Proportion;",
            "⩴": "&Colone;",
            "≡": "&equiv;",
            "∯": "&DoubleContourIntegral;",
            "∮": "&oint;",
            "ℂ": "&complexes;",
            "∐": "&coprod;",
            "∳": "&awconint;",
            "⨯": "&Cross;",
            "𝒞": "&Cscr;",
            "⋓": "&Cup;",
            "≍": "&asympeq;",
            "⤑": "&DDotrahd;",
            "Ђ": "&DJcy;",
            "Ѕ": "&DScy;",
            "Џ": "&DZcy;",
            "‡": "&ddagger;",
            "↡": "&Darr;",
            "⫤": "&DoubleLeftTee;",
            "Ď": "&Dcaron;",
            "Д": "&Dcy;",
            "∇": "&nabla;",
            "Δ": "&Delta;",
            "𝔇": "&Dfr;",
            "´": "&acute;",
            "˙": "&dot;",
            "˝": "&dblac;",
            "`": "&grave;",
            "˜": "&tilde;",
            "⋄": "&diamond;",
            "ⅆ": "&dd;",
            "𝔻": "&Dopf;",
            "¨": "&uml;",
            "⃜": "&DotDot;",
            "≐": "&esdot;",
            "⇓": "&dArr;",
            "⇐": "&lArr;",
            "⇔": "&iff;",
            "⟸": "&xlArr;",
            "⟺": "&xhArr;",
            "⟹": "&xrArr;",
            "⇒": "&rArr;",
            "⊨": "&vDash;",
            "⇑": "&uArr;",
            "⇕": "&vArr;",
            "∥": "&spar;",
            "↓": "&downarrow;",
            "⤓": "&DownArrowBar;",
            "⇵": "&duarr;",
            "̑": "&DownBreve;",
            "⥐": "&DownLeftRightVector;",
            "⥞": "&DownLeftTeeVector;",
            "↽": "&lhard;",
            "⥖": "&DownLeftVectorBar;",
            "⥟": "&DownRightTeeVector;",
            "⇁": "&rightharpoondown;",
            "⥗": "&DownRightVectorBar;",
            "⊤": "&top;",
            "↧": "&mapstodown;",
            "𝒟": "&Dscr;",
            "Đ": "&Dstrok;",
            "Ŋ": "&ENG;",
            "Ð": "&ETH;",
            "É": "&Eacute;",
            "Ě": "&Ecaron;",
            "Ê": "&Ecirc;",
            "Э": "&Ecy;",
            "Ė": "&Edot;",
            "𝔈": "&Efr;",
            "È": "&Egrave;",
            "∈": "&isinv;",
            "Ē": "&Emacr;",
            "◻": "&EmptySmallSquare;",
            "▫": "&EmptyVerySmallSquare;",
            "Ę": "&Eogon;",
            "𝔼": "&Eopf;",
            "Ε": "&Epsilon;",
            "⩵": "&Equal;",
            "≂": "&esim;",
            "⇌": "&rlhar;",
            "ℰ": "&expectation;",
            "⩳": "&Esim;",
            "Η": "&Eta;",
            "Ë": "&Euml;",
            "∃": "&exist;",
            "ⅇ": "&exponentiale;",
            "Ф": "&Fcy;",
            "𝔉": "&Ffr;",
            "◼": "&FilledSmallSquare;",
            "▪": "&squf;",
            "𝔽": "&Fopf;",
            "∀": "&forall;",
            "ℱ": "&Fscr;",
            "Ѓ": "&GJcy;",
            ">": "&gt;",
            "Γ": "&Gamma;",
            "Ϝ": "&Gammad;",
            "Ğ": "&Gbreve;",
            "Ģ": "&Gcedil;",
            "Ĝ": "&Gcirc;",
            "Г": "&Gcy;",
            "Ġ": "&Gdot;",
            "𝔊": "&Gfr;",
            "⋙": "&ggg;",
            "𝔾": "&Gopf;",
            "≥": "&geq;",
            "⋛": "&gtreqless;",
            "≧": "&geqq;",
            "⪢": "&GreaterGreater;",
            "≷": "&gtrless;",
            "⩾": "&ges;",
            "≳": "&gtrsim;",
            "𝒢": "&Gscr;",
            "≫": "&gg;",
            "Ъ": "&HARDcy;",
            "ˇ": "&caron;",
            "^": "&Hat;",
            "Ĥ": "&Hcirc;",
            "ℌ": "&Poincareplane;",
            "ℋ": "&hamilt;",
            "ℍ": "&quaternions;",
            "─": "&boxh;",
            "Ħ": "&Hstrok;",
            "≏": "&bumpeq;",
            "Е": "&IEcy;",
            "Ĳ": "&IJlig;",
            "Ё": "&IOcy;",
            "Í": "&Iacute;",
            "Î": "&Icirc;",
            "И": "&Icy;",
            "İ": "&Idot;",
            "ℑ": "&imagpart;",
            "Ì": "&Igrave;",
            "Ī": "&Imacr;",
            "ⅈ": "&ii;",
            "∬": "&Int;",
            "∫": "&int;",
            "⋂": "&xcap;",
            "⁣": "&ic;",
            "⁢": "&it;",
            "Į": "&Iogon;",
            "𝕀": "&Iopf;",
            "Ι": "&Iota;",
            "ℐ": "&imagline;",
            "Ĩ": "&Itilde;",
            "І": "&Iukcy;",
            "Ï": "&Iuml;",
            "Ĵ": "&Jcirc;",
            "Й": "&Jcy;",
            "𝔍": "&Jfr;",
            "𝕁": "&Jopf;",
            "𝒥": "&Jscr;",
            "Ј": "&Jsercy;",
            "Є": "&Jukcy;",
            "Х": "&KHcy;",
            "Ќ": "&KJcy;",
            "Κ": "&Kappa;",
            "Ķ": "&Kcedil;",
            "К": "&Kcy;",
            "𝔎": "&Kfr;",
            "𝕂": "&Kopf;",
            "𝒦": "&Kscr;",
            "Љ": "&LJcy;",
            "<": "&lt;",
            "Ĺ": "&Lacute;",
            "Λ": "&Lambda;",
            "⟪": "&Lang;",
            "ℒ": "&lagran;",
            "↞": "&twoheadleftarrow;",
            "Ľ": "&Lcaron;",
            "Ļ": "&Lcedil;",
            "Л": "&Lcy;",
            "⟨": "&langle;",
            "←": "&slarr;",
            "⇤": "&larrb;",
            "⇆": "&lrarr;",
            "⌈": "&lceil;",
            "⟦": "&lobrk;",
            "⥡": "&LeftDownTeeVector;",
            "⇃": "&downharpoonleft;",
            "⥙": "&LeftDownVectorBar;",
            "⌊": "&lfloor;",
            "↔": "&leftrightarrow;",
            "⥎": "&LeftRightVector;",
            "⊣": "&dashv;",
            "↤": "&mapstoleft;",
            "⥚": "&LeftTeeVector;",
            "⊲": "&vltri;",
            "⧏": "&LeftTriangleBar;",
            "⊴": "&trianglelefteq;",
            "⥑": "&LeftUpDownVector;",
            "⥠": "&LeftUpTeeVector;",
            "↿": "&upharpoonleft;",
            "⥘": "&LeftUpVectorBar;",
            "↼": "&lharu;",
            "⥒": "&LeftVectorBar;",
            "⋚": "&lesseqgtr;",
            "≦": "&leqq;",
            "≶": "&lg;",
            "⪡": "&LessLess;",
            "⩽": "&les;",
            "≲": "&lsim;",
            "𝔏": "&Lfr;",
            "⋘": "&Ll;",
            "⇚": "&lAarr;",
            "Ŀ": "&Lmidot;",
            "⟵": "&xlarr;",
            "⟷": "&xharr;",
            "⟶": "&xrarr;",
            "𝕃": "&Lopf;",
            "↙": "&swarrow;",
            "↘": "&searrow;",
            "↰": "&lsh;",
            "Ł": "&Lstrok;",
            "≪": "&ll;",
            "⤅": "&Map;",
            "М": "&Mcy;",
            " ": "&MediumSpace;",
            "ℳ": "&phmmat;",
            "𝔐": "&Mfr;",
            "∓": "&mp;",
            "𝕄": "&Mopf;",
            "Μ": "&Mu;",
            "Њ": "&NJcy;",
            "Ń": "&Nacute;",
            "Ň": "&Ncaron;",
            "Ņ": "&Ncedil;",
            "Н": "&Ncy;",
            "​": "&ZeroWidthSpace;",
            "\n": "&NewLine;",
            "𝔑": "&Nfr;",
            "⁠": "&NoBreak;",
            " ": "&nbsp;",
            "ℕ": "&naturals;",
            "⫬": "&Not;",
            "≢": "&nequiv;",
            "≭": "&NotCupCap;",
            "∦": "&nspar;",
            "∉": "&notinva;",
            "≠": "&ne;",
            "≂̸": "&nesim;",
            "∄": "&nexists;",
            "≯": "&ngtr;",
            "≱": "&ngeq;",
            "≧̸": "&ngeqq;",
            "≫̸": "&nGtv;",
            "≹": "&ntgl;",
            "⩾̸": "&nges;",
            "≵": "&ngsim;",
            "≎̸": "&nbump;",
            "≏̸": "&nbumpe;",
            "⋪": "&ntriangleleft;",
            "⧏̸": "&NotLeftTriangleBar;",
            "⋬": "&ntrianglelefteq;",
            "≮": "&nlt;",
            "≰": "&nleq;",
            "≸": "&ntlg;",
            "≪̸": "&nLtv;",
            "⩽̸": "&nles;",
            "≴": "&nlsim;",
            "⪢̸": "&NotNestedGreaterGreater;",
            "⪡̸": "&NotNestedLessLess;",
            "⊀": "&nprec;",
            "⪯̸": "&npreceq;",
            "⋠": "&nprcue;",
            "∌": "&notniva;",
            "⋫": "&ntriangleright;",
            "⧐̸": "&NotRightTriangleBar;",
            "⋭": "&ntrianglerighteq;",
            "⊏̸": "&NotSquareSubset;",
            "⋢": "&nsqsube;",
            "⊐̸": "&NotSquareSuperset;",
            "⋣": "&nsqsupe;",
            "⊂⃒": "&vnsub;",
            "⊈": "&nsubseteq;",
            "⊁": "&nsucc;",
            "⪰̸": "&nsucceq;",
            "⋡": "&nsccue;",
            "≿̸": "&NotSucceedsTilde;",
            "⊃⃒": "&vnsup;",
            "⊉": "&nsupseteq;",
            "≁": "&nsim;",
            "≄": "&nsimeq;",
            "≇": "&ncong;",
            "≉": "&napprox;",
            "∤": "&nsmid;",
            "𝒩": "&Nscr;",
            "Ñ": "&Ntilde;",
            "Ν": "&Nu;",
            "Œ": "&OElig;",
            "Ó": "&Oacute;",
            "Ô": "&Ocirc;",
            "О": "&Ocy;",
            "Ő": "&Odblac;",
            "𝔒": "&Ofr;",
            "Ò": "&Ograve;",
            "Ō": "&Omacr;",
            "Ω": "&ohm;",
            "Ο": "&Omicron;",
            "𝕆": "&Oopf;",
            "“": "&ldquo;",
            "‘": "&lsquo;",
            "⩔": "&Or;",
            "𝒪": "&Oscr;",
            "Ø": "&Oslash;",
            "Õ": "&Otilde;",
            "⨷": "&Otimes;",
            "Ö": "&Ouml;",
            "‾": "&oline;",
            "⏞": "&OverBrace;",
            "⎴": "&tbrk;",
            "⏜": "&OverParenthesis;",
            "∂": "&part;",
            "П": "&Pcy;",
            "𝔓": "&Pfr;",
            "Φ": "&Phi;",
            "Π": "&Pi;",
            "±": "&pm;",
            "ℙ": "&primes;",
            "⪻": "&Pr;",
            "≺": "&prec;",
            "⪯": "&preceq;",
            "≼": "&preccurlyeq;",
            "≾": "&prsim;",
            "″": "&Prime;",
            "∏": "&prod;",
            "∝": "&vprop;",
            "𝒫": "&Pscr;",
            "Ψ": "&Psi;",
            '"': "&quot;",
            "𝔔": "&Qfr;",
            "ℚ": "&rationals;",
            "𝒬": "&Qscr;",
            "⤐": "&drbkarow;",
            "®": "&reg;",
            "Ŕ": "&Racute;",
            "⟫": "&Rang;",
            "↠": "&twoheadrightarrow;",
            "⤖": "&Rarrtl;",
            "Ř": "&Rcaron;",
            "Ŗ": "&Rcedil;",
            "Р": "&Rcy;",
            "ℜ": "&realpart;",
            "∋": "&niv;",
            "⇋": "&lrhar;",
            "⥯": "&duhar;",
            "Ρ": "&Rho;",
            "⟩": "&rangle;",
            "→": "&srarr;",
            "⇥": "&rarrb;",
            "⇄": "&rlarr;",
            "⌉": "&rceil;",
            "⟧": "&robrk;",
            "⥝": "&RightDownTeeVector;",
            "⇂": "&downharpoonright;",
            "⥕": "&RightDownVectorBar;",
            "⌋": "&rfloor;",
            "⊢": "&vdash;",
            "↦": "&mapsto;",
            "⥛": "&RightTeeVector;",
            "⊳": "&vrtri;",
            "⧐": "&RightTriangleBar;",
            "⊵": "&trianglerighteq;",
            "⥏": "&RightUpDownVector;",
            "⥜": "&RightUpTeeVector;",
            "↾": "&upharpoonright;",
            "⥔": "&RightUpVectorBar;",
            "⇀": "&rightharpoonup;",
            "⥓": "&RightVectorBar;",
            "ℝ": "&reals;",
            "⥰": "&RoundImplies;",
            "⇛": "&rAarr;",
            "ℛ": "&realine;",
            "↱": "&rsh;",
            "⧴": "&RuleDelayed;",
            "Щ": "&SHCHcy;",
            "Ш": "&SHcy;",
            "Ь": "&SOFTcy;",
            "Ś": "&Sacute;",
            "⪼": "&Sc;",
            "Š": "&Scaron;",
            "Ş": "&Scedil;",
            "Ŝ": "&Scirc;",
            "С": "&Scy;",
            "𝔖": "&Sfr;",
            "↑": "&uparrow;",
            "Σ": "&Sigma;",
            "∘": "&compfn;",
            "𝕊": "&Sopf;",
            "√": "&radic;",
            "□": "&square;",
            "⊓": "&sqcap;",
            "⊏": "&sqsubset;",
            "⊑": "&sqsubseteq;",
            "⊐": "&sqsupset;",
            "⊒": "&sqsupseteq;",
            "⊔": "&sqcup;",
            "𝒮": "&Sscr;",
            "⋆": "&sstarf;",
            "⋐": "&Subset;",
            "⊆": "&subseteq;",
            "≻": "&succ;",
            "⪰": "&succeq;",
            "≽": "&succcurlyeq;",
            "≿": "&succsim;",
            "∑": "&sum;",
            "⋑": "&Supset;",
            "⊃": "&supset;",
            "⊇": "&supseteq;",
            "Þ": "&THORN;",
            "™": "&trade;",
            "Ћ": "&TSHcy;",
            "Ц": "&TScy;",
            "\t": "&Tab;",
            "Τ": "&Tau;",
            "Ť": "&Tcaron;",
            "Ţ": "&Tcedil;",
            "Т": "&Tcy;",
            "𝔗": "&Tfr;",
            "∴": "&therefore;",
            "Θ": "&Theta;",
            "  ": "&ThickSpace;",
            " ": "&thinsp;",
            "∼": "&thksim;",
            "≃": "&simeq;",
            "≅": "&cong;",
            "≈": "&thkap;",
            "𝕋": "&Topf;",
            "⃛": "&tdot;",
            "𝒯": "&Tscr;",
            "Ŧ": "&Tstrok;",
            "Ú": "&Uacute;",
            "↟": "&Uarr;",
            "⥉": "&Uarrocir;",
            "Ў": "&Ubrcy;",
            "Ŭ": "&Ubreve;",
            "Û": "&Ucirc;",
            "У": "&Ucy;",
            "Ű": "&Udblac;",
            "𝔘": "&Ufr;",
            "Ù": "&Ugrave;",
            "Ū": "&Umacr;",
            _: "&lowbar;",
            "⏟": "&UnderBrace;",
            "⎵": "&bbrk;",
            "⏝": "&UnderParenthesis;",
            "⋃": "&xcup;",
            "⊎": "&uplus;",
            "Ų": "&Uogon;",
            "𝕌": "&Uopf;",
            "⤒": "&UpArrowBar;",
            "⇅": "&udarr;",
            "↕": "&varr;",
            "⥮": "&udhar;",
            "⊥": "&perp;",
            "↥": "&mapstoup;",
            "↖": "&nwarrow;",
            "↗": "&nearrow;",
            "ϒ": "&upsih;",
            "Υ": "&Upsilon;",
            "Ů": "&Uring;",
            "𝒰": "&Uscr;",
            "Ũ": "&Utilde;",
            "Ü": "&Uuml;",
            "⊫": "&VDash;",
            "⫫": "&Vbar;",
            "В": "&Vcy;",
            "⊩": "&Vdash;",
            "⫦": "&Vdashl;",
            "⋁": "&xvee;",
            "‖": "&Vert;",
            "∣": "&smid;",
            "|": "&vert;",
            "❘": "&VerticalSeparator;",
            "≀": "&wreath;",
            " ": "&hairsp;",
            "𝔙": "&Vfr;",
            "𝕍": "&Vopf;",
            "𝒱": "&Vscr;",
            "⊪": "&Vvdash;",
            "Ŵ": "&Wcirc;",
            "⋀": "&xwedge;",
            "𝔚": "&Wfr;",
            "𝕎": "&Wopf;",
            "𝒲": "&Wscr;",
            "𝔛": "&Xfr;",
            "Ξ": "&Xi;",
            "𝕏": "&Xopf;",
            "𝒳": "&Xscr;",
            "Я": "&YAcy;",
            "Ї": "&YIcy;",
            "Ю": "&YUcy;",
            "Ý": "&Yacute;",
            "Ŷ": "&Ycirc;",
            "Ы": "&Ycy;",
            "𝔜": "&Yfr;",
            "𝕐": "&Yopf;",
            "𝒴": "&Yscr;",
            "Ÿ": "&Yuml;",
            "Ж": "&ZHcy;",
            "Ź": "&Zacute;",
            "Ž": "&Zcaron;",
            "З": "&Zcy;",
            "Ż": "&Zdot;",
            "Ζ": "&Zeta;",
            "ℨ": "&zeetrf;",
            "ℤ": "&integers;",
            "𝒵": "&Zscr;",
            "á": "&aacute;",
            "ă": "&abreve;",
            "∾": "&mstpos;",
            "∾̳": "&acE;",
            "∿": "&acd;",
            "â": "&acirc;",
            "а": "&acy;",
            "æ": "&aelig;",
            "𝔞": "&afr;",
            "à": "&agrave;",
            "ℵ": "&aleph;",
            "α": "&alpha;",
            "ā": "&amacr;",
            "⨿": "&amalg;",
            "∧": "&wedge;",
            "⩕": "&andand;",
            "⩜": "&andd;",
            "⩘": "&andslope;",
            "⩚": "&andv;",
            "∠": "&angle;",
            "⦤": "&ange;",
            "∡": "&measuredangle;",
            "⦨": "&angmsdaa;",
            "⦩": "&angmsdab;",
            "⦪": "&angmsdac;",
            "⦫": "&angmsdad;",
            "⦬": "&angmsdae;",
            "⦭": "&angmsdaf;",
            "⦮": "&angmsdag;",
            "⦯": "&angmsdah;",
            "∟": "&angrt;",
            "⊾": "&angrtvb;",
            "⦝": "&angrtvbd;",
            "∢": "&angsph;",
            "⍼": "&angzarr;",
            "ą": "&aogon;",
            "𝕒": "&aopf;",
            "⩰": "&apE;",
            "⩯": "&apacir;",
            "≊": "&approxeq;",
            "≋": "&apid;",
            "'": "&apos;",
            "å": "&aring;",
            "𝒶": "&ascr;",
            "*": "&midast;",
            "ã": "&atilde;",
            "ä": "&auml;",
            "⨑": "&awint;",
            "⫭": "&bNot;",
            "≌": "&bcong;",
            "϶": "&bepsi;",
            "‵": "&bprime;",
            "∽": "&bsim;",
            "⋍": "&bsime;",
            "⊽": "&barvee;",
            "⌅": "&barwedge;",
            "⎶": "&bbrktbrk;",
            "б": "&bcy;",
            "„": "&ldquor;",
            "⦰": "&bemptyv;",
            "β": "&beta;",
            "ℶ": "&beth;",
            "≬": "&twixt;",
            "𝔟": "&bfr;",
            "◯": "&xcirc;",
            "⨀": "&xodot;",
            "⨁": "&xoplus;",
            "⨂": "&xotime;",
            "⨆": "&xsqcup;",
            "★": "&starf;",
            "▽": "&xdtri;",
            "△": "&xutri;",
            "⨄": "&xuplus;",
            "⤍": "&rbarr;",
            "⧫": "&lozf;",
            "▴": "&utrif;",
            "▾": "&dtrif;",
            "◂": "&ltrif;",
            "▸": "&rtrif;",
            "␣": "&blank;",
            "▒": "&blk12;",
            "░": "&blk14;",
            "▓": "&blk34;",
            "█": "&block;",
            "=⃥": "&bne;",
            "≡⃥": "&bnequiv;",
            "⌐": "&bnot;",
            "𝕓": "&bopf;",
            "⋈": "&bowtie;",
            "╗": "&boxDL;",
            "╔": "&boxDR;",
            "╖": "&boxDl;",
            "╓": "&boxDr;",
            "═": "&boxH;",
            "╦": "&boxHD;",
            "╩": "&boxHU;",
            "╤": "&boxHd;",
            "╧": "&boxHu;",
            "╝": "&boxUL;",
            "╚": "&boxUR;",
            "╜": "&boxUl;",
            "╙": "&boxUr;",
            "║": "&boxV;",
            "╬": "&boxVH;",
            "╣": "&boxVL;",
            "╠": "&boxVR;",
            "╫": "&boxVh;",
            "╢": "&boxVl;",
            "╟": "&boxVr;",
            "⧉": "&boxbox;",
            "╕": "&boxdL;",
            "╒": "&boxdR;",
            "┐": "&boxdl;",
            "┌": "&boxdr;",
            "╥": "&boxhD;",
            "╨": "&boxhU;",
            "┬": "&boxhd;",
            "┴": "&boxhu;",
            "⊟": "&minusb;",
            "⊞": "&plusb;",
            "⊠": "&timesb;",
            "╛": "&boxuL;",
            "╘": "&boxuR;",
            "┘": "&boxul;",
            "└": "&boxur;",
            "│": "&boxv;",
            "╪": "&boxvH;",
            "╡": "&boxvL;",
            "╞": "&boxvR;",
            "┼": "&boxvh;",
            "┤": "&boxvl;",
            "├": "&boxvr;",
            "¦": "&brvbar;",
            "𝒷": "&bscr;",
            "⁏": "&bsemi;",
            "\\": "&bsol;",
            "⧅": "&bsolb;",
            "⟈": "&bsolhsub;",
            "•": "&bullet;",
            "⪮": "&bumpE;",
            "ć": "&cacute;",
            "∩": "&cap;",
            "⩄": "&capand;",
            "⩉": "&capbrcup;",
            "⩋": "&capcap;",
            "⩇": "&capcup;",
            "⩀": "&capdot;",
            "∩︀": "&caps;",
            "⁁": "&caret;",
            "⩍": "&ccaps;",
            "č": "&ccaron;",
            "ç": "&ccedil;",
            "ĉ": "&ccirc;",
            "⩌": "&ccups;",
            "⩐": "&ccupssm;",
            "ċ": "&cdot;",
            "⦲": "&cemptyv;",
            "¢": "&cent;",
            "𝔠": "&cfr;",
            "ч": "&chcy;",
            "✓": "&checkmark;",
            "χ": "&chi;",
            "○": "&cir;",
            "⧃": "&cirE;",
            "ˆ": "&circ;",
            "≗": "&cire;",
            "↺": "&olarr;",
            "↻": "&orarr;",
            "Ⓢ": "&oS;",
            "⊛": "&oast;",
            "⊚": "&ocir;",
            "⊝": "&odash;",
            "⨐": "&cirfnint;",
            "⫯": "&cirmid;",
            "⧂": "&cirscir;",
            "♣": "&clubsuit;",
            ":": "&colon;",
            ",": "&comma;",
            "@": "&commat;",
            "∁": "&complement;",
            "⩭": "&congdot;",
            "𝕔": "&copf;",
            "℗": "&copysr;",
            "↵": "&crarr;",
            "✗": "&cross;",
            "𝒸": "&cscr;",
            "⫏": "&csub;",
            "⫑": "&csube;",
            "⫐": "&csup;",
            "⫒": "&csupe;",
            "⋯": "&ctdot;",
            "⤸": "&cudarrl;",
            "⤵": "&cudarrr;",
            "⋞": "&curlyeqprec;",
            "⋟": "&curlyeqsucc;",
            "↶": "&curvearrowleft;",
            "⤽": "&cularrp;",
            "∪": "&cup;",
            "⩈": "&cupbrcap;",
            "⩆": "&cupcap;",
            "⩊": "&cupcup;",
            "⊍": "&cupdot;",
            "⩅": "&cupor;",
            "∪︀": "&cups;",
            "↷": "&curvearrowright;",
            "⤼": "&curarrm;",
            "⋎": "&cuvee;",
            "⋏": "&cuwed;",
            "¤": "&curren;",
            "∱": "&cwint;",
            "⌭": "&cylcty;",
            "⥥": "&dHar;",
            "†": "&dagger;",
            "ℸ": "&daleth;",
            "‐": "&hyphen;",
            "⤏": "&rBarr;",
            "ď": "&dcaron;",
            "д": "&dcy;",
            "⇊": "&downdownarrows;",
            "⩷": "&eDDot;",
            "°": "&deg;",
            "δ": "&delta;",
            "⦱": "&demptyv;",
            "⥿": "&dfisht;",
            "𝔡": "&dfr;",
            "♦": "&diams;",
            "ϝ": "&gammad;",
            "⋲": "&disin;",
            "÷": "&divide;",
            "⋇": "&divonx;",
            "ђ": "&djcy;",
            "⌞": "&llcorner;",
            "⌍": "&dlcrop;",
            $: "&dollar;",
            "𝕕": "&dopf;",
            "≑": "&eDot;",
            "∸": "&minusd;",
            "∔": "&plusdo;",
            "⊡": "&sdotb;",
            "⌟": "&lrcorner;",
            "⌌": "&drcrop;",
            "𝒹": "&dscr;",
            "ѕ": "&dscy;",
            "⧶": "&dsol;",
            "đ": "&dstrok;",
            "⋱": "&dtdot;",
            "▿": "&triangledown;",
            "⦦": "&dwangle;",
            "џ": "&dzcy;",
            "⟿": "&dzigrarr;",
            "é": "&eacute;",
            "⩮": "&easter;",
            "ě": "&ecaron;",
            "≖": "&eqcirc;",
            "ê": "&ecirc;",
            "≕": "&eqcolon;",
            "э": "&ecy;",
            "ė": "&edot;",
            "≒": "&fallingdotseq;",
            "𝔢": "&efr;",
            "⪚": "&eg;",
            "è": "&egrave;",
            "⪖": "&eqslantgtr;",
            "⪘": "&egsdot;",
            "⪙": "&el;",
            "⏧": "&elinters;",
            "ℓ": "&ell;",
            "⪕": "&eqslantless;",
            "⪗": "&elsdot;",
            "ē": "&emacr;",
            "∅": "&varnothing;",
            " ": "&emsp13;",
            " ": "&emsp14;",
            " ": "&emsp;",
            "ŋ": "&eng;",
            " ": "&ensp;",
            "ę": "&eogon;",
            "𝕖": "&eopf;",
            "⋕": "&epar;",
            "⧣": "&eparsl;",
            "⩱": "&eplus;",
            "ε": "&epsilon;",
            "ϵ": "&varepsilon;",
            "=": "&equals;",
            "≟": "&questeq;",
            "⩸": "&equivDD;",
            "⧥": "&eqvparsl;",
            "≓": "&risingdotseq;",
            "⥱": "&erarr;",
            "ℯ": "&escr;",
            "η": "&eta;",
            "ð": "&eth;",
            "ë": "&euml;",
            "€": "&euro;",
            "!": "&excl;",
            "ф": "&fcy;",
            "♀": "&female;",
            "ﬃ": "&ffilig;",
            "ﬀ": "&fflig;",
            "ﬄ": "&ffllig;",
            "𝔣": "&ffr;",
            "ﬁ": "&filig;",
            fj: "&fjlig;",
            "♭": "&flat;",
            "ﬂ": "&fllig;",
            "▱": "&fltns;",
            "ƒ": "&fnof;",
            "𝕗": "&fopf;",
            "⋔": "&pitchfork;",
            "⫙": "&forkv;",
            "⨍": "&fpartint;",
            "½": "&half;",
            "⅓": "&frac13;",
            "¼": "&frac14;",
            "⅕": "&frac15;",
            "⅙": "&frac16;",
            "⅛": "&frac18;",
            "⅔": "&frac23;",
            "⅖": "&frac25;",
            "¾": "&frac34;",
            "⅗": "&frac35;",
            "⅜": "&frac38;",
            "⅘": "&frac45;",
            "⅚": "&frac56;",
            "⅝": "&frac58;",
            "⅞": "&frac78;",
            "⁄": "&frasl;",
            "⌢": "&sfrown;",
            "𝒻": "&fscr;",
            "⪌": "&gtreqqless;",
            "ǵ": "&gacute;",
            "γ": "&gamma;",
            "⪆": "&gtrapprox;",
            "ğ": "&gbreve;",
            "ĝ": "&gcirc;",
            "г": "&gcy;",
            "ġ": "&gdot;",
            "⪩": "&gescc;",
            "⪀": "&gesdot;",
            "⪂": "&gesdoto;",
            "⪄": "&gesdotol;",
            "⋛︀": "&gesl;",
            "⪔": "&gesles;",
            "𝔤": "&gfr;",
            "ℷ": "&gimel;",
            "ѓ": "&gjcy;",
            "⪒": "&glE;",
            "⪥": "&gla;",
            "⪤": "&glj;",
            "≩": "&gneqq;",
            "⪊": "&gnapprox;",
            "⪈": "&gneq;",
            "⋧": "&gnsim;",
            "𝕘": "&gopf;",
            "ℊ": "&gscr;",
            "⪎": "&gsime;",
            "⪐": "&gsiml;",
            "⪧": "&gtcc;",
            "⩺": "&gtcir;",
            "⋗": "&gtrdot;",
            "⦕": "&gtlPar;",
            "⩼": "&gtquest;",
            "⥸": "&gtrarr;",
            "≩︀": "&gvnE;",
            "ъ": "&hardcy;",
            "⥈": "&harrcir;",
            "↭": "&leftrightsquigarrow;",
            "ℏ": "&plankv;",
            "ĥ": "&hcirc;",
            "♥": "&heartsuit;",
            "…": "&mldr;",
            "⊹": "&hercon;",
            "𝔥": "&hfr;",
            "⤥": "&searhk;",
            "⤦": "&swarhk;",
            "⇿": "&hoarr;",
            "∻": "&homtht;",
            "↩": "&larrhk;",
            "↪": "&rarrhk;",
            "𝕙": "&hopf;",
            "―": "&horbar;",
            "𝒽": "&hscr;",
            "ħ": "&hstrok;",
            "⁃": "&hybull;",
            "í": "&iacute;",
            "î": "&icirc;",
            "и": "&icy;",
            "е": "&iecy;",
            "¡": "&iexcl;",
            "𝔦": "&ifr;",
            "ì": "&igrave;",
            "⨌": "&qint;",
            "∭": "&tint;",
            "⧜": "&iinfin;",
            "℩": "&iiota;",
            "ĳ": "&ijlig;",
            "ī": "&imacr;",
            "ı": "&inodot;",
            "⊷": "&imof;",
            "Ƶ": "&imped;",
            "℅": "&incare;",
            "∞": "&infin;",
            "⧝": "&infintie;",
            "⊺": "&intercal;",
            "⨗": "&intlarhk;",
            "⨼": "&iprod;",
            "ё": "&iocy;",
            "į": "&iogon;",
            "𝕚": "&iopf;",
            "ι": "&iota;",
            "¿": "&iquest;",
            "𝒾": "&iscr;",
            "⋹": "&isinE;",
            "⋵": "&isindot;",
            "⋴": "&isins;",
            "⋳": "&isinsv;",
            "ĩ": "&itilde;",
            "і": "&iukcy;",
            "ï": "&iuml;",
            "ĵ": "&jcirc;",
            "й": "&jcy;",
            "𝔧": "&jfr;",
            "ȷ": "&jmath;",
            "𝕛": "&jopf;",
            "𝒿": "&jscr;",
            "ј": "&jsercy;",
            "є": "&jukcy;",
            "κ": "&kappa;",
            "ϰ": "&varkappa;",
            "ķ": "&kcedil;",
            "к": "&kcy;",
            "𝔨": "&kfr;",
            "ĸ": "&kgreen;",
            "х": "&khcy;",
            "ќ": "&kjcy;",
            "𝕜": "&kopf;",
            "𝓀": "&kscr;",
            "⤛": "&lAtail;",
            "⤎": "&lBarr;",
            "⪋": "&lesseqqgtr;",
            "⥢": "&lHar;",
            "ĺ": "&lacute;",
            "⦴": "&laemptyv;",
            "λ": "&lambda;",
            "⦑": "&langd;",
            "⪅": "&lessapprox;",
            "«": "&laquo;",
            "⤟": "&larrbfs;",
            "⤝": "&larrfs;",
            "↫": "&looparrowleft;",
            "⤹": "&larrpl;",
            "⥳": "&larrsim;",
            "↢": "&leftarrowtail;",
            "⪫": "&lat;",
            "⤙": "&latail;",
            "⪭": "&late;",
            "⪭︀": "&lates;",
            "⤌": "&lbarr;",
            "❲": "&lbbrk;",
            "{": "&lcub;",
            "[": "&lsqb;",
            "⦋": "&lbrke;",
            "⦏": "&lbrksld;",
            "⦍": "&lbrkslu;",
            "ľ": "&lcaron;",
            "ļ": "&lcedil;",
            "л": "&lcy;",
            "⤶": "&ldca;",
            "⥧": "&ldrdhar;",
            "⥋": "&ldrushar;",
            "↲": "&ldsh;",
            "≤": "&leq;",
            "⇇": "&llarr;",
            "⋋": "&lthree;",
            "⪨": "&lescc;",
            "⩿": "&lesdot;",
            "⪁": "&lesdoto;",
            "⪃": "&lesdotor;",
            "⋚︀": "&lesg;",
            "⪓": "&lesges;",
            "⋖": "&ltdot;",
            "⥼": "&lfisht;",
            "𝔩": "&lfr;",
            "⪑": "&lgE;",
            "⥪": "&lharul;",
            "▄": "&lhblk;",
            "љ": "&ljcy;",
            "⥫": "&llhard;",
            "◺": "&lltri;",
            "ŀ": "&lmidot;",
            "⎰": "&lmoustache;",
            "≨": "&lneqq;",
            "⪉": "&lnapprox;",
            "⪇": "&lneq;",
            "⋦": "&lnsim;",
            "⟬": "&loang;",
            "⇽": "&loarr;",
            "⟼": "&xmap;",
            "↬": "&rarrlp;",
            "⦅": "&lopar;",
            "𝕝": "&lopf;",
            "⨭": "&loplus;",
            "⨴": "&lotimes;",
            "∗": "&lowast;",
            "◊": "&lozenge;",
            "(": "&lpar;",
            "⦓": "&lparlt;",
            "⥭": "&lrhard;",
            "‎": "&lrm;",
            "⊿": "&lrtri;",
            "‹": "&lsaquo;",
            "𝓁": "&lscr;",
            "⪍": "&lsime;",
            "⪏": "&lsimg;",
            "‚": "&sbquo;",
            "ł": "&lstrok;",
            "⪦": "&ltcc;",
            "⩹": "&ltcir;",
            "⋉": "&ltimes;",
            "⥶": "&ltlarr;",
            "⩻": "&ltquest;",
            "⦖": "&ltrPar;",
            "◃": "&triangleleft;",
            "⥊": "&lurdshar;",
            "⥦": "&luruhar;",
            "≨︀": "&lvnE;",
            "∺": "&mDDot;",
            "¯": "&strns;",
            "♂": "&male;",
            "✠": "&maltese;",
            "▮": "&marker;",
            "⨩": "&mcomma;",
            "м": "&mcy;",
            "—": "&mdash;",
            "𝔪": "&mfr;",
            "℧": "&mho;",
            "µ": "&micro;",
            "⫰": "&midcir;",
            "−": "&minus;",
            "⨪": "&minusdu;",
            "⫛": "&mlcp;",
            "⊧": "&models;",
            "𝕞": "&mopf;",
            "𝓂": "&mscr;",
            "μ": "&mu;",
            "⊸": "&mumap;",
            "⋙̸": "&nGg;",
            "≫⃒": "&nGt;",
            "⇍": "&nlArr;",
            "⇎": "&nhArr;",
            "⋘̸": "&nLl;",
            "≪⃒": "&nLt;",
            "⇏": "&nrArr;",
            "⊯": "&nVDash;",
            "⊮": "&nVdash;",
            "ń": "&nacute;",
            "∠⃒": "&nang;",
            "⩰̸": "&napE;",
            "≋̸": "&napid;",
            "ŉ": "&napos;",
            "♮": "&natural;",
            "⩃": "&ncap;",
            "ň": "&ncaron;",
            "ņ": "&ncedil;",
            "⩭̸": "&ncongdot;",
            "⩂": "&ncup;",
            "н": "&ncy;",
            "–": "&ndash;",
            "⇗": "&neArr;",
            "⤤": "&nearhk;",
            "≐̸": "&nedot;",
            "⤨": "&toea;",
            "𝔫": "&nfr;",
            "↮": "&nleftrightarrow;",
            "⫲": "&nhpar;",
            "⋼": "&nis;",
            "⋺": "&nisd;",
            "њ": "&njcy;",
            "≦̸": "&nleqq;",
            "↚": "&nleftarrow;",
            "‥": "&nldr;",
            "𝕟": "&nopf;",
            "¬": "&not;",
            "⋹̸": "&notinE;",
            "⋵̸": "&notindot;",
            "⋷": "&notinvb;",
            "⋶": "&notinvc;",
            "⋾": "&notnivb;",
            "⋽": "&notnivc;",
            "⫽⃥": "&nparsl;",
            "∂̸": "&npart;",
            "⨔": "&npolint;",
            "↛": "&nrightarrow;",
            "⤳̸": "&nrarrc;",
            "↝̸": "&nrarrw;",
            "𝓃": "&nscr;",
            "⊄": "&nsub;",
            "⫅̸": "&nsubseteqq;",
            "⊅": "&nsup;",
            "⫆̸": "&nsupseteqq;",
            "ñ": "&ntilde;",
            "ν": "&nu;",
            "#": "&num;",
            "№": "&numero;",
            " ": "&numsp;",
            "⊭": "&nvDash;",
            "⤄": "&nvHarr;",
            "≍⃒": "&nvap;",
            "⊬": "&nvdash;",
            "≥⃒": "&nvge;",
            ">⃒": "&nvgt;",
            "⧞": "&nvinfin;",
            "⤂": "&nvlArr;",
            "≤⃒": "&nvle;",
            "<⃒": "&nvlt;",
            "⊴⃒": "&nvltrie;",
            "⤃": "&nvrArr;",
            "⊵⃒": "&nvrtrie;",
            "∼⃒": "&nvsim;",
            "⇖": "&nwArr;",
            "⤣": "&nwarhk;",
            "⤧": "&nwnear;",
            "ó": "&oacute;",
            "ô": "&ocirc;",
            "о": "&ocy;",
            "ő": "&odblac;",
            "⨸": "&odiv;",
            "⦼": "&odsold;",
            "œ": "&oelig;",
            "⦿": "&ofcir;",
            "𝔬": "&ofr;",
            "˛": "&ogon;",
            "ò": "&ograve;",
            "⧁": "&ogt;",
            "⦵": "&ohbar;",
            "⦾": "&olcir;",
            "⦻": "&olcross;",
            "⧀": "&olt;",
            "ō": "&omacr;",
            "ω": "&omega;",
            "ο": "&omicron;",
            "⦶": "&omid;",
            "𝕠": "&oopf;",
            "⦷": "&opar;",
            "⦹": "&operp;",
            "∨": "&vee;",
            "⩝": "&ord;",
            "ℴ": "&oscr;",
            "ª": "&ordf;",
            "º": "&ordm;",
            "⊶": "&origof;",
            "⩖": "&oror;",
            "⩗": "&orslope;",
            "⩛": "&orv;",
            "ø": "&oslash;",
            "⊘": "&osol;",
            "õ": "&otilde;",
            "⨶": "&otimesas;",
            "ö": "&ouml;",
            "⌽": "&ovbar;",
            "¶": "&para;",
            "⫳": "&parsim;",
            "⫽": "&parsl;",
            "п": "&pcy;",
            "%": "&percnt;",
            ".": "&period;",
            "‰": "&permil;",
            "‱": "&pertenk;",
            "𝔭": "&pfr;",
            "φ": "&phi;",
            "ϕ": "&varphi;",
            "☎": "&phone;",
            "π": "&pi;",
            "ϖ": "&varpi;",
            "ℎ": "&planckh;",
            "+": "&plus;",
            "⨣": "&plusacir;",
            "⨢": "&pluscir;",
            "⨥": "&plusdu;",
            "⩲": "&pluse;",
            "⨦": "&plussim;",
            "⨧": "&plustwo;",
            "⨕": "&pointint;",
            "𝕡": "&popf;",
            "£": "&pound;",
            "⪳": "&prE;",
            "⪷": "&precapprox;",
            "⪹": "&prnap;",
            "⪵": "&prnE;",
            "⋨": "&prnsim;",
            "′": "&prime;",
            "⌮": "&profalar;",
            "⌒": "&profline;",
            "⌓": "&profsurf;",
            "⊰": "&prurel;",
            "𝓅": "&pscr;",
            "ψ": "&psi;",
            " ": "&puncsp;",
            "𝔮": "&qfr;",
            "𝕢": "&qopf;",
            "⁗": "&qprime;",
            "𝓆": "&qscr;",
            "⨖": "&quatint;",
            "?": "&quest;",
            "⤜": "&rAtail;",
            "⥤": "&rHar;",
            "∽̱": "&race;",
            "ŕ": "&racute;",
            "⦳": "&raemptyv;",
            "⦒": "&rangd;",
            "⦥": "&range;",
            "»": "&raquo;",
            "⥵": "&rarrap;",
            "⤠": "&rarrbfs;",
            "⤳": "&rarrc;",
            "⤞": "&rarrfs;",
            "⥅": "&rarrpl;",
            "⥴": "&rarrsim;",
            "↣": "&rightarrowtail;",
            "↝": "&rightsquigarrow;",
            "⤚": "&ratail;",
            "∶": "&ratio;",
            "❳": "&rbbrk;",
            "}": "&rcub;",
            "]": "&rsqb;",
            "⦌": "&rbrke;",
            "⦎": "&rbrksld;",
            "⦐": "&rbrkslu;",
            "ř": "&rcaron;",
            "ŗ": "&rcedil;",
            "р": "&rcy;",
            "⤷": "&rdca;",
            "⥩": "&rdldhar;",
            "↳": "&rdsh;",
            "▭": "&rect;",
            "⥽": "&rfisht;",
            "𝔯": "&rfr;",
            "⥬": "&rharul;",
            "ρ": "&rho;",
            "ϱ": "&varrho;",
            "⇉": "&rrarr;",
            "⋌": "&rthree;",
            "˚": "&ring;",
            "‏": "&rlm;",
            "⎱": "&rmoustache;",
            "⫮": "&rnmid;",
            "⟭": "&roang;",
            "⇾": "&roarr;",
            "⦆": "&ropar;",
            "𝕣": "&ropf;",
            "⨮": "&roplus;",
            "⨵": "&rotimes;",
            ")": "&rpar;",
            "⦔": "&rpargt;",
            "⨒": "&rppolint;",
            "›": "&rsaquo;",
            "𝓇": "&rscr;",
            "⋊": "&rtimes;",
            "▹": "&triangleright;",
            "⧎": "&rtriltri;",
            "⥨": "&ruluhar;",
            "℞": "&rx;",
            "ś": "&sacute;",
            "⪴": "&scE;",
            "⪸": "&succapprox;",
            "š": "&scaron;",
            "ş": "&scedil;",
            "ŝ": "&scirc;",
            "⪶": "&succneqq;",
            "⪺": "&succnapprox;",
            "⋩": "&succnsim;",
            "⨓": "&scpolint;",
            "с": "&scy;",
            "⋅": "&sdot;",
            "⩦": "&sdote;",
            "⇘": "&seArr;",
            "§": "&sect;",
            ";": "&semi;",
            "⤩": "&tosa;",
            "✶": "&sext;",
            "𝔰": "&sfr;",
            "♯": "&sharp;",
            "щ": "&shchcy;",
            "ш": "&shcy;",
            "­": "&shy;",
            "σ": "&sigma;",
            "ς": "&varsigma;",
            "⩪": "&simdot;",
            "⪞": "&simg;",
            "⪠": "&simgE;",
            "⪝": "&siml;",
            "⪟": "&simlE;",
            "≆": "&simne;",
            "⨤": "&simplus;",
            "⥲": "&simrarr;",
            "⨳": "&smashp;",
            "⧤": "&smeparsl;",
            "⌣": "&ssmile;",
            "⪪": "&smt;",
            "⪬": "&smte;",
            "⪬︀": "&smtes;",
            "ь": "&softcy;",
            "/": "&sol;",
            "⧄": "&solb;",
            "⌿": "&solbar;",
            "𝕤": "&sopf;",
            "♠": "&spadesuit;",
            "⊓︀": "&sqcaps;",
            "⊔︀": "&sqcups;",
            "𝓈": "&sscr;",
            "☆": "&star;",
            "⊂": "&subset;",
            "⫅": "&subseteqq;",
            "⪽": "&subdot;",
            "⫃": "&subedot;",
            "⫁": "&submult;",
            "⫋": "&subsetneqq;",
            "⊊": "&subsetneq;",
            "⪿": "&subplus;",
            "⥹": "&subrarr;",
            "⫇": "&subsim;",
            "⫕": "&subsub;",
            "⫓": "&subsup;",
            "♪": "&sung;",
            "¹": "&sup1;",
            "²": "&sup2;",
            "³": "&sup3;",
            "⫆": "&supseteqq;",
            "⪾": "&supdot;",
            "⫘": "&supdsub;",
            "⫄": "&supedot;",
            "⟉": "&suphsol;",
            "⫗": "&suphsub;",
            "⥻": "&suplarr;",
            "⫂": "&supmult;",
            "⫌": "&supsetneqq;",
            "⊋": "&supsetneq;",
            "⫀": "&supplus;",
            "⫈": "&supsim;",
            "⫔": "&supsub;",
            "⫖": "&supsup;",
            "⇙": "&swArr;",
            "⤪": "&swnwar;",
            "ß": "&szlig;",
            "⌖": "&target;",
            "τ": "&tau;",
            "ť": "&tcaron;",
            "ţ": "&tcedil;",
            "т": "&tcy;",
            "⌕": "&telrec;",
            "𝔱": "&tfr;",
            "θ": "&theta;",
            "ϑ": "&vartheta;",
            "þ": "&thorn;",
            "×": "&times;",
            "⨱": "&timesbar;",
            "⨰": "&timesd;",
            "⌶": "&topbot;",
            "⫱": "&topcir;",
            "𝕥": "&topf;",
            "⫚": "&topfork;",
            "‴": "&tprime;",
            "▵": "&utri;",
            "≜": "&trie;",
            "◬": "&tridot;",
            "⨺": "&triminus;",
            "⨹": "&triplus;",
            "⧍": "&trisb;",
            "⨻": "&tritime;",
            "⏢": "&trpezium;",
            "𝓉": "&tscr;",
            "ц": "&tscy;",
            "ћ": "&tshcy;",
            "ŧ": "&tstrok;",
            "⥣": "&uHar;",
            "ú": "&uacute;",
            "ў": "&ubrcy;",
            "ŭ": "&ubreve;",
            "û": "&ucirc;",
            "у": "&ucy;",
            "ű": "&udblac;",
            "⥾": "&ufisht;",
            "𝔲": "&ufr;",
            "ù": "&ugrave;",
            "▀": "&uhblk;",
            "⌜": "&ulcorner;",
            "⌏": "&ulcrop;",
            "◸": "&ultri;",
            "ū": "&umacr;",
            "ų": "&uogon;",
            "𝕦": "&uopf;",
            "υ": "&upsilon;",
            "⇈": "&uuarr;",
            "⌝": "&urcorner;",
            "⌎": "&urcrop;",
            "ů": "&uring;",
            "◹": "&urtri;",
            "𝓊": "&uscr;",
            "⋰": "&utdot;",
            "ũ": "&utilde;",
            "ü": "&uuml;",
            "⦧": "&uwangle;",
            "⫨": "&vBar;",
            "⫩": "&vBarv;",
            "⦜": "&vangrt;",
            "⊊︀": "&vsubne;",
            "⫋︀": "&vsubnE;",
            "⊋︀": "&vsupne;",
            "⫌︀": "&vsupnE;",
            "в": "&vcy;",
            "⊻": "&veebar;",
            "≚": "&veeeq;",
            "⋮": "&vellip;",
            "𝔳": "&vfr;",
            "𝕧": "&vopf;",
            "𝓋": "&vscr;",
            "⦚": "&vzigzag;",
            "ŵ": "&wcirc;",
            "⩟": "&wedbar;",
            "≙": "&wedgeq;",
            "℘": "&wp;",
            "𝔴": "&wfr;",
            "𝕨": "&wopf;",
            "𝓌": "&wscr;",
            "𝔵": "&xfr;",
            "ξ": "&xi;",
            "⋻": "&xnis;",
            "𝕩": "&xopf;",
            "𝓍": "&xscr;",
            "ý": "&yacute;",
            "я": "&yacy;",
            "ŷ": "&ycirc;",
            "ы": "&ycy;",
            "¥": "&yen;",
            "𝔶": "&yfr;",
            "ї": "&yicy;",
            "𝕪": "&yopf;",
            "𝓎": "&yscr;",
            "ю": "&yucy;",
            "ÿ": "&yuml;",
            "ź": "&zacute;",
            "ž": "&zcaron;",
            "з": "&zcy;",
            "ż": "&zdot;",
            "ζ": "&zeta;",
            "𝔷": "&zfr;",
            "ж": "&zhcy;",
            "⇝": "&zigrarr;",
            "𝕫": "&zopf;",
            "𝓏": "&zscr;",
            "‍": "&zwj;",
            "‌": "&zwnj;"
        }
    }
};

},{}],"2RgqP":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.numericUnicodeMap = {
    0: 65533,
    128: 8364,
    130: 8218,
    131: 402,
    132: 8222,
    133: 8230,
    134: 8224,
    135: 8225,
    136: 710,
    137: 8240,
    138: 352,
    139: 8249,
    140: 338,
    142: 381,
    145: 8216,
    146: 8217,
    147: 8220,
    148: 8221,
    149: 8226,
    150: 8211,
    151: 8212,
    152: 732,
    153: 8482,
    154: 353,
    155: 8250,
    156: 339,
    158: 382,
    159: 376
};

},{}],"4YHvO":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fromCodePoint = String.fromCodePoint || function(astralCodePoint) {
    return String.fromCharCode(Math.floor((astralCodePoint - 65536) / 1024) + 55296, (astralCodePoint - 65536) % 1024 + 56320);
};
exports.getCodePoint = String.prototype.codePointAt ? function(input, position) {
    return input.codePointAt(position);
} : function(input, position) {
    return (input.charCodeAt(position) - 55296) * 1024 + input.charCodeAt(position + 1) - 56320 + 65536;
};
exports.highSurrogateFrom = 55296;
exports.highSurrogateTo = 56319;

},{}]},["dKqMn","3JDr1"], "3JDr1", "parcelRequire4ef6")

//# sourceMappingURL=babel-preset-solid.936a1af1.js.map
